# Architecture Advanced

## 架构师岗位职责

负责产品及项目的整体架构设计，开发系统核心模块

规划业务架构的合理演进，能够制定合理的开发工作计划并实施

制定相关技术开发规范，对通用技术进行整理，提高技术复用

优化现有架构，提出合理可行的重构方案

对新技术保持非常高的敏感度，同时有能力进行评估并合理引入



## 讲师：李智慧

前阿里 & Intel 架构师，《大型网站技术架构》作者

李智慧老师现任某大厂首席架构师，他是 Apache Spark 源码贡献者，长期从事大型网站架构、大数据的研发工作，曾担任阿里巴巴技术专家、Intel 亚太研发中心架构师、WiFi 万能钥匙 CTO ，著有畅销书《大型网站技术架构：核心原理与案例分析》。

李智慧老师不仅实战经验丰富，并且还很会讲课，有超过 6 年的线下咨询、企业架构内训经验，曾经作为外聘教师为浙江大学硕士研究生开展《面向对象高级编程》课程，备受好评。老师出品了极客时间《从 0 开始学大数据》《后端技术面试 38 讲》，目前已有 2w+ 学员加入。



## 课程大纲

### **Week 1：架构方法：架构师如何做架**

#### **教学目标：**

1. 了解架构训练营的课程设计思路及内容综述。
2. 对架构师以及架构工作有一个深入透彻的理解。
3. 学习软件架构建模的一般方法和工具
4. 学习软件架构设计文档的写作模式

#### **架构工作中的痛点：**

1. 缺乏全局性思维能力
2. 缺乏超越普通开发者的视野和格局
3. 缺乏知识的全面性
4. 对软件开发本质和挑战缺乏理解
5. 缺乏做一个完整的软件架构的方法，不知道该从何下手做架构设计。
6. 缺乏软件建模的能力与技巧，不会灵活应用 UML 进行软件设计。
7. 无法通过设计文档清晰阐述自己的设计思想和方案。
8. 不清楚技术架构和技术团队管理的关系。

#### **通过学习掌握的核心能力：**

1. 对架构工作有一个正确、透彻的理解，开拓视野。
2. 使用UML进行软件设计与建模的能力。
3. 软件设计文档的写法与应用。

#### **详细内容：**

1. 架构师职责：架构工作中都要面临哪些方面的难题？

- 1. 架构师不同的职责划分，以及它们之间的联系。
  2. 训练营的课程内容综述
  3. 形形色色的架构师们

2. 架构师面试：大厂Offer该如何获取？

- 1. 互联网大厂JD解读
  2. 职责要求
  3. 技能要求
  4. 软实力要求
  5. 训练营内容与大厂JD对应关系以及学习重点
  6. 架构师技术面试套路分析

3. 架构概论：你能描述清楚软件架构与架构吗？

- 1. 对软件架构与架构师的一般误解有哪些？
  2. 什么是架构？什么是软件架构？
  3. 架构的一般方法是什么？
  4. 如何做架构？

4. 4+1视图模型：软件开发的本质是什么？如何进行软件架构设计？

- 1. 什么是软件建模？
  2. 为什么要进行软件建模？
  3. 软件建模的方法论
  4. 软件架构设计的成果和产出是什么？

5. 软件建模语言：如何使用UML进行软件架构设计与建模？

- 1. UML建模方法概述
  2. UML静态建模
  3. UML动态建模

6. 软件设计文档：架构师应该如何输出自己的架构设计？

- 1. 如何输出一份有干货的软件设计文档？
  2. 软件设计文档模板

7. 案例：我如何利用UML成为软件架构师？



### **Week 2：框架设计：开发框架是架构师实现自己架构目标的主要手段**

#### **教学目标：**

1. 掌握软件设计的基本原则。
2. 了解框架、工具、组件等概念的区别于应用方式。
3. 掌握开发框架的一般思路与方法。

#### **架构工作中的痛点：**

1. 架构师如何建立自己的技术威信，让技术人员都听他的。
2. 架构师如何掌控软件的架构，保证几十、数百人共同开发的软件不会陷入混乱。

#### **通过学习掌握的核心能力：**

1. 开发一个软件框架的方法、思想、步骤和技巧。
2. 软件设计原则的理解与应用能力。

#### **详细内容：**

1. 软件开发简史：你还在用面向对象编程语言写面向过程的代码吗？

- 1. 计算机与软件编程的历史
  2. 面向对象编程范式的本质分析

2. 框架概述：什么是软件框架，如何开发一个软件框架？

- 1. 软件框架的基本概念，框架与工具的区别。
  2. 如何通过框架掌控软件开发过程。
  3. 开发软件框架的基本方法和原则。

3. 开闭原则：如何不修改代码却能实现需求变更？

- 1. 什么是开闭原则？
  2. 违反开闭原则的代码分析
  3. 策略模式实现开闭原则
  4. 适配器模式实现开闭原则
  5. 观察者模式实现开闭原则

4. 依赖倒置原则：如何不调用代码却能复用代码的功能？

- 1. 什么是依赖倒置原则
  2. 为什么说框架必须遵循依赖倒置原则
  3. 实现依赖倒置原则的代码案例分析

5. 其他软件设计原则：如何用好多态特性设计优雅的软件架构？

- 1. 里氏替换原则
  2. 单一职责原则
  3. 接口隔离原则

6. 案例：反应式编程框架Flower的设计案例分析

- 1. 什么是反应式编程，反应式编程解决什么问题
  2. 反应式编程框架Flower的设计原理分析



### **Week 3：代码重构：代码重构能力是架构师最基本的能力**

#### **教学目标：**

1. 掌握常用软件设计模式
2. 了解常用开源软件中的设计模式

#### **架构工作中的痛点：**

1. 架构师应该写什么样的代码？
2. 架构师如何指导工程师开发优雅的代码？
3. 什么样的情况下该进行代码重构了？
4. 架构师如何如何组织研发团队进行代码重构？

#### **通过学习掌握的核心能力：**

1. 灵活应用设计模式的能力
2. 利用设计模式重构代码的能力

#### **详细内容：**

1. 代码腐坏：糟糕的代码会带来什么样的烦恼？

- 1. 一个代码因需求变更而逐渐腐坏的例子
  2. 糟糕的代码有哪些特点？
  3. 优雅的代码应该是什么样子？

2. 设计模式基础：如何使用设计模式优化代码？

- 1. 设计模式在软件开发中的地位
  2. 用工厂模式实现开闭原则
  3. 建造模式
  4. 原型模式
  5. 单例模式
  6. 适配器模式

3. 案例：JUnit 的设计模式分析：为什么说 JUnit 是设计模式样本？

- 1. 单元测试需求分析
  2. JUnit 中的模板方法模式
  3. JUnit 中的策略模式
  4. JUnit 中的装饰器模式
  5. JUnit 中的组合模式
  6. 实现依赖倒置原则的代码案例分析

4. 案例：我在Intel开发的大数据仓库引擎Panthera设计模式分析：设计模式如何拯救我的工作？

- 1. 大数据仓库架构设计分析
  2. Panthera中的组合模式分析
  3. Panthera中的装饰器模式分析

 

 

### **Week 4：系统架构：系统架构知识是架构师的常识而不是能力**

#### **教学目标：**

1. 理解高并发系统的历史演化过程
2. 理解高并发系统的架构模式
3. 理解高并发系统架构的常用技术解决方案

#### **架构工作中的痛点：**

1. 对大规模高并发系统的整体架构缺乏宏观的认知
2. 对大规模高并发系统的技术挑战缺乏直观认知和知识背景

#### **通过学习掌握的核心能力：**

1. 使高并发系统架构知识成为自己的常识，并本能地应用到自己的架构实践中。
2. 训练系统架构设计时平衡选择技术方案的能力。

#### **详细内容：**

1. 系统架构概述：高并发系统架构面临怎样的挑战？

- 1. 高并发挑战
  2. 高可用挑战
  3. 安全性挑战
  4. 快速迭代的挑战
  5. 垂直伸缩与水平伸缩的策略选择

2. 系统架构体系：高并发系统经历了怎样的演化历程？

- 1. 早期互联网系统架构
  2. 高并发系统架构的演化历程
  3. 互联网企业的技术思想是如何形成的

3. 系统架构模式概述：系统架构设计需要关注哪些方面？

- 1. 高性能架构模式
  2. 高可用架构模式
  3. 可伸缩架构模式
  4. 可扩展架构模式
  5. 安全架构模式

4. 分布式技术体系：一个大规模分布式系统架构包含了哪些技术？

- 1. 前端架构技术体系
  2. 服务端架构技术体系
  3. 存储架构技术体系
  4. 监控与运维技术体系
  5. 大数据技术体系

5. 案例：维基百科架构设计案例分析：20人团队如何开发、运维全球第六大互联网站？

- 1. 维基百科业务背景与技术特点分析
  2. 维基百科的整体系统架构分析
  3. 维基百科的高性能架构分析

6. 案例：淘宝架构演化案例分析：为什么说淘宝最初也很low？

- 1. 淘宝业务变迁历史分析
  2. 淘宝早期的几次重要技术架构重构分析

 

 

### **Week 5-6：技术选型：技术选型能力反映了架构师的综合水平**

#### **教学目标：**

1. 掌握常用分布式技术的架构原理
2. 理解各种分布式技术的优缺点
3. 理解常用分布式技术的产品特点与选型依据

#### **架构工作中的痛点：**

1. 对于常用的分布式技术只知道怎么用，却不理解其内部技术原理
2. 每种分布式技术都有很多产品技术方案，不知道该如何选型

#### **通过学习掌握的核心能力：**

1. 针对不同业务场景，选择合适技术方案的能力，以及在技术方案之中，选择合适产品的能力
2. 超越缓存、消息队列、负载均衡、数据分库分片、NoSQL、搜索引擎等各种分布式技术会用的阶段，理解其内部原理，达到可以优化、修改其代码的能力，必要时，可自己开发同类产品的能力

#### **详细内容：**

1. 分布式缓存架构：为什么说缓存是改善性能的杀手锏？

- 1. 缓存的核心原理与应用场景分析
  2. 缓存的分类
  3. CDN缓存原理分析
  4. 反向代理缓存原理分析
  5. 对象缓存原理分析
  6. 分布式对象缓存的访问模型
  7. 分布式对象缓存的应用场景与注意事项
  8. 缓存失效LRU算法分析
  9. 分布式对象缓存集群扩容的挑战与一致性Hash算法
  10. Memcached与Redis对比与技术选型分析

2. 消息队列架构：如何避免系统故障传递？

- 1. 消息队列的应用场景分析
  2. 消息队列的架构方案
  3. 消息队列架构优缺点分析
  4. Kafka、ActiveMQ等常用消息队列产品选型分析

3. 负载均衡架构：如何用十行代码写一个负载均衡服务器？

- 1. 负载均衡架构的技术原理
  2. 负载均衡的HTTP重定向实现技术
  3. 负载均衡的DNS解析实现技术
  4. 负载均衡的反向代理实现技术
  5. 负载均衡的IP路由实现技术
  6. 负载均衡的链路层路由实现技术
  7. 负载均衡的常用路由算法分析

4. 分布式关系数据库架构？数据库分库、分片有什么区别？

- 1. MySQL主从复制实现分布式架构的技术原理
  2. 数据库分库设计
  3. 关系数据库分片技术实现方案
  4. 分布式数据库中间件MyCat实现原理
  5. 分布式数据库复制、分片混合部署架构方案
  6. 分布式数据库集群扩容技术方案

5. NoSQL数据库架构？NoSQL数据库当初是怎么火起来的？

- 1. CAP原理分析
  2. 分布式系统的数据一致性挑战
  3. 应对数据一致性挑战的几种策略
  4. Cassandra实现数据的技术方案
  5. HBase技术架构与应用分析

6. 分布式锁架构：ZooKeeper是如何实现分布式强一致性的？

- 1. 什么是分布式系统脑裂？
  2. CAP原理再分析
  3. ZooKeeper分布式强一致性原理
  4. ZooKeeper应用场景分析

7. 搜索引擎架构：为什么说成功的架构必须要把握住细节？

- 1. 互联网爬虫系统技术原理
  2. 倒排索引技术原理
  3. Elasticsearch技术原理分析

8. 案例：我在阿里巴巴开发NoSQL系统Doris的设计案例分析：在互联网大厂开发基础技术产品是什么体验？

- 1. 开发 Doris 的背景
  2. Doris 架构设计分析



### **Week 7-9：性能优化：性能优化是架构师展现自己技术全面性的时刻**

#### **教学目标：**

1. 理解主要性能指标的意义
2. 了解性能测试的关键过程
3. 掌握一般性能分析方法和性能优化的思考策略
4. 理解基础技术背后的原理及其对性能的影响

#### **架构工作中的痛点：**

1. 遇到性能问题无从下手，无法量化性能问题的严重程度，也无法衡量优化后的效果
2. 解决性能问题没有系统、全面的解决办法，8只能刻舟求剑套用别人有限的技术方案，解决问题主要靠运气
3. 基本功不扎实，操作系统、文件系统、网络通信、数据库各种基础设施对性能的影响一知半解，解决问题的时候各种混乱

#### **通过学习掌握的核心能力：**

1. 全面掌握系统性能度量标准，性能测试方法的能力
2. 全面分析系统性能以及解决对策的能力
3. 融会贯通各种基础技术对性能影响的能力

#### **详细内容：**

1. 系统性能的主要技术指标：什么情况下性能指标好的系统反而感觉更慢？

- 1. 主观性能指标与客观性能指标
  2. 响应时间
  3. 吞吐量
  4. 并发数
  5. 性能计数器

2. 系统性能测试与分析：架构师如何在省钱与不出事之间走钢丝？

- 1. 性能测试的主要方式
  2. 性能测试
  3. 负载测试
  4. 压力测试
  5. 稳定性测试

3. 操作系统与程序运行时性能分析：程序是如何运行又是如何崩溃的？

- 1. 操作系统架构原理
  2. 操作系统多任务运行机制
  3. 操作系统资源消耗与性能相关性分析

4. 数据结构与内存对象访问性能分析：程序中如何选择合适的数据结构？

- 1. 常用数据结构以及内存存储访问原理
  2. Hash表原理与性能分析
  3. 红黑树原理与性能特性

5. 文件 I/O 性能优化与分析：什么办法可以把硬盘的读写速度提高十万倍？

- 1. 机械硬盘与SSD硬盘性能分析
  2. Linux文件系统架构
  3. 独立硬盘冗余阵列 RAID 如何实现文件高性能读写
  4. 分布式文件系统架构原理

6. TCP/IP协议分析与网络 I/O 优化：互联网应用一次请求响应涉及哪些网络通信？

- 1. TCP/IP协议分析
  2. HTTP协议分析
  3. 异步网络 I/O 及 epool 实现原理

7. 数据库原理与SQL性能分析：应用程序提交SQL为什么要用预编译？

- 1. 数据库架构原理
  2. 数据库连接与SQL提交方式对性能的影响
  3. 数据库文件存储原理与索引的性能影响
  4. 常见SQL性能问题分析

8. JVM虚拟机原理与垃圾回收性能分析：Java垃圾回收为什么那么慢？

- 1. JVM组成架构
  2. JVM程序运行机制
  3. JVM垃圾回收机制与不同回收算法性能分析
  4. JVM常用命令与性能分析方法

9. 大规模分布式系统性能优化的7层协议及案例分析：性能优化该从何着手？

- 1. 数据中心性能优化
  2. 硬件性能优化
  3. 操作系统性能优化
  4. 虚拟机性能优化
  5. 中间件性能优化
  6. 系统架构性能优化
  7. 代码性能优化

10. 案例：阿里巴巴秒杀系统架构设计案例分析：架构师如何应对突发的访问高峰？

- 1. 电商秒杀系统的性能挑战
  2. 秒杀架构设计分析
  3. 秒杀系统性能分析与结果验证

 

### **Week 10 模块分解：模块分解能力是架构师最核心的经验与优势**

#### **教学目标：**

1. 了解微服务架构的核心关键和挑战
2. 掌握微服务架构最佳实践方案
3. 掌握微服务框架及RCP框架设计方法
4. 了解领域模型设计方法

#### **架构工作中的痛点：**

1. 想要上微服务，却不知该从何下手
2. 上了微服务，系统变得更加难以维护，不知道哪里出了问题
3. 实现业务就是CRUD，一点技术含量没有，不知道该如何突破和提高

#### **通过学习掌握的核心能力：**

1. 真正掌控微服务架构的设计能力
2. 领域分析和设计的能力
3. 微服务框架、RPC框架设计、开发能力

#### **详细内容：**

1. 微服务架构：为什么现在微服务架构现在遇到这么多的失败和困难

- 1. 我在阿里巴巴经历的微服务架构重构
  2. 微服务架构设计最困难的是模块分解
  3. 微服务架构落地的最佳实践

2. 模块分解的设计原则：模块的边界在哪里？

- 1. 模块化设计的历史溯源
  2. 模块设计的聚合性原则
  3. 模块设计的依赖性原则

3. 微服务框架Dubbo设计原理与RPC实现分析：如何开发自己的微服务框架？

- 1. WebService架构分析
  2. Dubbo架构设计分析
  3. RPC框架分析

4. 领域驱动设计：架构师如何才能越老越吃香？

- 1. 领域模型模式
  2. 充血模型与贫血模型
  3. 领域驱动设计最佳实践

5. ServiceMesh架构、中台架构、事件驱动架构与网关架构：如何实现系统可扩展？

- 1. ServiceMesh架构分析分析
  2. 中台架构分析
  3. 事件驱动架构分析
  4. 网关架构分析



### **Week 11：安全稳定：系统安全稳定高可用是架构师最主要的KPI**

#### **教学目标：**

1. 了解系统高可用的度量标准及故障管理方法
2. 掌握高可用设计的主要方法与实现原理
3. 掌握常见系统攻击手段与防护策略

#### **架构工作中的痛点：**

1. 系统经常出故障、不稳定，不知道是哪里的问题
2. 解决系统可用性问题，东一下、西一下，没有完整的解决思路和方案
3. 不知道该如何保障系统安全性

#### **通过学习掌握的核心能力：**

1. 系统设计时，全面考虑实现高可用的架构能力
2. 系统故障时，全面分析故障原因，并解决可用性问题的能力
3. 安全性架构原理与思路

#### **详细内容：**

1. 高可用系统的度量标准：如何通过KPI提高系统可用性？

- 1. 可用性度量标准
  2. 系统故障响应流程
  3. 技术团队故障考核方案

2. 系统高可用架构方案：架构师如何避免因为系统崩溃而半夜加班？

- 1. 冗余设计与失效转移
  2. 限流、降级
  3. 服务熔断设计
  4. 高可用的事务
  5. 异步架构实现故障隔离
  6. 异地多活多机房架构

3. 系统高可用运维：如何避免系统发布引起故障？

- 1. 代码分支管理
  2. 发布管理
  3. 预发布管理

4. 系统安全架构：架构师如何避免因数据泄密而背锅？

- 1. 网络攻击与防护
  2. 数据加密与解密
  3. 系统安全防火墙



### **Week 12-13：数据应用：会用数据的架构师可以超越开发及架构**

#### **教学目标：**

1. 掌握Hadoop大数据技术原理与应用
2. 掌握Spark技术原理与应用
3. 掌握Flink等大数据流计算原理与应用
4. 掌握Hive等大数据仓库原理与应用的能力
5. 掌握数据分析的原理与应用
6. 掌握数据挖掘与机器学习的原理与应用

#### **架构工作中的痛点：**

1. 对大数据略知一二，不成体系也无法在实践中应用
2. 技术架构成熟的公司环境中，如何寻找个人新的成长点与职业发展机会

#### **通过学习掌握的核心能力：**

1. 大数据开发与应用的能力
2. 利用数据，发现新商业价值的能力

#### **详细内容：**

1. 大数据原理概述：大数据有什么用？

- 1. 大数据技术的核心思想
  2. 大数据技术体系与发展历史
  3. 大数据主要的应用场景分析

2. 分布式文件系统HDFS：如何存储数百T的数据？

- 1. HDFS架构分析
  2. HDFS高可用设计

3. 大数据计算框架MapReduce：架构师应该有能力自己实现MapReduce计算框架

- 1. MapReduce编程模型与案例分析
  2. Hadoop1架构与执行过程分析
  3. 操作系统资源消耗与性能相关性分析

4. 大数据集群资源管理系统Yarn：为什么说Yarn也是一个框架？

- 1. 大数据集群管理和应用的挑战
  2. Yarn架构分析

5. 大数据仓库Hive：SQL如何转化为MapReduce计算？

- 1. SQL生成MapReduce计算逻辑分析
  2. SQL生成MapReduce处理过程分析
  3. Hive架构分析

6. 快速大数据引擎Spark：Spark为什么比MapReduce快那么多？

- 1. Spark生态体系
  2. Spark为什么更快
  3. Spark编程模型案例分析
  4. Spark架构分析

7. 流式大数据Flink、Storm、Spark Streaming：大数据技术是一脉相承的

- 1. Storm架构原理
  2. Flink架构原理
  3. Spark Streaming架构原理

8. 大数据分析：产品运营好不好，数据全知道

- 1. 数据分析常用指标
  2. 数据可视化
  3. AB测试与数据驱动运营

9. 数据挖掘：如何从数据中发现规律？

- 1. 数据分类预测
  2. 数据关联分析
  3. 推荐引擎算法

10. 机器学习：机器学习和数学的关系是什么？

- 1. 机器学习算法原理
  2. 神经网络算法分析

11. 案例：一个利用数据分析发现运营异常的案例分析

- 1. 数据异常监控
  2. 异常原因分析

12. 案例：Spark 源码性能优化分析案例分析

- 1. 性能优化步骤
  2. Spark 源码性能分析与优化

 

 

 

### **Week 14：技术创新：创新让架构师保持职业发展之路长盛不衰**

#### **教学目标：**

1. 了解创新在架构师职业生涯中的重要作用
2. 理解区块链技术架构原理与典型应用场景
3. 理解物联网技术架构原理与典型应用场景
4. 掌握基于大数据的AI平台架构设计方案
5. 了解5G技术原理与应用场景

#### **架构工作中的痛点：**

1. 多年架构师遇到职业发展瓶颈，如何成长与突破
2. 如何在自己的工作中应用区块链、AI、物联网、5G这些新技术，在未来的技术发展中引领潮流

#### **通过学习掌握的核心能力：**

1. 培养自己对新技术的技术敏感性，获得快速学习新技术的技巧和方法论
2. 应用区块链、AI、物联网、5G这些新技术的能力

#### **详细内容：**

1. 大数据与AI平台：大数据的计算结果如何响应给用户？

- 1. 大数据应用在技术架构方面的挑战
  2. 大数据与AI平台架构方案
  3. 案例：BAT大数据平台架构案例分析

2. 云计算：未来只有云计算

- 1. 公有云与私有云
  2. 虚拟化与容器

3. 区块链技术：为什么说区块链将颠覆生产关系？

- 1. 传统金融货币系统的弊端与缺陷
  2. 比特币的技术架构
  3. 以太坊技术架构
  4. 区块链应用场景分析

4. 物联网技术：无限可能的物联网

- 1. 物联网应用场景分析
  2. 物联网技术架构方案

5. 5G技术：5G真的有那么大价值吗？

- 1. 无线通信与5G技术原理
  2. 5G应用场景分析

6. 案例：我在区块链、大数据等方面的一些技术创新案例分享

 

### **Week 15：技术管理：管理也是架构师的职责**

#### **教学目标：**

1. 掌握管理学与组织行为学的一般原理
2. 掌握架构师解决问题的思路和技巧
3. 了解技术成长的一般规律和最佳实践

#### **架构工作中的痛点：**

1. 架构师也需要带团队，但是对管理发憷，心里没底
2. 架构师要跟很多人打交道，协调很多的关系，自己不善沟通，很多事情搞得事与愿违

#### **通过学习掌握的核心能力：**

1. 技术管理的基本技能
2. 人际沟通的核心技巧

#### **详细内容：**

1. 如何成为优秀的架构师：架构师的职业发展路径是什么？

- 1. 技术进化的金字塔结构
  2. 成为技术专家的发展瓶颈
  3. 成为技术专家的方法与最佳实践

2. 成为技术管理者：技术管理者和传统管理者有什么区别？

- 1. 管理的4要素
  2. 组织行为的特点与规律
  3. 德鲁克的管理学经验

3. 技术沟通之道：你真的知道自己要解决的问题是什么吗？

- 1. 发现问题的真正所在
  2. 如何达成自己的任务目标
  3. 不要掉进解决问题的陷阱

4. 案例：我做CTO的一些经验和心得





## 架构基础

### 架构方法： 架构师如何做架构 

#### 如何成为架构师？ 

- JD（简历）
- 架构师面试
- 大厂 Offer 该如何获取？
- 重新思考过往项目经历，重新设计，提高设计能力，包装简历
- 后端架构师
  - SaaS应用等后台业务的产品调研/讨论以及整体的架构设计
  - 业内难点的技术攻坚，主导核心组件/服务的编码和上线
  - 定位系统瓶颈，提高系统性能/稳定性以及业务扩展性
  - 主导扩部门协作和复杂功能的调研、设计、协调、实施和落地
  - 具备海量数据和大规模分布式系统的设计和开发经验
  - 从设计到实现始终对齐业内一流产品水准
- Java 架构师
- Java 架构师（中间件）
- 架构师



#### 架构师面试题？

- 面试题
- 自我介绍；讲一个最有技术含量的项目，面对的难题，解决方案，关键技术，技术点，沟通表达，手绘流程图，手写代码能力。

**如何写一个架构设计文档，文档中应该包含哪些方面的内容？**



**子类 override 父类的方法后，想要修改抛出的异常，那么子类方法抛出的异常类应该是父类方法抛出异常类的子类还是父类？**

答：子类。



**Spring 是如何实现单例的？和设计模式中单例实现方式有什么不同？**

答：在Spring中，bean可以被定义为两种模式：prototype（多例）和singleton（单例）

singleton（单例）：只有一个共享的实例存在，所有对这个bean的请求都会返回这个唯一的实例。

prototype（多例）：对这个bean的每次请求都会创建一个新的bean实例，类似于new。

Spring bean 默认是单例模式。

简单来说，**spring中的单例是通过单例注册表实现的。**

link：https://blog.csdn.net/w1014074794/article/details/88403568



**淘宝这样的大规模分布式互联网应用系统使用了哪些技术方案和手段，主要解决什么问题？**



**什么是 CAP 原理？请描述某个你熟悉的 NoSQL 产品是如何解决CAP问题的。**



**如何进行性能测试，性能测试的流程是什么?性能测试的主要关注指标有哪些?**



**为什么在系统性能测试的时候，随着并发请求数的逐渐增加，错误响应（或者响应超时）的比例快速增加?请从操作系统的线程与进程调度原理以及计算机内部资源使用角度进行分析。**



**为什么支持异步I/O的Web服务器（比如Nginx）要比阻塞式的Web 服务器（比如Apache)性能好很多，前者要比后者可以处理的并发连接请求多几十甚至数百倍?请从异步I/O的线程阻塞特性进行分析。**



**给定一个key，为什么可以在Hash表中快速查找到value?**



**数据库索引是如何存储的?**



**Java虚拟机的垃圾回收原理是什么?**



**你怎么理解领域驱动设计 DDD？**



**DDD 的优缺点是什么？**



**导致系统故障无法正常访问的原因有哪些?保障系统稳定高可用的方案有哪些?请列举并简述。**



**为什么单向散列加密可以保护用户密码安全，请细化 week2的时序图设计，使用单向散列加密保护用户密码。**



**Spark 为什么比 MapReduce快?**

答：Spark 的出现，就是以快著称。使用DAG，有向无环图数据结构，充分利用内存和硬盘的存储，自动根据内存使用情况，动态选择。



**淘宝，头条这些应用会针对不同用户推荐不同的商品和内容，他们是如何做到的?用了哪些算法?**



**Google 搜索结果页面是如何排序的，正好使用户最想看到的页面排在前面?**



**区块链是如何保证数据无法被篡改的?**

答：区块链加密算法，椭圆加密算法。



**什么是边缘计算?**

答：类似于网关进行简单计算，将算力下沉到用户侧。



**如果你觉得系统需要进行重构，但是老板和团队成员都觉得没必要，你如何说服大家?**



**成为架构师以后，如何承担起架构师的职责，如何开展架构设计工作?**



#### 架构师的主要职责

- 编写架构设计文档（week1)
- 开发编程框架（week2)
- 重构软件代码（week3)
- 设计系统架构（week4)
- 进行技术选型，解决技术应用中的问题（ week5-6)
- 优化系统性能（week7-9)
- 模块分解与微服务架构重构（week10)
- 保障系统安全与高可用（ week11)
- 大数据应用（ week12-13)
- 技术创新（week14)
- 沟通管理（week15)



#### 架构师主要能力

- 编程能力
- 基础技术掌握能力
- 常用技术产品的理解与应用能力
- 性能优化与分析故障的能力
- 常用架构模式和框架的理解与应用能力
- 建模以及设计文档的方法和能力
- 业务理解与功能模块及非功能模块拆解能力
- 快速学习能力
- 沟通与领导能力



#### 什么是软件架构?

软件架构，是有关软件整体结构与组件的抽象描述，用于指导大型软件系统各个方面的设计。——维基百科

**架构**表达元素间的关系，动态关系 + 静态关系。

**架构文档**是给人（老板，工程师，业务）做的，给谁看的，给的相关方的是谁？

![1608603537031](ArchitectureAdvanced.assets/1608603537031.png)



#### 关于软件开发的几个事实

软件技术的进步使得程序员不需要了解技术细节和原理就能开发出能用的软件。让程序员关注更少的事情有助于提高软件开发效率和质量。



#### 什么是架构师?

架构师是做架构设计、对系统架构负责的那个人。

架构师是一顶帽子，而不是一把椅子;架构师是一个角色而不是一个职位。



#### 如何做软件架构

- 编写架构设计文档（week1)
- 开发编程框架（week2)
- 重构软件代码（week3)
- 设计系统架构（week4)
- 进行技术选型，解决技术应用中的问题（ week5-6)
- 优化系统性能（week7-9)
- 模块分解与微服务架构重构（week10)
- 保障系统安全与高可用（ week11)
- 大数据应用（ week12-13)
- 技术创新（week14)
- 沟通管理（week15)



#### 大家关心的一些问题

架构师与全栈工程师的区别是什么?两者之间是否有联系?

架构师应该怎么成长?哪些人适合做架构师?

技术的广度和深度怎么去选择和平衡?

当您面对一个陌生领域，或者复杂问题时，这种情况就好比您的工作经验比较少的领域，您是如何突破自我，做到驾轻就熟的?

有没有什么好的方式沉淀领域（行业）知识，以便构建个人中台?

学完之后，怎么应聘架构师?

感觉单单靠老师讲课还不够，希望老师推荐一些必备技能的书单，让我们在跟着老师学习过程中还可以有目标的去看一些书。



#### 如何通过训练营提高自己

- 架构师训练营，而不是架构训练营。
  - 架构方法、架构模式、关键知识点可以训练，但是架构一定要实践，一定要关注场景。
- 课程中所有的技术都只是例子，通过学习例子训练架构思维，构建知识体系。
  - 通过例子，总结模式，通过模式，构建知识体系。





### 4+1视图模型：软件开发的本质是什么？如何进行软件架构设计？ 

#### 4+1 架构视图

- 软件架构={元素，形式，关系/约束}
- 单一的视图无法完整的表达架构，因此需要具备完整的视图集。
  - 逻辑视图(Logical View)，设计的对象模型。
  - 过程视图（Process View)，捕捉设计的并发和同步特征。
  - 物理视图（Physical View)，描述了软件到硬件的映射，反映了部署特性。
  - 开发视图（Development View），描述了在开发环境中软件的静态组织结构。
  - 场景视图(scenarios)，描述用例场景。

![1608622192138](ArchitectureAdvanced.assets/1608622192138.png)



#### 逻辑视图

相关方:客户，用户，开发组织管理者。

视角:系统的功能元素，以及它们接口，职责，交互。

主要元素:系统，子系统，功能模块，子功能模块，接口。

用途:开发组织划分，成本/进度的评估。

![1608622319263](ArchitectureAdvanced.assets/1608622319263.png)



#### 开发视图

相关者:开发相关人员，测试人员。

视角:系统如何开发实现。

主要元素:描述系统的层，分区，包，框架，系统通用服务，业务通用服务，类和接口，系统平台和相关基础框架。

用途:指导开发组织设计和开发实现。



#### 物理视图

相关者:系统集成商，系统运维人员。

视角:系统逻辑组件到物理节点的物理部署和节点之间的物理网络配置。

主要元素:物理节点以及节点的通信。

![1608622451197](ArchitectureAdvanced.assets/1608622451197.png)



#### 过程视图

相关者:性能优化，开发相关人员。

视角:系统运行时线程，进程的情况。

主要元素:系统进程，线程以及处理队列等。

![1608622513162](ArchitectureAdvanced.assets/1608622513162.png)



#### 场景视图

相关者:用户，设计和开发人员。

视角:概括了架构上最重要的场景（最典型或者最有风险）及其非功能性需求，通过这些场景的实现，阐明了架构的广度或众多架构元素运行的方式。

![1608622609393](ArchitectureAdvanced.assets/1608622609393.png)





### 软件建模语言 ~ 如何使用 UML 进行软件架构设计与建模？

#### 什么是模型?

模型是一个系统的完整的**抽象**。人们对某个领域特定问题的求解及解决方案，对它们的理解和认识都蕴涵在模型中。

通常，开发一个计算机系统是为了解决某个领域特定问题，问题的求解过程，就是从领域问题到计算机系统的映射。

![1608622686945](ArchitectureAdvanced.assets/1608622686945.png)



#### 为什么要建造模型?

- 建造传统模型的目的
  - 为了证明某件事物能否工作
  - 前提:建造模型的成本远远低于建造实物的成本
    - 造飞机
    - 造高楼
- 建造软件模型的目的
  - 为了与它人沟通
  - 为了保存软件设计的最终成果
  - 前提:除非模型比代码更说明问题



#### 何时、何处画图?

- 何时画图?
  - 讨论、交流时
  - 最终设计文档
    - 只保留少量的、重要的图
    - 避免涉及过多内容和实现细节
- 何处画图?
  - 白板
  - 绘图工具，如: Visio、Aastah、亿图图示(win)、edrawmax(mac)
  - draw.io



#### UML 简介

- 什么是 UML?
  - Unified Modeling Language，或统一建模语言
  - 以图形方式描述软件的概念
- UML可用来描述:
  - 某个问题领域
  - 构思中的软件设计
  - 描述已经完成的软件实现





#### UML 图的分类-静态图

静态图 – 通过描述类、对象和数据结构以及它们之间存在的关系，来描述软件要素中不变的逻辑结构。

- 用例图（Use Case Diagrams)
- 对象图(Object Diagrams)
- 类图(Class Diagrams)
- 组件图（Component Diagrams)
- 包图(Package Diagrams)
- 部署图（Deployment Diagrams)



#### UML 图的分类-动态图

动态图 – 通过描绘执行流程或者实体状态变化的方式，来展示软件实体在执行过程中的变化过程。

- 时序图(Sequence Diagrams)
- 活动图(Activity Diagrams)
- 状态图(State Diagrams)
- 合作图（Collaboration Diagrams)



#### 通用模型元素

可以在图中使用的概念统称为模型元素。

模型元素在图中用其相应的**视图元素**（符号)表示，下图给出了常用的元素符号:类、对象、结点、包和组件等。

![1608623085218](ArchitectureAdvanced.assets/1608623085218.png)

模型元素与模型元素之间的**连接关系**也是模型元素，常见的关系有关联（association）、泛化( generalization)、依赖(dependency）和聚合（aggregation)。

- 关联: 连接（connect）模型元素及链接（ link）实例。
- 依赖: 表示一个元素以某种方式依赖于另一种元素。
- 泛化: 表示一般与特殊的关系，即“一般”元素是“特殊”关系的泛化。
- 聚合:表示整体与部分的关系。（每一个小整体组合在一起成为一个大的整体，拆开之后还是一个整体）
- 组合：（每一个零部件组合在一起成为一个新的物品，拆开之后就不是一个整体）
- 继承（继承方法和属性）
- 实现（实现接口，子类 override 父类的方法）

这些关系的图示符号如图所示。

![1608623161146](ArchitectureAdvanced.assets/1608623161146.png)



#### 用例建模(用例图)

用例建模技术，用于描述系统的功能需求。在宏观上给出模型的总体轮廓。通过对典型用例的分析，使开发者能够有效地**了解用户的需求**。

![1608623456700](ArchitectureAdvanced.assets/1608623456700.png)

用例模型描述的是外部执行者(Actor）所理解的系统功能。它描述了待开发系统的功能需求。

它驱动了需求分析之后各阶段的开发工作,不仅在开发过程中保证了系统所有功能的实现，而且被用于验证和检测所开发的系统，从而影响到开发工作的各个阶段和 UML 的各个模型。

用例模型由若干个用例图构成，用例图中主要描述执行者和用例之间的关系。在UML中，构成用例图的主要元素是用例和执行者及其它们之间的联系。

创建用例模型的工作包括:定义系统、确定执行者和用例、描述用例、定义用例间的关系、确认模型。



##### 执行者(Actor)

执行者是指用户在系统中所扮演的角色。执行者在用例图中是用类似人的图形来表示，但执行者可以是人，也可以是一个外界系统。

注意:用例总是由执行者启动的。

如何确定执行者:

- 谁使用系统的主要功能(主执行者)?
- 谁需要从系统获得对日常工作的支持和服务?
- 需要谁维护管理系统的日常运行（副执行者）?
- 系统需要控制哪些硬件设备?
- 系统需要与其它哪些系统交互?
- 谁需要使用系统产生的结果（值)?

![1608623825050](ArchitectureAdvanced.assets/1608623825050.png)



##### 《使用》和《扩展》关系

用例图描述了系统的功能需求，它是从执行者的角度来理解系统，用于捕获系统的需求，规划和控制项目;描述了系统外部的执行者与系统提供的用例之间的某种联系。

图中还有另外两种类型的连接，即《使用》和《扩展》关系，是两种不同形式的泛化关系。

《Use》表示一个用例使用另一个用例。

《Extend》通过向被扩展的用例添加动作来扩展用例。

![1608623978247](ArchitectureAdvanced.assets/1608623978247.png)



##### 项目与资源管理系统的Use case图 示例

系统的主要功能是:项目管理，资源管理和系统管理。

项目管理包括项目的增加、删除、更新。资源管理包括对资源和技能的添加、删除和更新。系统管理包括系统的启动和关闭，数据的存储和备份等功能。

- 分析确定系统的执行者（角色)
  - 项目管理员、资源管理员、系统管理员、备份数据系统。
- 确定用例
  - 项目管理，资源管理和系统管理。
- 对用例进行分解，画出下层的Use case图
  - 对上层的用例进行分解,并将执行者分配到各层次的Use case图中。

![1608624166927](ArchitectureAdvanced.assets/1608624166927.png)



#### 静态建模

任何建模语言都以静态建模机制为基础,标准建模语言UML也不例外。所谓静态建模是指对象之间通过属性互相联系，而这些关系不随时间而转移。

类和对象的建模，是 UML建模的基础。UML 的静态建模机制包括:

- 用例图(Use case diagram)
- 对象图(Object diagram )
- 类图(Class diagram)
- 包图(Package diagram)
- 组件图(Component diagram)
- 部署图(Deployment diagram)



#### 类与对象(类图与对象图)

面向对象的开发方法的基本任务是建立对象模型，是软件系统开发的基础。

UML 中的类图(Class Diagram）与对象图（Object Diagram）表达了对象模型的静态结构，能够有效地建立专业领域的计算机系统对象模型。

![1608624408142](ArchitectureAdvanced.assets/1608624408142.png)



##### 属性（attribute)

属性用来描述类的特征，表示需要处理的数据。

属性定义:

- visibility attribute-name : type = initial-value {property-string}
- 可见性 属性名: 类型=缺省值{约束特性}

其中: 可见性（visibility）表示该属性对类外的元素是否可见。

分为:

- public (+)公有的。
- private (-)私有的。
- protected (#)受保护的。
- 默认（未声明)



##### 操作

对数据的具体处理方法的描述则放在操作部分，操作说明了该类能做些什么工作。操作通常称为函数，它是类的一个组成部分，只能作用于该类的对象上。

操作定义:

- visibility operating-name(parameter-list): return-type {property- string)
- 可见性 操作名（参数表）;返回类型{约束特性}



##### 一个使用 Visio 绘制的类图

![1608624737214](ArchitectureAdvanced.assets/1608624737214.png)



#### 包图(包图)

一个最古老的软件方法问题是:怎样将大系统拆分成小系统。解决该问题的思路之一是将许多类集合成一个更高层次的单位，形成一个高内聚、低耦合的类的集合。

UML 中这种分组机制叫包（Package)。引入包是为了降低系统的复杂性。

![1608625230555](ArchitectureAdvanced.assets/1608625230555.png)·



#### 动态建模

动态模型主要描述系统的动态行为和控制结构。动态行为包括系统中对象生存期内可能的状态以及事件发生时状态的转移，对象之间动态合作关系，显示对象之间的交互过程以及交互顺序，同时描述了为满足用例要求所进行的活动以及活动间的约束关系。

在动态模型中,对象间的交互是通过对象间消息的传递来完成的。对象通过相互间的通信(消息传递）进行合作，并在其生命周期中根据通信的结果不断改变自身的状态。



#### 动态模型

动态模型主要描述系统的动态行为和控制结构。

包括四类图:状态图、活动图、时序图、合作图。

- 时序图（sequence diagram)):是一种交互图，主要描述对象之间的动态合作关系以及合作过程中的行为次序，常用来描述一个用例的行为。
- 活动图（activity diagram):着重描述操作实现中完成的工作以及用例实例或对象中的活动，
  活动图是状态图的一个变种。
- 状态图（state diagram):状态图用来描述对象，子系统，系统的生命周期。
- 合作图(collaboration diagram):用于描述相互合作的对象间的交互关系，它描述的交互
  关系是对象间的消息连接关系。



#### UML中的消息

- 简单消息(simple)
  - 表示控制流，描述控制如何从一个对象传递到另一个对象，但不描述通信的细节。
- 同步消息(synchronous)
  - 是一种嵌套的控制流，用操作调用实现。操作的执行者要到消息相应操作执行完并回送一个简单消息后，再继续执行。
- 异步消息（ asynchronous)
  - 是一种异步的控制流，消息的发送者在消息发送后就继续执行，不等待消息的处理。

![1608625949937](ArchitectureAdvanced.assets/1608625949937.png)



#### 时序图(时序图)

时序图(Sequence Diagram）用来描述对象之间动态的交互行为,着重体现对象间消息传递的时间顺序。

时序图存在两个轴:

- 水平轴表示一组对象
- 垂直轴表示时间

时序图中的对象用一个带有垂直虚线的矩形框表示，并标有对象名和类名。垂直虚线是对象的生命线,用于表示在某段时间内对象是存在的。

对象间的通信通过在对象的生命线之间消息来表示，消息的箭头类型指明消息的类型。

![1608626111728](ArchitectureAdvanced.assets/1608626111728.png)



##### 时序图的形式

有两种使用时序图的方式:一般格式和实例格式。

实例格式详细描述一次可能的交互。没有任何条件和分支或循环，它仅仅显示选定情节(场景)的交互。

而一般格式则描述所有的情节。因此，包括了分支，条件和循环。

![1608626366422](ArchitectureAdvanced.assets/1608626366422.png)



#### 活动图(活动图)

活动图（Activity Diagram)的应用非常广泛,它既可用来描述操作（类的方法）的行为，也可以描述用例和对象内部的工作过程,并可用于表示并行过程。

活动图描述了系统中各种活动的执行的顺序。刻化一个方法中所要进行的各项活动的执行流程。

活动图中一个活动结束后将立即进入下一个活动（在状态图中状态的变迁可能需要事件的触发)。



##### 活动图的模型元素

构成活动图的模型元素有: 活动、转移、对象、信号、泳道等。



##### 活动

- 是构成活动图的核心元素，是具有内部动作的状态，由隐含的事件触发活动的转移。
- 活动的解释依赖于作图的目的和抽象层次，在概念层描述中，活动表示要完成的一些任务
- 在说明层和实现层中，活动表示类中的方法。
- 活动用圆角框表示，标注活动名。
- 模型元素有:活动、转移、对象、信号、泳道等。
- 活动还有其它的图符：初态、终态、判断、同步。

![1608626600430](ArchitectureAdvanced.assets/1608626600430.png)

![1608626726406](ArchitectureAdvanced.assets/1608626726406.png)



##### 转移

- 转移描述活动之间的关系，描述由于隐含事件引起的活动变迁，即转移可以连接各活动及特殊活动（初态、终态、判断、同步线）。
- 转移用带箭头的直线表示，可标注执行该转移的条件，无标注表示顺序执行。

![1608626859186](ArchitectureAdvanced.assets/1608626859186.png)



##### 泳道

- 泳道进一步描述完成活动的对象，并聚合一组活动。活动图是另一种描述交互的方式，描述采取何种动作，做什么（对象状态改变)，何时发生（动作序列)，以及在何处发生（泳道)。
- 泳道也是一种分组机制。

![1608626958816](ArchitectureAdvanced.assets/1608626958816.png)



##### 对象流

- 活动图中可以出现对象，对象作为活动的输入/输出，用虚箭头表示。

![1608627028100](ArchitectureAdvanced.assets/1608627028100.png)



##### 控制图符

- 活动图中可发送和接收信号，发送符号对应于与转移联系在一起的发送短句。接收符号也同转移联系在一起。

![1608627097001](ArchitectureAdvanced.assets/1608627097001.png)



#### 状态图(状态图)

状态图(State Diagram）用来描述一个特定对象的所有可能的状态及其引起状态转移的事件。一个状态图包括一系列的状态以及状态之间的转移。

所有对象都具有状态，状态是对象执行了一系列活动的结果。当某个事件发生后,对象的状态将发生变化。状态图中定义的状态有:

- 初态-状态图的起始点，一个状态图只能有一个初态。
- 终态–是状态图的终点，而终态则可以有多个。
- 中间状态–可包括三个区域:名字域、状态变量与活动域。
- 复合状态–可以进一步细化的状态称作复合状态。

![1608627304099](ArchitectureAdvanced.assets/1608627304099.png)

![1608627377637](ArchitectureAdvanced.assets/1608627377637.png)



#### 合作图(合作图)

合作图（Collaboration Diagram)，也称为协作图，用于描述相互合作的对象间的交互关系和链接（Link）关系。

虽然时序图和合作图都用来描述对象间的交互关系，但侧重点不一样。时序图着重体现交互的时间顺序，合作图则着重体现交互对象间的静态链接关系。

![1608627492357](ArchitectureAdvanced.assets/1608627492357.png)



#### 实现模型

实现模型描述了系统实现时的一些特性，又称为物理体系结构建模。包括源代码的静态结构和运行时刻的实现结构。

实现模型包括:

- 组件图(Component diagram）显示代码本身的逻辑结构，它描述系统中存在的软构件以及
  它们之间的依赖关系。
- 部署图(Deployment diagram）描述了系统中硬件和软件的物理配置情况和系统体系结构。
  显示系统运行时刻的结构，部署图中的简单结点是指实际的物理设备以及在该结点上运行构件或对象。部署图还描述结点之间的连接以及通信类型。



#### 组件图(组件图)

组件(component)

组件定义:系统中遵从一组接口且提供其实现的物理的、可替换的部分。对系统的物理方面建模时，它是一个重要的构造块。

组件可以看作包与类对应的物理代码模块，逻辑上与包，类对应，实际上是一个文件，可以有下列几种类型的构件:

- 源代码构件
- 二进制构件
- 可执行构件

![1608627778155](ArchitectureAdvanced.assets/1608627778155.png)

组件之间的依赖关系是指结构之间在编译，连接或执行时的依赖关系。用虚线箭头表示组件图符:

![1608627795120](ArchitectureAdvanced.assets/1608627795120.png)



#### 部署图(部署图)

部署图用来描述系统硬件的物理拓扑结构以及在此结构上执行的软件，即系统运行时刻的结构。

部署图可以显示计算机结点的拓扑结构和通信路径，结点上执行的组件，特别对于分布式系统，部署图可以清楚的描述系统中硬件设备的配置，通信以及在各硬件设备上各种软构件和对象的配置。

因此，部署图是描述任何基于计算机的应用系统的物理配置或逻辑配置的有力工具，部署图的元素有结点和连接。

部署图中的结点代表某种计算机，通常是某种硬件。同时结点还包括在其上运行的软组件，软件组件代表可执行的物理代码模块。如一个可执行程序。结点的图符是一个立方体。

![1608627987219](ArchitectureAdvanced.assets/1608627987219.png)

部署图各结点之间进行交互的通信路径称为连接，连接表示系统中的结点存在着联系，用结点之间的的连线表示连接，在连接的连线上标注通信类型。

![1608628019307](ArchitectureAdvanced.assets/1608628019307.png)



#### 产品生命周期 UML 图绘制时机

![1608865565174](ArchitectureAdvanced.assets/1608865565174.png)





### 架构设计⽂档模板 

[架构设计⽂档模板.md](./SoftwareDesignDemo.md) 

[架构设计⽂档模板 pdf](./SoftwareDesignDemo.pdf)



### UML 练习 1

食堂就餐卡系统设计

- 系统中每个消费者都有一张卡，在管理中心注册缴费，卡内记着消费者的身份、余额。
- 使用时将卡插入收款机则显示卡上金额，服务员按收款机上数字键，收款机自动计算并显示消费额及余额。
- 管理中心的管理员监视每一笔消费，可打印出消费情况的相关统计数据。

请设计系统用例图，组件图，组件时序图，部署图。



**基于UML的食堂就餐卡系统的设计**：http://www.uml.org.cn/appCase/200701244.asp

用例图：

![1608865892869](ArchitectureAdvanced.assets/1608865892869.png)

部署图：

![1608865935133](ArchitectureAdvanced.assets/1608865935133.png)





### 架构之美：如何遵循康威定律做出优秀架构？

#### 康威定律

设计系统的架构受限制于产生这些设计的组织的沟通结构。

![1608628802574](ArchitectureAdvanced.assets/1608628802574.png)



#### 第一定律

Communication dictates design。

组织沟通方式决定系统设计。

启示：

- 架构设计不仅仅是关于系统的设计，也是关于开发组织方式的设计
- 架构师要关注公司的组织结构，公司的运行方式
- 架构师要关注团队的成员构成，技术水平
- 架构师要对项目计划负责



#### 第二定律

There is never enough time to do something right, but there is always enough time to do it over。

时间再多一件事情也不可能做的完美，但总有时间做完一件事情。

启示：

- 架构是权衡的艺术，没有正确的架构，只有合适的架构;没有完美的架构，但是有灵活的架构。
- 架构师如何面对压力，保守还是激进，目光长远还是只看眼前，将反映在他的架构设计中。
- 真真正正重要的事，只有一件:完成任务。



#### 第三定律

There is a homomorphism from the linear graph of a system to the linear graph of its design organization。

线型系统和线型组织架构间有潜在的异质同态特性。

启示：

- 如果你的团队成员职责混乱，那么你将会设计出一个混乱的系统。
- 每个设计混乱、故障不断的系统背后，都有一个混乱、没有战斗力的团队。重构这样的系统，首先要重构开发团队。
- 架构师不是救世主，在拯救项目之前，先拯救自己。



#### 第四定律

The structures of large systems tend to disintegrate during development, qualitatively more so than with small systems。

大的系统总是比小系统更倾向于分解。

启示

- 随着系统变得更大、更复杂，系统重构拆分是一种必然的冲动。
- 所有能持续发展的系统，都必然变得更大、更复杂。
- 架构师将在系统重构拆分中奠定（失去）自己的技术威望。
- 随着系统发展，微服务架构是一种必然的架构选择，但并不一定是一开始最好的选择。



#### 一个创业公司的技术团队组织结构变迁

![1608629097528](ArchitectureAdvanced.assets/1608629097528.png)





#### GPS

![1608629128651](ArchitectureAdvanced.assets/1608629128651.png)

![1608629147101](ArchitectureAdvanced.assets/1608629147101.png)

![1608629158791](ArchitectureAdvanced.assets/1608629158791.png)



#### 都江堰

![1608629192625](ArchitectureAdvanced.assets/1608629192625.png)



### 形形色色的架构师

#### MBTI 测试



#### 按作用划分架构师

- 设计型架构师
  - 也就是一般意义上的架构师，负责系统架构设计，同时也要负责架构的实施落地、演化发展、推广重构。
- 救火型架构师
  - 充当救火队员的角色，系统出现故障或者“灵异现象”，会请他们出马解决，有时重要而紧急的项目也会
    由此类架构师主持。
  - 他们通常是公司的元老，对系统有全局性的认识，知道“水有多深”。
- 布道型架构师
  - 对某一领域有较深刻的认识，有时候甚至是坚定的技术信仰，乐于同他人分享自己的知识，希望能够推广自己的技术主张，此类架构师通常有较好的个人影响力。
  - 但有时，由于自身的局限或者不能跟上技术潮流的发展，会成为忽悠型的“大师”、偶像派的专家。
- Geek 型架构师
  - 架构师中的Geek，对某些技术问题的研究达到疯狂偏执的境地，精益求精追求完美。
  - 通常由于知识技能不够全面，不符合许多企业对架构师“高大全”的要求，此类架构师常有怀才不遇之惑。



#### 按效果划分架构师

- 夏尔巴人架构师
  - 夏尔巴人生活在喜马拉雅山麓，协助探险队或者登山爱好者攀登那些8000米以上被称为“生命的禁区”的雪山，帮助他们运送给养到突击队营地，以及作为向导带领登山队员登顶。每一次成功对于登山队员是一次自我的超越，而对于夏尔巴人，不过是完成了一个工作。
  - 夏尔巴人架构师通常会开发项目中最具技术难度和挑战性的模块，从而为整个项目的顺利进行铺平道路。
- 斯巴达人架构师
  - 传说在古希腊，城邦之间发生战争，如果有城邦向斯巴达人求援，斯巴达人只会派出一个人去协助，但只要这一个人就可以扭转战局。
  - 不管项目有多么艰难复杂，只要有斯巴达人架构师，大家就会坚信，项目一定能顺利完成。斯巴达人架构师带给项目组的，不只是技术和方法，更重要的是必胜的信念。这种信念是架构师自己积累起来的气场和影响力。
- 达官贵人架构师
  - 此类架构师或者有傲人的学历，或者有辉煌的履历，或仪表堂堂，或口吐莲花，但是公司里如果有个吃人的怪兽，悄悄地把此类架构师都吃光了，也没人会发现。



#### 按职责角色划分架构师

- 产品架构师
  - 负责具体互联网产品的技术架构。当产品业务规划确定后，产品架构师就要开始产品的架构设计了，和运营团队确定PV数、用户数、商品数等产品运营目标、发展规划、非功能指标;和产品经理确定功能需求、模块划分等功能目标;和项目经理确定各种开发资源。获得必要的信息后进行整体架构设计，参与项目开发。产品架构师一般会参与产品的整个生命周期。
- 基础服务架构师
  - 有时候也被称为平台架构师，负责开发基础框架、公共组件、通用服务等平台类产品。
  - 在大型互联网应用中，基础服务承担着海量的数据存储和核心业务处理服务，有许多挑战性的工作。
- 基础设施架构师
  - 负责网络、存储、数据库运维管理的架构师，此类架构师一般有专门的称呼(如DBA等)。
  - 此外，根据具体的职责，在数据挖掘、搜索技术、安全诚信、运维监控等领域也有专门的架构师。



#### 按关注层次划分架构师

- 只关注功能的架构师
  - 架构目标只是完成功能，通常，这不叫架构。
- 关注非功能的架构师
  - 除了产品功能，架构设计也关注性能、伸缩性、安全性、可用性、系统未来的扩展性，以及上线后易于运维管理、监控报警、故障修复等非功能目标。
- 关注团队组织与管理的架构师
  - 架构设计不但关注功能目标和非功能目标，同时还考虑开发团队的成员特点、进度安排、开发过程等，使架构设计和项目管理完美融合。
- 关注产品运营的架构师
  - 架构设计不但关注产品的各项功能、非功能指标和开发过程的可实现性，还关注产品运营是否合理方便，能否达到运营目标，技术架构兼顾产品业务架构。也就是关注技术最终价值的架构师。
- 关注产品和团队未来的架构师
  - 不但关注前面提到的所有方面，还会结合技术发展趋势、公司战略目标、个人及团队发展方向，去思考产品未来的发展前景。
  - 为产品的发展演化符合历史发展趋势而设计并为其奠定一个坚实的基础。



#### 按口碑划分架构师

- 最好的架构师
  - 和团队相处日久，通常情况下团队成员感觉不出他的存在，貌似没有他工作也可以完成得很好，但是如果他真的离开了，大家就会觉得心里空荡荡，没了主心骨。
- 好的架构师
  - 深得团队成员的敬重和信任，承担项目中的重要设计开发工作，团队几乎离不开他。
  - 一般架构师承担了项目中大部分的技术工作，却常常因为团队成员不符合自己的期望而经常雷霆大发。
- 差的架构师
  - 既无技术实力也不善于处理人际关系，常被团队成员鄙视，主要工作是给大家添乱、制造笑话和八卦的谈资。
- 最差的架构师
  - 通过制造压力驱使团队成员努力去完成一些无价值的工作，让每个人都忙碌不堪以使大家都没有注意到他自己其实并不能胜任工作。
  - 这种架构师对组织整体和团队成员的伤害无以复加，却常常因为敬业和努力的形象而得到老板的肯定。



#### 非主流方式划分架构师

- 普通架构师
  - 从问题和需求出发，结合个人经验、组织资源、业界模式进行架构设计，中规中矩，能够切实可行地解决问题满足需求，是架构师中的普通青年。
- 文艺架构师
  - 除了像普通架构师那样在架构设计中解决问题，文艺架构师还会在架构设计中进行一些更前瞻的思考和别出心裁的设计。
  - 此类架构师的设计文档通常会透着文艺青年的小清新范儿，喜欢在文档的开头描述他们与众不同的设计理念和风格。
- 1+1架构师
  - 不包括那些完全不能胜任架构设计工作的架构师，此类架构师喜欢在架构设计中堆砌概念和模式，设计文档宏大而不着调，面面俱到却不解决具体问题，说起来头头是道却不知如何落地。
  - 其根源不是不了解真正的问题就是不掌握正确的方法。有时候也不排除这样一种可能性:做架构设计的目的是为了炫耀自己知道这么多术语。



## 软件开发基础

### 软件开发简史：你还在用面向对象编程语言写面向过程的代码吗？

### 莱布尼茨的奇思怪想

计算机软件编程是个非常新兴的行业，程序员这一职业的出现不过半个多世纪，但是人类从事软件编程的探索却要久远的多，在计算机出现之前，甚至蒸汽机出现之前，人类就开始探索软件编程了。

最早开始编程探索的人是德国人莱布尼兹，早在1700年代，莱布尼兹就期望将各种事物都通过一种逻辑语言进行描述，然后用一种可执行演算规则的机器进行计算，就可以计算出事物的各种结果。这种思想其实和我们现代的软件编程与计算机已经差不多了，莱布尼兹为了实现这个想法，进行了大量的工作，获得了丰硕的成果，其中就包括了微积分和二进制。



### 人类第一位程序媛

莱布尼兹制造可编程计算机的梦想没有成功。又过了100年，法国人雅卡尔发明了一台可编程的织布机，这种织布机读取纸带上的打孔，进而控制织布机织出不同的图案。

于是人们开始尝将打孔纸带用于计算机编程，19世纪中叶，当英国人Ada利用打孔纸带写出人类第一个软件程序的时候，距能够运行这个程序的计算机的发明还有100年的时间，而这个程序已经包含了循环和子程序。

Ada因此被认为是人类第一个程序员，准确的说，是程序媛。科技发明受时代的限制，天才们的想象力和聪明才智却可以超越时代。

![1608866179828](ArchitectureAdvanced.assets/1608866179828.png)



### 什么是计算机?什么是程序?

人类发明制造计算机器有非常悠久的历史，但是这些计算机器都是专门进行数值计算的，加减乘除、微分积分等等。

而从莱布尼兹、Ada，到图灵、冯诺依曼，这些现代计算机的开创者们试图创造的是一种通用的计算机，这种计算机不是读取数值进行计算，而是读取数据进行计算，这些数据本身包含着计算的逻辑，这个数据就是程序。



### 现代计算机与现代的程序

当冯诺依曼在 ENIAC 计算机上输入第一个程序的时候，标志着现代计算机的诞生，也意味着软件编程这一新兴的行业即将出现。

最早的计算机编程非常麻烦，程序员需要将电线编来编去，作为输入数据，以控制计算机的执行，这也是编程这个词的由来。不过很快人们就将打孔纸带应用到计算机上，编程的效率极大提升。

![1608866372669](ArchitectureAdvanced.assets/1608866372669.png)



### 形形色色的编程语言

#### 汇编语言（以下为6502汇编)

```sh
2000: BMI $2009  ;结果为负数,那么转地址2009
2002: BEQ $200c  ;若=0,转地址200c
2004: CLC        ;这里说明>0
2005: ADC #$01
2007: TAY
2008: RTS
2009: LDY #$01
200B: RTS
200C: LDY #$00
200E: RTS
```

每一种CPU都有独特的机器语言，因而需要不同的汇编语言



#### 早期Basic语言

```sh
10 CLS:J=1:TROFF:KEY OFE:DIM
Z(30),B$ (20,20),c(30),BS (22):BS=0:BS$ (1)="YES":BS$(0)="NO":DIM BU$ (11)，PL(11),DI$ (11),cH (11),sc (11),CH$ (11),P2(11):P2(11)=3

11 FORI=0 TO 7:READ B$(I,10):NEXT I
12 FORI=1 TO4:READ B$(I,8):NEXT I
13 FORI=0 To 7:READ B$(I,12):NEXT I
14 FORI=1 TO 4:READ B$ (I,14) :NEXT I
15 P1=3:QF=1:L$="A":R$="D":U$="w":D$="S":P$="P":Q$="Q":M$="o"
16 FORI=1 TO2:READ B$(I,18） :NEXT I
17 FOR I=1 TO 2:READ B$(I,20):NEXT I:FOR I=1 TO 30:C(I)=2:NEXT I:C(20)=1
20 COLOR 7,0,0 :CLS:DIM NA$ (11):DIM NAM$(40)
21 FOR I=1 TO 11
23 READ P2(I),BU$(I),DI$(I),CH(10), SC (I),NA$(I)
25 NEXTI:PLAY "T500"
```

早期Basic语言虽然号称为“高级语言”，但是保留了汇编语言的特征――地址（即行号)。



#### 结构化的 Basic语言(Quick Basic、Visual Basic等)

```sh
DO
	SCREEN 7, ,APage%, VPage% ' Draw to the active page
							' while showing the visual page.
	CLS 1					' Clear the active page.

	' Rotate the cube "Angle%" degrees :
	DRAw "TA" +STR$(Angle%) + Plot$

	' Angle% is some multiple of 15 degrees:
	Angle% = (Angle% + 15)MOD 360
	
	' Drawing is complete,so make the cube visible in its
	' new position by switching the active and visual pages:
	SWAP APage%, VPage%
	
LOOP WHILE INKEYS = ""		' A keystroke ends the program.
```

结构化的Basic语言仍然兼容传统的Basic，而且提供了更好的集成开发环境。

结构化的编程取消了“地址”和Goto语句，代之以几种程序控制“结构”，如:循环、条件等



#### Perl语言

```perl
package Horse;
@ISA = qw (Animal) ;

sub sound { "neigh" }
sub name {
	my $self = shift;
	$$self;
}
sub named {
	my $class = shift;
	my $name = shift;
	bless \$name,$class;
}

my $talking = Horse->named ( "Mr. Ed");
print $talking->name ;
```

Perl是一种脚本语言，最强大的功能是正则表达式。但Perl的语法比较晦涩难懂。

Perl是一种“伪”的面向对象语言。



#### C语言

```c
#include <stdio.h>
#include <stdlib.h>

int main (void){
	puts ( "Hello world ! ");
    return EXIT_sUCCESS;
}
```

C语言是一个结构化的语言



#### C++语言

```c++
#include <iostream>
using namespace std;

int main ()
{
	cout <<"Hello, world ! " <<endl;
    return 0;
}
```

C++向后兼容C的所有功能，并且提供了面向对象的编程机制。



#### Java语言

```java
package my.test;

public class TestMain {
    public static void main (string[ ] args){
    	system.out.println ("Hello world ! ");
}
```

Java是一个完全面向对象的语言，尤其是在当今的Internet编程领域，占领了绝对的市场。



### 编程语言的实质

编程的目的是:用计算机来解决现实世界的问题。

编程的过程即:在计算机所能理解的“模型”（解空间）和现实世界（问题空间）之间，建立一种联系。

编程语言是一种“抽象”的机制，问题是对“谁”来抽象:

![1608867426029](ArchitectureAdvanced.assets/1608867426029.png)



### 问题领域(Problem Domain)

包含与系统所要解决的问题相关的实物和概念的空间。

![1608867508230](ArchitectureAdvanced.assets/1608867508230.png)



### 抽象的种类

#### 机器代码和汇编语言

- 对基础机器进行抽象

![1608867603538](ArchitectureAdvanced.assets/1608867603538.png)



#### 非结构化的高级语言（如Basic, Fortran 等)

- 对计算处理逻辑抽象

![1608867669211](ArchitectureAdvanced.assets/1608867669211.png)



#### 结构化的程序设计

- 开始对问题领域进行一定程度的抽象

![1608867733921](ArchitectureAdvanced.assets/1608867733921.png)



#### 面象对象的程序设计

- 直接表达问题空间内的元素

![1608867778086](ArchitectureAdvanced.assets/1608867778086.png)



### 编程方法的演进

![1608867870077](ArchitectureAdvanced.assets/1608867870077.png)



### 编程的核心要素

- 人
- 客观业务领域
- 计算机

![1608867913012](ArchitectureAdvanced.assets/1608867913012.png)



### 什么是面向对象编程?

第一个成功的面向对象的语言Smalltalk描述:

- 万物皆为对象
- 程序是对象的集合，它们通过发送消息来告知彼此所要做的。
- 每个对象都有自己的由其他对象所构成的存储。
- 每个对象都拥有其类型。
- 某一特定类型的所有对象都可以接收同样的消息。

C++和Java等后期的面向对象语言，都是在这个定义的基础上设计的。



### 什么是对象?

Booch 对于对象的描述: 对象具有状态、行为和标识。

- 状态:表明每个对象可以有自己的数据。
- 行为:表明每个对象可以产生行为。
- 标识:表明每个对象都区别于其它的对象。（唯一的地址)



### 面向对象编程(OOP)的三要素（特征)

- 封装性（Encapsulation)
  - 隐藏实现细节（访问控制)
  - 定义接口
- 继承性(Inheritance)
  - IS-A关系
  - HAS-A关系（组合)
- 多态性（Polymorphism)
  - 后期绑定（虚函数)
  - 向上转形（up Casting)



#### No.1:封装性 - 隐藏实现

封装并不是面向对象编程语言独有的。

面向过程的编程语言，比如C语言，也可以实现封装特性，在头文件.h里面定义方法，而在实现文件.c文件里定义具体的结构体和方法实现，从而使依赖.h头文件的外部程序只能够访问头文件里定义过的方法，这样同样实现了变量和函数的封装，以及访问权限的控制。

![1608868204380](ArchitectureAdvanced.assets/1608868204380.png)



#### No.2:继承性 - 接口的重用

继承也不是面向对象独有的。

语言也可以实现继承。如果A结构体包含B结构体的定义，那么就可以理解成A继承了B，定义在B结构上的方法可以直接（通过强制类型转换）执行A结构体的数据。

![1608868356366](ArchitectureAdvanced.assets/1608868356366.png)



#### No.3:多态性 - 对象互换的魔法

多态也不是面向对象独有的。因为有指向函数的指针，多态事实上在C语言中也可以实现。

但是使用指向函数的指针实现多态是非常危险的，因为这种多态没有语法和编译方面的约束，只能靠程序员之间约定，一旦出现 bug，调试非常痛苦。因此在面向过程语言的开发中，这种多态并不能频繁使用。

而在面向对象的编程语言中，多态非常简单:子类实现父类或者接口的抽象方法，程序使用抽象父类或者接口编程，运行期注入不同的子类，程序就表现出不同的形态，是为多态。

![1608868459309](ArchitectureAdvanced.assets/1608868459309.png)



### 面向对象编程与面向对象分析

面向对象编程不是使用面向对象的编程语言进行编程，而是利用多态特性进行编程。

面向对象分析是将客观世界，即编程的业务领域进行对象分析。

- 充血模型与贫血模型
- 领域驱动设计DDD



### 面向对象设计的目的和原则

面向对象设计的目的

- 强内聚、低耦合，从而使系统
  - 易扩展 - 易于增加新的功能
  - 更强壮 - 不容易被粗心的程序员破坏
  - 可移植 - 能够在多样的环境下运行
  - 更简单 - 容易理解、容易维护

面向对象设计的原则

- 为了达到上述设计目标，有人总结出了多种指导原则
- “原则”是独立于编程语言的，甚至也可以用于非面向对象的编程语言中。



### 设计模式(design patterns)

设计模式是用于解决某一种问题的通用的解决方案。

设计模式也是语言中立的。

设计模式贯彻了设计原则。

Gang of Four ,(Erich Gamma, Richard Helm, Ralph Johnson and John Vlissides）提出了三大类23种基本的设计模式:

- 创建模式
- 行为模式
- 结构模式

在更细分的领域当中还可以总结出许多设计模式:

- 并发编程模式
- Java EE模式 
- etc.



### 框架(frameworks)

框架是用来实现某一类应用的结构性的程序，是对某一类架构方案可复用的设计与实现

- 如同框架结构的大厦的框架
- 简化应用开发者的工作
- 实现了多种设计模式，使应用开发者不需要花太大的力气，就能设计出结构良好的程序来

不同领域的框架

- 微软公司为Windows编程开发了MFC框架。
- Java为它的GUI(图形用户界面）开发了AWT框架。
- 还有许多开源的框架:MyBatis,Spring等。
- Web服务器也有框架:Tomcat



### 框架VS工具

- 框架调用应用程序代码
- 应用程序代码调用工具

- 架构师用框架保证架构的落地
- 架构师用工具提高开发效率



## 软件设计原则

### UML 练习 2

设计一个控制电话拨号的软件。

下面是一个“拨打电话”的Use Case描述:

- 我们按下数字按钮，屏幕上显示号码，扬声器发出按键音。
- 我们按下Send 按钮，系统接通无线网络，同时屏幕上显示正在拨号。



#### 类图

![1609079790943](ArchitectureAdvanced.assets/1609079790943.png)



#### 合作图

![1609079809795](ArchitectureAdvanced.assets/1609079809795.png)





#### 根据 UML 想象程序代码 Button

```java
public class Button {
    public final static int SEND_BUTTON = -99;

    private Dialer dialer;
    private int token;

    public Button(int token, Dialer dialer) {
        this.token = token;
        this.dialer = dialer;
    }
}
```



#### 根据 UML 想象程序代码 press

```java
    public void press() {
        switch (token) {
            case 0:
            case 1:
            case 2:
            case 3:
            case 4:
            case 5:
            case 6:
            case 7:
            case 8:
            case 9:
                dialer.dial();
                break;

            case SEND_BUTTON:
                dialer.dial();
                break;

            default:
                throw new UnsupportedOperationException("unknown button pressed: token =" + token)
        }
    }
```





#### 根据 UML 想象程序代码 Dialer

```java
public class Dialer {
    public void enterDigit(int digit) {
        screen.display(digit);
        speeker.beep(digit);
    }

    public void dial() {
        screen.display("dialing...");
        radio.connect();
    }
}

```



### 软件设计的臭味

软件设计的**最终目的**，是使软件达到“强内聚，松耦合”，从而使软件：

- 易扩展，易于增加新的功能
- 更强壮，不容易被粗心的程序员破坏
- 可移植，能够在多样的环境下运行
- 更简单，容易理解，容易维护

与之相反，一个“不好的”软件，会发出如下**臭味**：

- 僵硬，不易改变
- 脆弱，指向该A，结果B被意外破坏
- 不可抑制，不能适应环境的变化
- 导致误用的陷阱，做错误的事比做正确的事更容易，引诱程序员破坏原有的设计
- 晦涩，代码难以理解
- 过度设计，copy-paste 代码

**僵化性（ Rigidity）** ：很难对系统进行改动，因为每个改动都会迫使许多对系统其他部分的改动。

- 如果单一的改动会导致依赖关系的模块中的连锁改动，那么设计就是僵化的，必须要改动的模块越多，设计就越僵化。

**脆弱性（Fragility）** ：对系统的改动会导致系统中和改动的地方无关的许多地方出现问题。

- 出现新问题的地方与改动的地方没有概念上的关联。要修正这些问题又会引出更多的问题，从而使开发团队就像一只不停追逐自己尾巴的狗一样。

**牢固性（Immobility）** ： 很难解开系统的纠结，使之成为一些可在其他系统中重用的组件。

- 设计中包含了对其他系统有用的部分，而把这些部分从系统中分离出来所需的努力和风险是巨大的。

**粘滞性（Viscosity）** ：做正确的事情比做错误的事情要困难。

- 面临一个改动的时候，开发人员常常会发现会有多种改动的方法。有的方法会保持系统原来的设计，而另外一些则会破坏设计，当那些可以保持系统设计的方法比那些破坏设计的方法更难应用时，就表明设计具有高的粘滞性，作错误的事情就很容易。

**不必要的复杂性（Needless Complexity）** ：设计中包含有不具任何直接好处的基础结构

- 如果设计中包含有当前没有用的组成部分，他就含有不必要的复杂性。当开发人员预测需求的变化，并在软件中放置了处理那些潜在变化的代码时，常常会出现这种情况。

**不必要的重复（ Needless Repetition）** ：设计中包含有重复的结构，而该重复的结构本可以使用单一的抽象进行统-。

- 当copy， cut， paste 编程的时候，这种情况就会发生。

**晦涩性（Opacity）** ：很难阅读、理解。没有很好的表现出意图。

- 代码可以用清晰、富有表现力的方式编写，也可以用晦涩、费解的方式编写。一般说来，随着时间的推移，代码会变得越来越晦涩。



### 一个设计腐化过程的例子

- 编一个从键盘读入字符并输出到打印机的程序



#### copy 程序结构图

![1609079841798](ArchitectureAdvanced.assets/1609079841798.png)

#### copy 程序

```java
void copy() {
    int c;
    while ((c = RdKbd()) != EOF) {
        WrtPrt(c);
    }
}
```



#### copy 程序的第一次修改

几个月以后，老板来找你，说希望 copy 程序能从纸带机中读入信息。

```java
boolean ptFlag = false;
// remember to reset this flag

void copy() {
    int c;
    while ((c = (ptFlag ? Rdpt() : RdKbd())) != EOF) {
        WrtPrt(c);
    }
}
```



#### copy 程序的第二次修改

几个月以后，老板来找你，说客户有时候需要输出纸带打印机上。

```java
boolean ptFlag = false;
boolean punchFlag = false;
// remember to reset these flag

void copy() {
    int c;
    while ((c = (ptFlag ? Rdpt() : RdKbd())) != EOF) {
        punchFlag ? WrtPunch(c) : WrtPrt(c);
    }
}
```





#### 一个遵循 OOD 原则的设计

```java
public interface Reader {
    public int read();
}

public class KeyboardReader implements Reader {

    @Override
    public int read() {
        return readKeyboard();
    }
}

Reader reader = new KeyboardReader();
Writer writer = new Printer();

public void copy() {
  int c;
  while ((c = reader.read()) != EOF) {
    writer.write();
  }
}
```





### 回顾 buttone/ Dialer

有什么臭味吗？

![1609080089077](ArchitectureAdvanced.assets/1609080089077.png)

- 僵硬 不易增加、修改：
  - 增加一种Button类型，就需要对Button类进行修改；
  - 修改Dialer，可能会影响Button。
- 脆弱- switch case/if else语句是相当脆弱的。
  - 当我想修改Send按钮的功能时，有可能不小心破坏数字按钮；
  - 当这种函数很多时，我很有可能会漏掉某个函数，或其中的某个条件分支。
- 不可移植-设想我们要设计密码锁的按钮，它只需要数字按键，但Button的设计使它必须"附带”一个"Send"类型的按钮。



### OOD原则一：开/闭原则（OCP）

OCP - Open/Closed Principle

- 对于扩展是开放的（Open for extension ）
- 对于更改是封闭的（Closed for modification）
- 简言之：不需要修改软件实体（类、模块、函数等） ，就应该能实现功能的扩展。

传统的扩展模块的方式就是修改模块的源代码。如何实现不修改而扩展呢？

- 关键是抽象！



#### 改进 Button: 方法一 简单继承

- 接口继承出两个类，一个实现 数字按钮，另一个实现发送按钮

![1609080126031](ArchitectureAdvanced.assets/1609080126031.png)



#### 改进 Button: 方法二 策略模式 

- 防止过多的重复代码，使用一个 按钮接口

![1609080138541](ArchitectureAdvanced.assets/1609080138541.png)



#### 改进 Button: 方法三 适配器模式

- 将写死的按钮匹配，进行动态的分发，可以实现多个Adapter

![1609080148058](ArchitectureAdvanced.assets/1609080148058.png)



#### 改进 Button: 方法四：观察者模式

- 当添加按键的声音事件的时候，可以使用 listener 接口实现

![1609080157086](ArchitectureAdvanced.assets/1609080157086.png)



#### 想像代码（ButtonListener 接口）

```java
public interface ButtonListener {
    void buttonPressed();
}
```



#### 想像代码（Button 类）

```java
public class Button {
    private List<ButtonListener> listeners;

    public Button() {
        this.listeners = new LinkedList<ButtonListener>();
    }

    public void addListener(ButtonListener listener) {
        assert listener != null;
        listeners.add(listener);
    }

    public void press() {
        for (ButtonListener listener : listeners) {
            listener.buttonPressed();
        }
    }
}
```



#### 想像代码（Phone 类-用来组装）

```java
public class Phone {
    private Dialer dialer;
    private Button[] digitButtons;
    private Button sendButton;

    public Phone() {
        dialer = new Dialer();
        digitButtons = new Button[10];  // 数字按钮

        for (int i = 0; i < digitButtons.length; i++) {
            digitButtons[i] = new Button();

            final int digit = i;

            digitButtons[i].addListener(new ButtonListener() {

                @Override
                public void buttonPressed() {
                    dialer.enterDigit(digit);
                }
            });
        }

        sendButton = new Button();  // 发送按钮
        sendButton.addListener(new ButtonListener() {

            @Override
            public void buttonPressed() {
                dialer.dial();
            }
        });
    }

    public static void main(String[] args) {
        Phone phone = new Phone();

        phone.digitButtons[9].press();
        phone.digitButtons[1].press();
        phone.digitButtons[1].press();

        phone.sendButton.press();

    }

}
```



### OOD原则二：依赖倒置原则(DIP)

DIP - Dependency Inversion Principle

- 高层模块不能依赖低层模块，而是大家都依赖于抽象;
- 抽象不能依赖实现，而是实现依赖抽象。

DIP倒置了什么?

- 模块或包的依赖关系
- 开发顺序和职责

软件的层次化

- 高层决定低层
- 高层被重用

![1609080169793](ArchitectureAdvanced.assets/1609080169793.png)



#### 遵循 DIP 的层次依赖关系

- 顶层的策略，依赖于策略服务接口
- 原理层，依赖上层抽象

![1609080183940](ArchitectureAdvanced.assets/1609080183940.png)



#### 违反 DIP 案例

- 按钮不应该依赖于灯的开关

![1609080195030](ArchitectureAdvanced.assets/1609080195030.png)

- 按钮，应该依赖于按钮服务的接口，下层灯实现上层服务的接口

![1609080204612](ArchitectureAdvanced.assets/1609080204612.png)



#### 架构的核心

好莱坞规则：

- Don't call me, I'll call you

倒转的层次依赖关系

![1609080251837](ArchitectureAdvanced.assets/1609080251837.png)



#### 找出Button背后的抽象

Button的本质是什么?

- 检测用户的按键指令，并传递给目标对象

用什么机制检测用户的按键?

- 不重要

目标对象是什么?

- 不重要



### OOD原则三：Liskov替换原则(LSP)

在Java/C++这样的静态类型语言中，实现OCP 的关键在于抽象，而抽象的威力在于**多态和继承**。

- 一个正确的继承要符合什么要求呢?
- 答案:Liskov替换原则

1988年，Barbara Liskov描述这个原则:

- 若对每个类型T1的对象o1，都存在一个类型T2的对象 o2，使得在所有针对T2编写的程
  序P中，用o1替换o2后，程序Р的行为功能不变，则T1是T2的子类型。
- 简言之:子类型(subtype）必须能够替换掉它们的基类型(base type)。



#### 举例说明

假设: Horse是WhiteHorse和 BlackHorse的基类

在使用Horse对象的任何场合，我们可以把 WhiteHorse对象传进去，以取代 Horse对象，程序仍然正确。（但是小马 is 马，就不可以在任何场景下取代马了。）

![1609080263250](ArchitectureAdvanced.assets/1609080263250.png)



#### LSP的反命题不成立

墨子曾经曰过:《墨子 小取》

- “娣，美人也，爱娣，非爱美人也...

![1609080272711](ArchitectureAdvanced.assets/1609080272711.png)



#### 违反 LSP 的案例一

- 一旦在程序中使用if判断，多个的时候，就已经违反了里氏替换原则

```java
    void drawShape(Shape shape) {
        if (shape instanceof Circle) {
            drawCircle((Circle) shape);
        } else if (shape instanceof Square) {
            drawSquare((Square) shape);
        } else {
            // ....
        }
    }
```



#### 违反 LSP 的案例二

不符合IS-A关系的继承，一定不符合LSP

JDK中的错误设计:

![1609080281255](ArchitectureAdvanced.assets/1609080281255.png)



#### 违反 LSP 的案例三

下面是一个 长方形 类，接着创建一个 正方形类。

```java
public class Rectangle {
    private double width;
    private double height;

    public void setWidth(double w) {
        width = w;
    }

    public void setHeight(double h) {
        height = h;
    }

    private double getWidth() {
        return this.width;
    }

    private double getHeight() {
        return this.height;
    }
}
```



#### 正方形 IS-A 长方形吗？

Rectangle 包含 width 和 height，但 Square 只需要 side 就可以了。

```java
public class Square extends Rectangle {
    @Override
    public void setWidth(double w) {
        width = height = w;
    }

    @Override
    public void setHeight(double h) {
        height = width = h;
    }
}
```

假如有一个方法：

```java
    void testArea(Rectangle rect) {
        rect.setWidth(3);
        rect.setHeight(4);

        assert 12 == rect.calculatedArea(); // 传入Square，正方形的时候将会断言失败
    }
```

![1609080290092](ArchitectureAdvanced.assets/1609080290092.png)



#### 为什么正方形IS-NOT-A长方形呢?

IS-A关系是关于**行为**的。

- 从行为方式来看，正方形和长方形是不同的。

从对象的属性来证明这一论点，对于同一个类，所创建的不同对象，它们的:

- 标识 – 是不同的。
- 状态 – 是不同的。
- 行为 – 是相同的。
- 因此，设计和界定一个类，应该以其行为作为区分。



#### 从“契约”的角度来看LSP

LSP要求，凡是使用基类的地方，一定也适用于其子类。

从Java语法角度看，意味着:

- 子类一定得拥有基类的整个接口。
- 子类的访问控制不能比基类更严格。
  - 例如，Object类中有一个方法:
    - protected Object clone();
  - 子类中可以覆盖(override)之并放松其访问控制:
    - public Object clone();
  - 但反过来是不行的，例如:
    - 覆盖public String tostring()方法，并将其访问控制缩小成private，编译器不可能允许这样的代码通过编译。

从更广泛的意义来看，子类的“契约”不能比基类更“严格”

- 例如，正方形长宽相等，这个契约比长方形要严格，因此正方形不是长方形的子类。
- 例如，Properties的契约比 Hashtable更严格。



#### 如何重构代码，以解决LSP问题?

最简单的办法是，提取共性到基类:

![1609080300124](ArchitectureAdvanced.assets/1609080300124.png)



#### 方法2 改成组合

![1609080307734](ArchitectureAdvanced.assets/1609080307734.png)



#### 继承vs.组合

继承和组合是OOP的两种扩展手段

继承的优点:

- 比较容易，因为基类的大部分功能可以通过继承直接进入子类。

继承的缺点:

- 继承破坏了封装，因为继承将基类更多的细节暴露给子类。因而继承被称为“白盒复用”。
- 当基类发生改变时，可能会层层影响其下的子类。
- 继承是静态的，无法在运行时改变组合。
- 类数量的爆炸。

应该优先使用组合



#### 何时检测 LSP?

一个模型，如果孤立地看，并不具有真正意义上的有效性。

- 孤立地看，Rectangle和 Square并没有什么问题。

通过它的客户程序才能体现出来

- 从对基类做出合理假设的客户程序的角度来看，Rectangle和Square这个模型就是有问题
  的。

有谁知道设计的使用者会做出什么合理的假设呢?

- 大多数这样的假设都很难预测。
- 避免“过于复杂”或“过度设计”。
- 只预测明显的违反LSP的情况，而推迟其它的预测。



#### 可能违反LSP的征兆

- 派生类中的退化函数

```java
public class Base {
    public void func(){
        /*
        * do something.
        * */
    }
}

public class Derived extends Base{
    @Override
    public void func() {
        // .....
    }
}
```

- 派生类中抛出基类不会产生的异常

```java
public class Derived extends Base {
    @Override
    public void func() {
        throw new UnsupportedOperationException();
    }
}
```



### OOD原则四：单一职责原则(SRP)

SRP - Single Responsibility Principle

- 又被称为“内聚性原则(Cohesion) ”，意为:
  - 一个模块的组成元素之间的功能相关性。
- 将它与引起一个模块改变的作用力相联，就形成了如下描述:
  - 一个类，只能有一个引起它的变化的原因。

什么是职责?

- 单纯谈论职责，每个人都会得出不同的结论
- 因此我们下一个定义∶
  -  一个职责是一个变化的原因。



#### 违反 SRP原则的后果

举例说明:

- Rectangle类包含了两个职责:
  - draw()在GUI上画出自己;
  - area()用来计算自身的面积。
- 有两个应用分别依赖Rectangle:
  - 计算几何应用，利用Rectangle计算面积。
  - 图形应用，利用Rectangle绘制长方形，也需要计算面积。

![1609080318727](ArchitectureAdvanced.assets/1609080318727.png)

- 后果
  - 脆弱性 – 把绘图和计算功能耦合在一起，当修改其中一个时，另一个功能可能会意外受损。
  - 不可移植性 – 计算几何应用只需要使用“计算面积”的功能，却不得不包含GUI的依赖。
- 改进

![1609080328432](ArchitectureAdvanced.assets/1609080328432.png)



#### 区分类的方法：分清职责

职责 – 变化的原因

- 有时区分一个类包含了几个职责并不明显，例如:

  - ```java
    interface Modem{
        void dial(String pno);
        void hangup();
        
        void send(char c);
        void recv();
    }
    ```

- 假如应用程序连接Modem的方式会发生变化，例如: dial的参数会因此而变化，那么这个设
  计会导致“僵化性”的问题。此时，应该把连接和收发这两个职责分离:

何时分离职责?当变化发生时。

![1609080341454](ArchitectureAdvanced.assets/1609080341454.png)



#### 一种常见的违反 SRP 情形

Employee包含了两个职责:

- 业务逻辑
- 持久化逻辑

这两个职责通常不应该混合在一起:

- 业务变化快，持久化逻辑变化慢
- 变化的原因也不同

![1609080351501](ArchitectureAdvanced.assets/1609080351501.png)



### OOD原则五：接口分离原则（ISP)

ISP - Interface Segregation Principle

- 不应该强迫客户程序依赖它们不需要的方法。

ISP和 SRP的关系

- ISP和 SRP是相关的，都和“内聚性”有关。
- SRP指出应该如何设计一个类 -- 只能有一种原因才能促使类发生改变。
- ISP指出应该如何设计一个接口 -- 从客户的需要出发，强调不要让客户看到他们不需要的方法。



#### 以前面Modem为例

事实上，要完全做到SRP是困难的，例如在Modem例子中，“连接”环节和“收发数据”环节有内在的关系，可能必须写在一个类中。

但是我们仍然可以把接口分开，这样当“连接”的方法改变时，那些只关心“收发数据”的程序不会受到影响。

![1609080341454](ArchitectureAdvanced.assets/1609080341454.png)



#### 胖接口 - 另一个例子

这是一个可定时关闭的门。

在这个例子中，Door类的接口中包含了timeout方法，然而这个方法对不需要timeout机制的门是没有用的。

```java
    interface TimerClient {
        void timeout();
    }

    interface Door extends TimerClient {
        void lock();

        void unlock();

        boolean isDoorOpen();
    }

    class Timer {
        void register(int timeout, TimerClient client) {
            // ....
        }
    }
```



#### 客户对接口的反作用

Timer是 Door的客户;另外还有一些不需要定时功能的Door客户。

当Timer 发生改变时:

```java
    class Timer {
        public void register(int timeout, int timeoutID, TimerClient client) {
            // ....
        }
    }
```

TimerClient 也被迫改变:

```java
    interface TimerClient {
        void timeout(int timeoutID);
    }
```

从而所有不需要定时功能的Door的客户程序都受到影响。



#### 改进：分离 Door 接口和 TimerClient 接口

- 适配器 方式（Adapter）

![1609080377066](ArchitectureAdvanced.assets/1609080377066.png)



- 多继承 方法

![1609080387163](ArchitectureAdvanced.assets/1609080387163.png)



#### 一个案例

- reBuild 方法，在所有的缓存中，不是必须要的方法，需要分离

![1609080395985](ArchitectureAdvanced.assets/1609080395985.png)



### 推荐阅读

![1609080405548](ArchitectureAdvanced.assets/1609080405548.png)



### 课后练习

- 请描述什么是依赖倒置原则，为什么有时候依赖倒置原则又被称为好莱坞原则？
- 请描述一个你熟悉的框架，是如何实现依赖倒置原则的。
- 请用接口隔离原则优化 Cache 类的设计，画出优化后的类图。
  - 将 Cache 中的 reBuild() 方法单另提出来，实现一个类 CacheManaged
  - 将两个类：Cache  和 CacheManaged 分别继承 BazzCache
  - 详细内容参见：

![1609080395985](ArchitectureAdvanced.assets/1609080395985.png)







### 案例：反应式编程框架 Flower 的设计

#### 程序是如何运行又是如何崩溃的

![1609080423706](ArchitectureAdvanced.assets/1609080423706.png)



#### Flower 反应式重构前后性能对比

![1609080436943](ArchitectureAdvanced.assets/1609080436943.png)



#### 为什么 Flower  可以显著提升系统性能？

![1609080450695](ArchitectureAdvanced.assets/1609080450695.png)



#### Flower 实现异步的基础是Akka的Actor

![1609080462295](ArchitectureAdvanced.assets/1609080462295.png)



#### 5分钟上手 Flower  反应式编程

![1609080477891](ArchitectureAdvanced.assets/1609080477891.png)



#### Flower 可视化流程编排

![1609080489512](ArchitectureAdvanced.assets/1609080489512.png)



#### 兼容 Spring的 Flower Web 开发

![1609141681512](ArchitectureAdvanced.assets/1609141681512.png)



#### Flower 异步数据库访问

![1609141715216](ArchitectureAdvanced.assets/1609141715216.png)



#### Flower 核心模块设计

![1609080511271](ArchitectureAdvanced.assets/1609080511271.png)



#### Flower 的分布式异步微服务解决方案

![1609080524832](ArchitectureAdvanced.assets/1609080524832.png)



#### 为什么选择Flower

Flower 与 WebFlux、RxJava的比较优势

- 开发工程师无需学习函数式编程即可开发反应式系统
- 纯消息驱动，可以实现更灵活的扩展（事件溯源、分布式事务，限流)

- 更好的性能与更低的成本
  - 更好的性能意味着用更少的机器就可以满足系统的并发压力
- 更高的可用性
  - 消息驱动天然限流特性使系统在过高并发和部分组件失效的情况下保障系统不会崩溃



#### Flower 开发

- link：https://github.com/zhihuili/flower

![1609080538730](ArchitectureAdvanced.assets/1609080538730.png)



## 软件设计模式

### 面向对象的设计模式

#### 设计模式的作用

- 应用程序
- 框架
- 设计模式
  - 创建模式，结构模式，行为模式
- OOD的原则
  - OCP/DIP/LSP/SRP/ISP
- OOD的目标
- 强内聚，低耦合的程序



#### 设计模式的定义

什么是设计模式？

- 每一种模式都描述了一种问题的统一解决方案。这种问题在我们的环境中，不停地出现。
- 设计模式是一种可重复使用的解决方案。

一种设计模式的四个部分：

- 模式的名称 - 由少量的字组成的名称，有助于我们表达我们的设计
- 待解问题 - 描述了合适需要运用这种模式，以及运用模式的环境（上下文）
- 解决方案 - 描述了组成设计的元素（类和对象），它们的关系，职责以及合作，但这种解决方案是抽象的，它不代表具体的实现
- 结论 - 运用这种方案所带来的利与弊，主要是指它对系统的弹性，扩展性，和可移植性的影响



#### 设计模式的分类

从功能分

- 创建模式（Creational Patterns）
  - 对类的实例化过程的抽象
- 结构模式（Structural Patterns）
  - 将类或者对象结合在一起形成更大的结构
- 行为模式（Behavioral Patterns）
  - 对在不同的对象中间划分责任和算法的抽象

从方式分

- 类模式
  - 以继承的方式实现模式，静态的
- 对象模式
  - 以组合的方式实现模式，动态的



### 排序问题 - 如何创建一个对象？

![1609902897235](ArchitectureAdvanced.assets/1609902897235.png)



### 利用简单工厂模式

#### 利用简单工厂

![1609902947219](ArchitectureAdvanced.assets/1609902947219.png)



#### 简单工厂及Client 程序

```java
public class SorterFactory {
    public static <T> Sorter<T> getSorter() {
        return new BubbleSorter<T>();
    }
}

public class Client {
    public static void main(String[] args) {
        Integer[] array = {5, 4, 9, 7, 6, 3, 8, 1, 0, 2};

        Sorter<Integer> sorter = SorterFactory.getSorter();
        Sortable<Integer> sortable = SorterableFactory.getSortable(array);

        Comparator<Integer> comparator = ComparatorFactory.getComparator();

        sorter.sort(sortable, comparator);
        // ...

    }
}
```



#### 简单工厂的优缺点

优点：

- 使Client不再依赖Sorter的具体实现（如 BubbleSorter）
- 对Client实现OCP - 增加 Sorter 不影响 Client

缺点：

- 对 Factory 未实现 OCP - 增加 Sorter 需要修改 Factory



#### 对简单工厂的改进一

```java
public class SorterFactory_2 {
    @SuppressWarnings("unchecked")
    public static <T> Sorter<T> getSorter(String implClass) {
        try {
            Class impl = Class.forName(implClass);
            return (Sorter<T>) impl.newInstance();
        } catch (Exception e) {
            throw new IllegalArgumentException("Illegal class name: " + implClass, e);
        }
    }
}

public class Client_2 {
    public static void main(String[] args) {
        Integer[] array = {5, 4, 9, 7, 6, 3, 8, 1, 0, 2};

        Sorter<Integer> sorter = SorterFactory_2.getSorter("demo.sort.impl.BubbleSorter");
        Sortable<Integer> sortable = SorterableFactory.getSortable(array);

        Comparator<Integer> comparator = ComparatorFactory.getComparator();

        sorter.sort(sortable, comparator);
        // ...

    }
}
```



#### 改进一所存在的问题

解决了Factory的OCP问题吗？

- 增加 Sorter实现时，不需要修改Factory了
- 但是仍然需要修改 Client

其他问题

- 丧失了编译时的类型安全
  - Client 和 Factory 均类型不安全
- Client 仍然知道 Sorter的实现是什么
- 限制了 Sorter 的实现只能通过 默认构造函数 创建



#### 对简单工厂的改进二

```java
import java.io.IOException;
import java.util.Properties;

public class SorterFactory_3 {
    private final static Properties IMPLS = loadImpls();

    private static Properties loadImpls() {
        Properties defaultImpls = new Properties();
        Properties impls = new Properties(defaultImpls);

        defaultImpls.setProperty("sorter", "demo.sort.impl.BubbleSorter");

        try {
            impls.load(SorterFactory_3.class.getResourceAsStream("sort.properties"));
        } catch (IOException e) {
            throw new RuntimeException(e);
        }

        return impls;
    }

    @SuppressWarnings("unchecked")
    public static <T> Sorter<T> getSorter() {
        String implClassName = IMPLS.getProperty("sorter");

        try {
            Class implClass = Class.forName(implClassName);

            return (Sorter<T>) implClass.newInstance();
        } catch (Exception e) {
            throw new IllegalArgumentException("Illegal class name: " + implClassName, e);
        }
    }
}

public class Client_3 {
    public static void main(String[] args) {
        Integer[] array = {5, 4, 9, 7, 6, 3, 8, 1, 0, 2};

        Sorter<Integer> sorter = SorterFactory_3.getSorter();
        Sortable<Integer> sortable = SorterableFactory.getSortable(array);

        Comparator<Integer> comparator = ComparatorFactory.getComparator();

        sorter.sort(sortable, comparator);
        // ...

    }
}

// 创建 sorter.properties 文件：
sorter=demo.sort.impl.BubbleSorter
```



#### 改进二的优缺点

优点：

- 满足 OCP ？
  - 对 Client 和 Factory 均满足
  - 满足 OCP 方法
    - 抽象
    - 动态编程（即将编译时类型检查转变成运行时检查）

缺点：

- 缺少编译时类型安全
- 限制了 Sorter 的实现，只能通过 默认构造函数 创建
  - 假如需要传递参数？

这种做法其实相当重要

- 简单工厂非常重要，是许多其他模式的基础
- 而该机制解决了简单工厂模式最致命的问题



### Singleton 单例模式

#### 为什么要使用

Single 模式保证产生单一实例，就是说一个类只产生一个实例。

使用Singleton 有两个原因：

- 因为只有一个实例，可以减少实例频繁创建和销毁带来的资源消耗；
- 当多个用户使用这个实例的时候，便于进行统一控制（比如打印机对象）

前者是性能需求，后者是功能需求



#### Singleton实现有两种方式

- 方法一

```java
public class Singleton1 {
    private Singleton1() {

    }

    private static Singleton1 instance = new Singleton1();

    public static Singleton1 getInstance() {
        return instance;
    }

}
```

- 方法二

```java
public class Singleton2 {
    private Singleton2() {

    }

    private static Singleton2 instance = null;

    public static synchronized Singleton2 getInstance() {
        if (instance == null) {
            instance = new Singleton2();
        }
        return instance;
    }
}
```





#### 说明

- 一定要有私有的构造函数，保证类实例只能通过 getInstance() 方法获得。
- 方法2中 getInstance 的修饰符 synchronized 一定要加上，否则可能会穿绳多重实例
- 尽量使用方法1构造单例实例
- 单例中的成员变量是多线程重用的，可能会产生意想不到的结果，因此尽量将单例设计为无状态对象（只提供服务，不保存状态）





### 适配器模式（Adapter）

- 类的适配器
- 对象的适配器

![1609905941988](ArchitectureAdvanced.assets/1609905941988.png)



#### 代码示例 - 类的适配器

- 这是一个类的适配器
- 由于原 Sortable 接口 和 ArrayList 不兼容，治好定义一个 newSortable

```java
public class SortableList<T> extends ArrayList<T> implements NewSortable<T> {
    
    @Override
    public T getElement(int i) {
        return get(i);
    }

    @Override
    public void setElement(int i, T o) {
        set(i, o);
    }
}

public interface NewSortable<T> {
    int size();

    T getElement(int i);

    void setElement(int i, T o);
}
```



#### 代码示例 - 对象的适配器

- 这是一个对象的适配器

```java
import java.util.List;

public class ListSortable<T> implements NewSortable<T> {

    private final List<T> list;

    public ListSortable(List<T> list) {
        this.list = list;
    }

    @Override
    public int size() {
        return list.size();
    }

    @Override
    public T getElement(int i) {
        return list.get(i);
    }

    @Override
    public void setElement(int i, T o) {
        list.set(i, o);
    }
}

public interface NewSortable<T> {
    int size();

    T getElement(int i);

    void setElement(int i, T o);
}
```



#### 适配器的作用

系统需要使用现有的类，而这个类的接口与我们所需要的不同

- 例如：我们需要对 List 进行排序，但是我们需要一个 Sortable 接口，原有的 List 接口不能满足要求。



#### 适配器的应用

- Buton 类的适配器模式版本

![1609080148058](ArchitectureAdvanced.assets/1609080148058.png)

JDBC Driver

- 是对具体数据库的适配器
- 例如，将Oracle 适配到 JDBC 中

JDBC-ODBC Bridge

- 是将 Windows ODBC 适配到 JDBC 接口中





### JUnit 中的设计模式

#### 如何写单元测试

```java
import junit.framework.TestCase;
import junit.runner.Sorter;

import java.util.Comparator;

public class BubbleSorterTests extends TestCase {
    private Integer[] array;
    private Sorter sorter;

    @Override
    protected void setUp() {
        array = new Integer[]{5, 4, 9, 7, 6, 3, 8, 1, 0, 2};
        sorter = new BubbleSorter();
    }

    public void testSort() {
        Sortable sortable = new ArraySortable(array);
        Comparator comparator = new IntegerComparator();

        sorter.sort(sortable, comparator);

        for (int i = 0; i < 10; i++) {
            assertEquals(i, array[i].intValue());
        }
    }
}
```



#### 实现一个单元测试的步骤

- 创建测试类，从TestCase 派生
- 初始化
  - 覆盖基类的方法： Protected void setUp()
- 清除环境
  - 覆盖基类的方法：Protected void tearDown()
- 书写测试方法
  - 命名规则：public void testXyz()





#### JUint 单元测试是如何执行的？

```java
public abstract class TestCase extends Assert implements Test {
  
    public void runBare() throws Throwable {
      Throwable exception= null;
      setUp();
      try {
        runTest();
      } catch (Throwable running) {
        exception= running;
      }
      finally {
        try {
          tearDown();
        } catch (Throwable tearingDown) {
          if (exception == null) exception= tearingDown;
        }
      }
      if (exception != null) throw exception;
    }
  
  	protected void runTest() throws Throwable {
      // 利用动态机制调用 testXyz()
		}
  
    protected void setUp() throws Exception {
    }

    protected void tearDown() throws Exception {
    }
}
```



#### 在 Eclipse 中运行测试的结果

![1609911613635](ArchitectureAdvanced.assets/1609911613635.png)



#### JUint 单元测试的执行

![1609911654673](ArchitectureAdvanced.assets/1609911654673.png)

​                       

### 模板方法模式（Template Method）

模板方法模式是扩展功能的最基本模式之一

- 它是一种 类的行为模式

它通过继承的方法来实现扩展

- 基类负责算法的轮廓和骨架
- 子类负责算法的具体实现

组合 vs. 继承

- 基于 继承 的模板方法比组合更容易实现
- 在很多情况下，可以适当使用这种模式



#### 模板方法的形式

- 抽象方法
  - protected abstract void step1();
  - 轻质子类实现该步骤
- 具体方法
  - protected void doSomething(){ ... }
  - 子类不需要覆盖，但也可以覆盖之
  - 如果想明确告诉子类 不要覆盖它，最好标明 final
- 钩子方法
  - protected void setUp(){}
  - 空的实现（缺省适配器模式）
  - 子类可选择性的覆盖之，以便在特定的时机做些事



#### Java Servlet 中的模板方法

- init()  属于初始化模板方法
- service() 中的模板，属于处理不同请求方式的模板

![1609912219433](ArchitectureAdvanced.assets/1609912219433.png)





### 策略模式（Strategy）

策略模式是扩展功能的另一种最基本的模式

- 他是一种 对象的行为模式

它是通过组合的方式来实现扩展

![1609913540951](ArchitectureAdvanced.assets/1609913540951.png)



#### 什么时候使用策略模式？

- 系统需要在多种算法中选择一个的时候
- 重构系统时，
  - 将条件语句转换成对于策略的多态性调用
- 策略模式的优点（对比模板方法）
  - 将使用策略的人与策略的具体实现分离
  - 策略对象可以自由组合
- 策略模式可能存在的问题
  - 策略模式仅仅封装了 算法的具体实现，方便添加和替换算法
  - 但它并不关心何时使用何种算反，这个必须要游客户端来决定



#### 策略模式和模板方法的结合

- 何时请求调用什么方法，是不知道的

![1609913850692](ArchitectureAdvanced.assets/1609913850692.png)



#### 测试 Sortable

```java
import junit.framework.TestCase;

public abstract class SortableTests extends TestCase {
    protected Sortable<Integer> sortable;

    @Override
    protected void setUp() throws Exception {
        Integer[] data = new Integer[10];

        for (int i = 0; i < 10; i++) {
            data[i] = i;
        }

        sortable = createSortable(data);

    }

    protected abstract Sortable<Integer> createSortable(Integer[] data);

    public final void testGet() {
        for (int i = 0; i < 10; i++) {
            assertEquals(i, sortable.get(i).intValue());
        }

        try {
            sortable.get(-1);
            fail();
        } catch (RuntimeException e) {

        }
        try {
            sortable.get(10);
            fail();
        } catch (RuntimeException e) {

        }
    }

    public final void testSet() {
        for (int i = 0; i < 10; i++) {
            sortable.set(i, 100);
            assertEquals(100, sortable.get(i).intValue());
        }

        try {
            sortable.set(-1, 999);
            fail();
        } catch (RuntimeException e) {

        }
        try {
            sortable.set(10, 999);
            fail();
        } catch (RuntimeException e) {

        }
    }

    public final void testSize() {
        assertEquals(10, sortable.size());
    }
}
```



#### 测试 ArraySortable

```java
import java.lang.reflect.Array;
import java.util.List;

public class ArraySortableTests extends SortableTests {

    @Override
    protected Sortable<Integer> createSortable(Integer[] data) {
        List<Integer> list = Array.asList(data);
        return new ListSortable<Integer>(list);
    }
}
```



#### 测试 ListSortable

```java
public class ListSortableTests extends SortableTests {
    @Override
    protected Sortable<Integer> createSortable(Integer[] data) {
        return new ArraySortableTests<Integer>(data);
    }
}
```



#### 测试排序程序

![1609913404231](ArchitectureAdvanced.assets/1609913404231.png)







### 组合模式（Composite）

- 组合模式
  - 是一种 对象的结构模式

![1609915093623](ArchitectureAdvanced.assets/1609915093623.png)



#### 组合模式的应用

- 文件系统
- AWT控件

![1609915168427](ArchitectureAdvanced.assets/1609915168427.png)



#### 参数化的单元测试

```java
import junit.framework.TestCase;

import java.util.Comparator;

public abstract class ComparatorTests<T> extends TestCase {
    protected T o1;
    protected T o2;
    protected boolean ascending;
    protected boolean isBefore;

    public ComparatorTests(T o1, T o2, boolean ascending, boolean isBefore) {
        super("testIsBefore");

        this.o1 = o1;
        this.o2 = o2;
        this.ascending = ascending;
        this.isBefore = isBefore;
    }

    public void testIsBefore() {
        assertEquals(isBefore, createComparator(ascending).isBefore(o1, o2));
    }

    protected abstract Comparator<T> createComparator(boolean ascending);

}

import junit.framework.Test;
import junit.framework.TestSuite;

import java.util.Comparator;

public class IntegerComparatorTests extends ComparatorTests<Integer> {

    public static Test suite() {
        TestSuite suite = new TestSuite("IntegerComparatorTests");

        suite.addTest(new IntegerComparatorTests(1, 1, true, false));
        suite.addTest(new IntegerComparatorTests(1, 2, true, true));
        suite.addTest(new IntegerComparatorTests(2, 1, true, false));

        suite.addTest(new IntegerComparatorTests(1, 1, false, false));
        suite.addTest(new IntegerComparatorTests(1, 2, false, false));
        suite.addTest(new IntegerComparatorTests(2, 1, false, true));

        return suite;
    }

    public IntegerComparatorTests(Integer o1, Integer o2, boolean ascending, boolean isBefore) {
        super(o1, o2, ascending, isBefore);
    }

    @Override
    protected Comparator<Integer> createComparator(boolean ascending) {
        return new IntegerCoparator(ascending);
    }
}
```



#### 测试包（Test Suite）

- 上述代码生成一个 测试包

![1609914650830](ArchitectureAdvanced.assets/1609914650830.png)



#### 生成更复杂的测试包

```java
import junit.framework.Test;
import junit.framework.TestSuite;

public class AllTests {
    public static Test suite() {
        TestSuite suite = new TestSuite("sort");

        suite.addTestSuite(BubbleSorterTests.class);
        suite.addTestSuite(InsertionSorterTests.class);

        suite.addTestSuite(ArraySortableTests.class);
        suite.addTestSuite(ListSortableTests.class);

        suite.addTest(IntegerComparatorTests.suite());
        suite.addTest(ComparableComparatorTests.suite());

        return suite;
    }
}
```

![1609915000001](ArchitectureAdvanced.assets/1609915000001.png)



#### 从组合设计模式看Go语⾔的多态特性

Go语言没有关于对象的关键词，没有class，没有extends，没有implements，但是Go语言依然是一种完整的面向对象编程语言，拥有面向对象编程语言的三大特性：封装、继承、多态。

传统的面向对象编程语言通过override和overwrite实现多态，特别是对接口的override，使面向对象编程呈现出迷人的特性：针对接口编程，运行期注入实现，使程序呈现多态的特性。

面向对象设计模式中最让人困惑，最引人入胜的就是那些灵活应用对象多态特性的模式。

而Go语言的多态更加灵活，在传统的面向对象编程中，关于组合还是继承总有许多争论，不良继承又带来诸多问题。

Go语言中组合就是继承（extends），struct中包含另一个struct，就拥有了另一个 struct的成员和方法。

```go
//树的中间节点
type node struct {
   *list.List //（匿名）组合即继承，node拥有了list的特性
   name       string
}
```

Go语言定义就是实现（implements），go语言可以定义接口（interface），也可以定义struct上的方法，但是方法不需要显式实现接口，只要方法签名一致就可以，如果一个struct上定义的方法实现了interface上定义的所有方法，那么就认为该struct实现了该接口。

```go
//接⼝，关于树的遍历操作都在这⾥
type tree interface {
   do()
}

func (l leaf) do() { //定义即实现，leaf实现了tree接⼝
   fmt.Println(l.name + " leaf do something.")
}
```

一个完整的关于树的遍历的go语言实现如下，利用go的多态特性，不需要递归。

```go
package main

import (
   "container/list"
   "fmt"
)

//接⼝，关于树的遍历操作都在这⾥
type tree interface {
   do()
}

//树的中间节点
type node struct {
   *list.List //（匿名）组合即继承，node拥有了list的特性
   name       string
}

//树的叶⼦
type leaf struct {
   name string
}

func (n node) do() {                             //定义即实现,node实现了tree接⼝
   for e := n.Front(); e != nil; e = e.Next() { //node拥有了list的特性
      e.Value.(tree).do()
   }
   fmt.Println(n.name + " node do something.")  // 写下面是深度优先遍历
}
func (n node) addSub(sub tree) {
   n.PushBack(sub)
}
func (l leaf) do() { //定义即实现，leaf实现了tree接⼝
   fmt.Println(l.name + " leaf do something.")
}

func main() {
   //定义树的节点
   n1 := node{list.New(), "n1"}
   n2 := node{list.New(), "n2"}
   l1 := leaf{"l1"}
   l2 := leaf{"l2"}
   //构造树的结构
   n2.addSub(l2)
   n1.addSub(n2)
   n1.addSub(l1)
   //遍历树
   n1.do()
}
```

以上为树的深度优先遍历，如果想改为广度优先遍历，只需要调整一行代码

```go
package main

import (
   "container/list"
   "fmt"
)

//接⼝，关于树的遍历操作都在这⾥
type tree interface {
   do()
}

//树的中间节点
type node struct {
   *list.List //（匿名）组合即继承，node拥有了list的特性
   name       string
}

//树的叶⼦
type leaf struct {
   name string
}

func (n node) do() { //定义即实现，node实现了tree接⼝
   fmt.Println(n.name + " node do something.")  // 写上面是广度优先遍历
   for e := n.Front(); e != nil; e = e.Next() { //node拥有了list的特性
      e.Value.(tree).do()
   }
}

func (n node) addSub(sub tree) {
   n.PushBack(sub)
}
func (l leaf) do() { //定义即实现，leaf实现了tree接⼝
   fmt.Println(l.name + " leaf do something.")
}

func main() {
   //定义树的节点
   n1 := node{list.New(), "n1"}
   n2 := node{list.New(), "n2"}
   l1 := leaf{"l1"}
   l2 := leaf{"l2"}
   //构造树的结构
   n2.addSub(l2)
   n1.addSub(n2)
   n1.addSub(l1)
   //遍历树
   n1.do()
}
```

​	



### 装饰器模式（Decorator）

#### 测试排序程序的性能

冒泡排序和插入排序，谁更快？

- 这种测试必须重复多次（如10000次），才能比较准确的计算出性能
- 如何让 BubbleSorterTests 和 InsertionSorterTests 重复运行多次，而不需要修改他们的代码？
- 如何计算时间？

运用 JUnit 扩展包中的辅助类：

- junit.extensions.TestSetup
- Junit.extensions.RepeatedSetup



#### 性能测试程序

```java
import junit.extensions.RepeatedTest;
import junit.extensions.TestSetup;
import junit.framework.Test;
import junit.framework.TestSuite;
import org.copydays.rmliu.JUnit.BubbleSorterTests;

public class PerformanceTests extends TestSetup {

    private long start;
    private int repeat;

    public PerformanceTests(Test test, int repeat) {
        super(new RepeatedTest(test, repeat));

        this.repeat = repeat;
    }

    protected void setUp() {
        start = System.currentTimeMillis();
    }

    protected void tearDown() {
        long duration = System.currentTimeMillis() - start;

        System.out.printf("%s repeated , %d times, takes %d ms \n", getTest(), repeat, duration);
    }

    public static Test suite() {
        TestSuite suite = new TestSuite("performance");

        Test bubbleTests = new TestSuite(BubbleSorterTests.class);
        Test insertionTests = new TestSuite(InsertionSorterTests.class);

        suite.addTest(new PerformanceTests(bubbleTests, 10000));
        suite.addTest(new PerformanceTests(insertionTests, 10000));

        return suite;
    }
}

import junit.framework.Assert;
import junit.framework.Test;
import junit.framework.TestResult;

public class TestDecorator extends Assert implements Test {

    protected Test fTest;

    public TestDecorator(Test fTest) {
        this.fTest = fTest;
    }

    @Override
    public int countTestCases() {
        return 0;
    }

    @Override
    public void run(TestResult result) {
        for (int i = 0; i < fTimesRepeat; i++) {
            if (result.shouldStop()) {
                beak;
            }
            super.run(result);
        }
    }
}
```



#### 装饰器模式（Decorator）

装饰器模式

- 是一种 对象的结构模式

装饰器的作用

- 在不改变对客户端的接口的前提下（对客户端透明）
- 扩展现有对象的功能
- 思考 PerformanceTests 的客户端是指谁？

![1609916819608](ArchitectureAdvanced.assets/1609916819608.png)



#### 装饰器模式示例

```java
public interface AnyThing {
    void exe();
}

public class Dream implements AnyThing {
    private AnyThing a;

    public Dream(AnyThing a) {
        this.a = a;
    }

    @Override
    public void exe() {
        System.out.print("梦装饰了");
        a.exe();
    }
}

public class Moon implements AnyThing {

    private AnyThing a;

    public Moon(AnyThing a) {
        this.a = a;
    }

    @Override
    public void exe() {
        System.out.print("明月装饰了");
        a.exe();
    }
}

public class You implements AnyThing{
    private AnyThing a;

    public You(AnyThing a) {
        this.a = a;
    }

    @Override
    public void exe() {
        System.out.print("你\n");
    }
}

public class DecoratorMain {
    public static void main(String[] args) {
        AnyThing t1 = new Moon(new Dream(new You(null)));
        t1.exe();
//        明月装饰了梦装饰了你

        AnyThing t2 = new Dream(new Moon(new You(null)));
        t2.exe();
//        梦装饰了明月装饰了你
    }
}
```



#### 装饰器模式

装饰器模式，也被笼统的称为 包装器（Wrapper）

- 适配器也被称作 包装器，区别在于适配器是转换成另一个接口，而装饰器是保持接口不变
- 包装器形成一条 链

![1609917888172](ArchitectureAdvanced.assets/1609917888172.png)



#### 装饰器的优缺点

装饰器和模板方法、策略模式的比较

- 装饰器保持对象的功能不变，扩展其外围的功能
- 模板方法和策略模式则保持算法的框架不变，而扩展其内部的实现

装饰器和继承的比较

- 都可以用来扩展对象的功能
- 但装饰器是动态的，继承是静态的
- 装饰器可以任意组合
  - 但这也使装饰器更复杂，有可能会组合出荒谬的结果





#### 装饰器的应用

- Java Servlet中的应用
  - HttpServletRequest/HttpServletRequestWrapper
  - HttpServletResponse/HttpServletResponseWrapper
- 同步化装饰器
  - Collections. synchronizedList（list）
  - 取代原先的Vector、Hashtable等同步类。
- Java I/O类库简介
  - 核心-流，即数据的有序排列，将数据从源送达目的地。
  - 流的种类
    - InputStream、 OutputStream -代表byte流（八位字节流）
    - Reader、Writer -代表char流（Unicode 字符流）
  - 流的对称性
    - 输入-输出对称
    - Byte-Char对称
    - 因此我们只要学习任意一种流，就可以基本了解其它所有的流。



### 作业实践

#### 作业题

请用组合设计模式编写程序，打印输出图1的窗口，窗口组件的树结构如图2所示。

打印输出示例参考图3。

- 图1: 窗口图例

![Picture1](ArchitectureAdvanced.assets/Picture1.png)

- 图2：窗口组件树结构

![Picture2](ArchitectureAdvanced.assets/Picture2.png)

- 图3：程序输出示例

![Picture3](ArchitectureAdvanced.assets/Picture3.png)



#### 答案

- [答案](DesignPatterns/src/main/java/org/copydays/rmliu/homework/Main.java)

```java
import org.copydays.rmliu.homework.component.*;

public class Main {
    public static void main(String[] args) {
        WinForm winForm = new WinForm("Window 窗口");

        winForm.addComponent(new PictureComponent("logo图片"));
        winForm.addComponent(new ButtonComponent("登录"));
        winForm.addComponent(new ButtonComponent("注册"));

        Container frame = new FrameComponent("frame1");
        frame.addComponent(new LableComponent("用户名"));
        frame.addComponent(new TextBoxComponent("文本框"));
        frame.addComponent(new LableComponent("密码"));
        frame.addComponent(new PasswordBoxComponent("密码框"));
        frame.addComponent(new CheckBoxComponent("复选框"));
        frame.addComponent(new TextBoxComponent("记住用户名"));
        frame.addComponent(new LinkLableComponent("记住密码"));
        winForm.addComponent(frame);

        winForm.print();
    }
}
```





### Spring 中的设计模式

#### 依赖注入 DI 与控制反转 IoC

![1609918467379](ArchitectureAdvanced.assets/1609918467379.png)



#### Spring DI 示例

```java
public class Client {
    private UserService userService;

    public void setUserService(UserService userService) {
        this.userService = userService;
    }
}

<?xml version="1.0" encoding="UTF-8"?>
<beans
        xmlns="http://www.springframework.org/schema/beans"
        xmlns:context="http://www.springframework.org/schema/context"
        xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
        xsi:schemaLocation="http://www.springframework.org/schema/beans
        https://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/context
        https://www.springframework.org/schema/context/spring-context.xsd">

    <bean id="userService" class="org.copydays.rmliu.UserDaoImpl">
        <property name="userDao" ref="userDao"/>
    </bean>

    <bean id="client" class="org.copydays.rmliu.Client">
        <property name="userService" ref="userService"/>
    </bean>

</beans>
```



#### Spring DI 示例-xm解析流程

- org.springframework.beans.factory.xml.BeanDefinitionParserDelegate#parseBeanDefinitionElement(org.w3c.dom.Element, org.springframework.beans.factory.config.BeanDefinition)

```java
private static void parseBeanElement(Element beanElement) throws Exception {
    String id = beanElement.getAttribute("id");
    String clsName = beanElement.getAttribute("class");

    // 获取 class 对象
    Class<?> cls = Class.forName(clsName);
    // 直接调用无参构造函数，实例化一个对象
    Object beanObj = cls.getDeclaredConstructor().newInstance();

    beanMap.put(id, beanObj);  // 使用 map 存储所有的beans

    // 获取属性结点，并调用 setter 方法设置属性
    List<Element> subElemList = beanElement.elements();

    for (Element subElem : subElemList) {
        // 获取属性名称
        String name = subElem.getAttribute("name");
        // 获取属性值
        String ref = subElem.getAttribute("ref");

        Object refObj = beanMap.get(ref);
        // 根据属性名称构造 setter 方法名：set + 属性首字母大写 + 属性其他字符，例：setUserDao
        String methodName = "set" + (char) (name.charAt(0) - 32) + name.substring(1);
        // 获取Method 对象
        Method method = cls.getDeclaredMethod(methodName, refObj.getClass().getInterfaces()[0]);
        // 调用setter 方法，设置对象属性
        method.invoke(beanObj, refObj);
    }
}
```



#### Spring 中的单例模式

```java
import java.util.HashMap;
import java.util.Map;

import static sun.tools.jconsole.inspector.XObject.NULL_OBJECT;

public class SingletonDemo {
    private final Map singletonObjects = new HashMap();

    protected Object getSingleton(String beanName) {
        Object singletinObjet = this.singletonObjects.get(beanName); // 检查缓存中是否存在实例

        if (singletinObjet == null) {
            synchronized (this.singletonObjects) {  // 如果为空，则锁定全局变量并进行处理
                singletinObjet = singletonFactory.getObjet(); // 调用工厂的 getObject 方法
                this.earlySingletonObjects.put(beanName, singletinObjet); // 纪录在缓存中
            }
        }
        return (singletinObjet != NULL_OBJECT ? singletinObjet : null);
    }
}
```



#### Spring MVC 模式

![1609927545573](ArchitectureAdvanced.assets/1609927545573.png)

```java
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

import javax.servlet.ServletRequest;
import javax.servlet.http.HttpServletRequest;

@RestController
@RequestMapping("/user/")
public class QueryUserController extends FlowerController {

    @Autowired
    OrderNoService orderNoService;

    @RequestMapping(value = "query")
    public void hello(String userid) {
        logger.info("收到请求： {}", userid);
        doProcess(userid);
    }

    public boolean handler(ServletRequest req, ServlertResponse res) {
        String uri = ((HttpServletRequest) req).getRequestURI();

        Object[] parameters = new Object[args.length];

        for (int i = 0; i < args.length; i++) {
            parameters[i] = req.getParameter(args[i]);
        }

        Object ctl = controller.newInstance(uri);
        Object response = method.invoke(ctl, parameters);
        res.getWriter().println(response.toString());

        return true;
    }
}
```



### Panthera 代码解析

- link: https://github.com/zhihuili/project-panthera-ase
- 初始实验动态语法树代码(几千行代码)参见：[HiveASTGenerator.java](Data/HiveASTGenerator.java)
- 在Hadoop中实现标准SQL 运行的分享 PPT 参见，[Beyond Hive-Standard SQL on Hadoop.pdf](Data/Beyond Hive-Standard SQL on Hadoop.pdf)

阅读步骤

- 打开SQL代码页：https://github.com/zhihuili/project-panthera-ase/tree/master/ql/src/java/org/apache/hadoop/hive/ql/parse/sql

- 点击文件 SqlASTTranslator.java

  - https://github.com/zhihuili/project-panthera-ase/blob/master/ql/src/java/org/apache/hadoop/hive/ql/parse/sql/SqlASTTranslator.java

  - 重点代码：

  - ```java
    // ...    
    if (transformer == null) {
      transformer = TransformerBuilder.buildTransformer();
    }
    transformer.transformAST(sqlASTRoot, context);
    
    // ...
    HiveASTGenerator generator = GeneratorFactory.getGenerator(sqlASTRoot);
    ASTNode hiveTopNode = new ASTNode();
    
    // long b = System.currentTimeMillis();
    // for (int i = 0; i < 1000; i++) {
    generator.generateHiveAST(hiveTopNode, sqlASTRoot, hiveTopNode, sqlASTRoot, context);
    // }
    // long e = System.currentTimeMillis();
    // System.out.println("--------"+(e-b));
    
    ret = (ASTNode) hiveTopNode.getChild(0);
    
    // ...
    ```

- 进入文件夹 transformer

  - https://github.com/zhihuili/project-panthera-ase/tree/master/ql/src/java/org/apache/hadoop/hive/ql/parse/sql/transformer
  - 看到的全部是 各种转换器

- 进入文件 TransformerBuilder.java

  - https://github.com/zhihuili/project-panthera-ase/blob/master/ql/src/java/org/apache/hadoop/hive/ql/parse/sql/transformer/TransformerBuilder.java
  - 可以看到，这个 TransformerBuilder.java ，使用了装饰器模式，一个包一个，直接变成了大粽子

- 进入文件 SqlASTTransformer.java

  - https://github.com/zhihuili/project-panthera-ase/blob/master/ql/src/java/org/apache/hadoop/hive/ql/parse/sql/transformer/SqlASTTransformer.java
  - 可以看到，这个 SqlASTTransformer.java，是一个sql 抽象语法树 转换器 接口

- 进入文件 UnionTransformer.java

  - https://github.com/zhihuili/project-panthera-ase/blob/master/ql/src/java/org/apache/hadoop/hive/ql/parse/sql/transformer/UnionTransformer.java
  - 可以看到，UnionTransformer.java 内部，使用组合模式，使用 SqlASTTransformer tf; 作为一个注入对象

- 进入文件夹 generator

  - https://github.com/zhihuili/project-panthera-ase/tree/master/ql/src/java/org/apache/hadoop/hive/ql/parse/sql/generator
  - 可以看到，generator 全部是 生成器

- 进入文件 BaseHiveASTGenerator.java

  - https://github.com/zhihuili/project-panthera-ase/blob/master/ql/src/java/org/apache/hadoop/hive/ql/parse/sql/generator/BaseHiveASTGenerator.java
  - 内部实现了，HiveASTGenerator 接口，
    - https://github.com/zhihuili/project-panthera-ase/blob/master/ql/src/java/org/apache/hadoop/hive/ql/parse/sql/generator/HiveASTGenerator.java
  - generateHiveAST()方法 实现，在动态语法树中，对 Hive 的查询语句转换

- 进入文件 LikeGenerator.java

  - https://github.com/zhihuili/project-panthera-ase/blob/master/ql/src/java/org/apache/hadoop/hive/ql/parse/sql/generator/LikeGenerator.java
  - 实现 like 语法的 转换
  - 并且，继承了 BaseHiveASTGenerator，继承父类的 baseProcess() 方法

- 进入文件 HavingGenerator.java

  - https://github.com/zhihuili/project-panthera-ase/blob/master/ql/src/java/org/apache/hadoop/hive/ql/parse/sql/generator/HavingGenerator.java
  - 实现 have 语法的转换
  - 并且，使用装饰器模式。覆写与继承了 BaseHiveASTGenerator，继承父类的 generate() 方法

- 至此，整个实现思路就很明确了，

  - 通过将 SQL 语句 通过每一个 关键组，在抽象语法树中进行解析，替换为转换后的关键字与语法



## 互联网系统架构

### 系统架构概述：互联网系统面临怎么样的挑战？

#### 高并发，大流量

需要面对高并发用户，大流量访问。

- Google 日均 PV 数 35亿，日均 IP 访问数 3亿
- 微信在线用户数 10亿
- 天猫双十一活动一天交易额3000亿



#### 高可用

系统 7 x 24 小时不间断服务。

大型互联网站的宕机事件通常会成为新闻焦点。



#### 海量数据

需要存储、管理海量数据。

- Facebook 每周上传的照片数目接近10亿
- 百度收录的网页数目有数百亿
- Google 有近百万台服务器为全球用户提供服务（200万台左右）



#### 用户分布广泛，网络情况复杂

许多大型互联网都是为全球用户提供服务的，用户分布范围广，各地网络情况千差万别。

在国内，有各个运营商网络互通难的问题。

而中美光缆的数次故障，也让一些对国外用户依赖较大的网站不得不考虑在海外建立数据中心。



#### 安全环境恶劣

由于互联网的开放性，使得互联网更容易受到攻击，大型网站几乎每天都会遇到黑客攻击情况。

2011年国内多个重要网站泄漏用户密码，让普通用户也直面一次互联网安全问题。



#### 需求快速变更，发布频繁

和传统软件的版本发布频率不同，互联网产品为快速适应市场，满足用户需求，其产品发布频率也是极高的。

Office 的产品版本以年为单位发布，而一般大型网站的产品每周都有新版本发布上线，至于中小型网站的发布就更频繁了，有时候一天会发布几十次。



#### 渐进式发展

不同于传统软件产品或者企业应用系统，一开始就规划好全部的功能和非功能需求，几乎所有的大型互联网站都是从一个小网站开始，渐进的发展起来的。

- Facebook是伯克扎克同学在哈佛大学的宿舍里开发的；
- Google的第一台服务器部署在斯坦福大学的实验室里；
- 阿里巴巴则是在马云家的客厅里诞生的。

好的互联网产品都是慢慢运营出来的，不是一开始就开发好的。那些刚建立就投入巨资，有巨大背景的网站，后来发展都很惨淡。



### 应对高并发挑战的两个技术方向

#### 垂直伸缩

通过升级硬件和网络吞吐能力可以实现垂直伸缩。由于不需要改变应用架构，所以通常被认为是最简单的短期伸缩性方案。

- 通过使用RAID （独立冗余磁盘阵列）增加I/O吞吐能力。
- 通过切换到SSD （固态硬盘）改善I/O 访问速度。
- 通过增加内存减少I/O 操作
- 通过升级网络接口或者增加网络接口提高网络吞吐能力。
- 更新服务器使用更多处理器或者更多超线程。

![1610020212572](ArchitectureAdvanced.assets/1610020212572.png)



#### 垂直伸缩的缺点

- 达到某个程度后，增加计算能力需要的更多的花费
- 垂直伸缩有物理极限
- 操作系统的设计或者应用程序自身制约着垂直伸缩，最多只能达到某个点

![1610020398306](ArchitectureAdvanced.assets/1610020398306.png)



#### 水平伸缩

水平伸缩是指通过增加服务器提升计算能力的一类架构方法。

水平伸缩被认为是伸缩性的圣杯，水平伸缩可以克服垂直伸缩带来的单位计算成本随计算能力增加而迅速飙升的问题。

另外，水平伸缩总是可以增加更多服务器，这样，就不会像垂直伸缩那样遭遇到单台服务器的极限。

![1610020585997](ArchitectureAdvanced.assets/1610020585997.png)



#### 水平伸缩的优点

![1610020658114](ArchitectureAdvanced.assets/1610020658114.png)





### 互联网架构演化

#### 第零阶段：最简单的互联网应用架构

![1610021203609](ArchitectureAdvanced.assets/1610021203609.png)



#### 第一阶段：应用与数据分离

![1610021256166](ArchitectureAdvanced.assets/1610021256166.png)



#### 第二阶段：使用缓存改善系统性能

- 本地缓存
- 远程分布式缓存

![1610021275696](ArchitectureAdvanced.assets/1610021275696.png)



#### 第三阶段：使用应用服务器集群改善系统的并发处理能力

![1610021301346](ArchitectureAdvanced.assets/1610021301346.png)



#### 第四阶段：数据库读写分离

![1610021322793](ArchitectureAdvanced.assets/1610021322793.png)



#### 第五阶段：使用反向代理和CDN加速网站响应

- 在网络运营商机房，本地部署CDN服务器
- 直接返回图片，文件等静态资源

![1610021342683](ArchitectureAdvanced.assets/1610021342683.png)



#### 第六阶段：使用分布式文件系统和分布式数据库系统

![1610021364730](ArchitectureAdvanced.assets/1610021364730.png)



#### 第七阶段：使用NoSQL和搜索引擎

- 使用键值对方式缓存与存储数据，加速查找

![1610021384989](ArchitectureAdvanced.assets/1610021384989.png)



#### 第八阶段：业务拆分

- 垂直拆分数据表，根据业务领域划分多个服务

![1610021403051](ArchitectureAdvanced.assets/1610021403051.png)



#### 第九阶段：微服务及中台化

- 数据库太大，水平拆分数据表，进行分片处理，sharding

![1610021424409](ArchitectureAdvanced.assets/1610021424409.png)



#### 第十阶段：大数据与智能化





### 互联网架构模式

#### 架构模式

每一个模式描述了一个在我们周围不断重复发生的问题以及该问题解决方案的核心。这样，你就能一次又一次的使用该方案而不必做重复工作。

模式的关键在于模式的可重复性，问题与场景的可重复性带来解决方案的可重复使用。

互联网架构模式就是试图去描述那些为解决互联网系统高性能、高可用、易扩展、可伸缩、安全等目标，被很多互联网应用重复使用的一些解决方案，这些解决方案是互联网软件系统的重要组成部分。



#### 分层

分层是企业应用系统中最常见的一种架构模式，将系统在横向维度上切分成几个部分，每一个部分负责一部分相对比较单一的职责，然后通过上层对下层依赖和调用组成一个完整的系统。



#### 分割

如果说分层是将软件在横向方面进行切分，那么分割就是在纵向方面对软件进行切分。

系统越大，功能越复杂，服务和数据处理的种类也越多，将这些不同的功能和服务分割开来，包装成高内聚，低耦合的模块单元。

一方面有助于软件的开发和维护，另一方面，便于不同模块的分布式部署，提高网站的并发处理能力和功能扩展能力。



#### 分布式

对于大型网站，分层和分割的一个主要目的是为了切分后的模块便于分布式部署，即将不同模块部署在不同的服务器上，通过远程调用协调工作。

分布式意味着解决同样的问题可以使用更多的计算机，计算机越多，CPU，内存，存储资源也就越多，能够处理的并发访问和数据库量就越大。

- 分布式应用和服务
- 分布式静态资源
- 分布式数据和存储
- 分布式计算



#### 集群

使用分布式虽然已经将分层和分割后的模块独立部署，但是对于用户访问集中的模块，比如网站的首页，还需要独立部署的服务器集群化，即多态服务器部署相同应用构成一个集群，通过负载均衡设备共同对外提供服务。



#### 缓存

缓存就是将数据存放在距离计算最近的位置以加快处理速度。

缓存是改善软件性能的第一手段，现代CPU越来越快的一个重要因素就是使用了更多的缓存，在复杂的软件设计中，缓存几乎无处不在。

大型网站架构设计在很多方面都使用了缓存设计。

- CDN
- 反向代理
- 本地缓存
- 远程缓存



#### 异步

计算机软件发展的一个重要目标和驱动力是降低软件耦合性。

事物之间越少直接关系，那么就越少被彼此影响，越可以独立发展。

大型网站架构中，系统解耦合的手段除了前面提到的分层、分割、分布等手段，还有一个重要手段是异步，就是将一一个业务操作分成多个阶段，每个阶段之间通过共享数据而不是直接调用的方法进行协作。

- 提高系统可用性
- 加快网站响应速度
- 消除并发访问高峰



#### 冗余

互联网应用需要 7x 24 小时连续运行，但是服务器总有可能会出现故障，特别是服务规模比较大的时候，服务器宕机是必然事件。

要想保证服务器宕机的情况下网站依然可以继续服务，数据不会丢失，就需要一定程度的服务器冗余运行，数据冗余备份。



#### 自动化

在无人值守的情况下，网站可以正常运行，一切都可以自动化是网站的理想状态。

目前互联网的自动化架构设计主要集中在运维方面。



#### 安全

互联网的开放特性使得其从诞生起就面对巨大的安全挑战，网站在安全架构方面也积累了许多模式：

- 通过密码和手机校验码进行身份认证；
- 登录、交易等操作需要对网络通讯进行加密，网站服务器上存储的敏感数据如用户信息等也进行加密处理；
- 为了防止机器人程序滥用网络资源供给网站，网站使用验证码进行识别；
- 对于常见的用于攻击网站的XSS攻击，SQL注入，进行编码转换等相应处理；
- 对于垃圾信息、敏感信息进行过滤；
- 对转账交易等重要操作根据交易模式和交易信息进行风险控制。





### 互联网系统架构核心要素：如何衡量一个系统的架构设计

#### 高性能

性能是互联网的一个重要指标,除非是没得选择,否则用户无法忍受一个响应缓慢的应 用。

一个打开缓慢应用会导致严重的用户流失,很多时候系统性能问题是系统架构升级优化的触发器。可以说性能是互联网系统架构设计的一个重要方面,任何架构设计方案都必须考虑可能会带来的性能问题。        

也正是因为性能问题几乎无处不在,所以优化网站性能的手段也非常多,从用户端到数据库,从代码到机房部署,影响用户请求的所有环节都可以进行性能优化。



#### 高可用

因为互联网分布式系统使用的服务器硬件通常是普通的商用服务器，这些服务器的设计目标本身并不保证高可用，也就是说，很有可能会出现服务器硬件故障，也就是俗称的服务器宕机。

大型互联网系统通常都会有上万台服务器，每天都必定会有一些服务器宕机，因此系统高可用架构设计的前提是必然会出现服务器宕机，而高可用设计的目标就是当服务器宕机的时候，服务或者应用依然可用。

系统高可用的主要手段是冗余，应用部署在多台服务器上同时提供访问，数据存储在多台服务器上互相备份，任何一台服务器宕机都不会影响应用的整体可用，也不会导致数据丢失。



#### 可伸缩

大型互联网应用通过集群的方式将多台服务器组成一个整体共同提供服务。

所谓伸缩性是指通过不断向集群中加入服务器的手段来缓解不断上升的用户并发访问压力和不断增长的数据存储需求。        

衡量架构伸缩性的主要标准就是是否可以用多台服务器构建集群,是否容易向集群中添加新的服务器。加入新的服务器后是否可以提供和原来的服务器无差别的服务。集群中可容纳的总的服务器数量是否有限制。



#### 可扩展

不同于其他架构要素主要关注非功能性需求，扩展性架构直接关注系统的功能需求。互联网应用快速发展，功能不断扩展，如何设计系统的架构使其能够快速响应需求变化，是系统可扩展架构主要的目的。

衡量系统架构扩展性好坏的主要标准就是在系统增加新的业务产品时，是否可以实现对现有产品透明无影响，不需要任何改动或者很少改动既有业务功能就可以上线新产品。不同产品之间是否很少耦合，一个产品改动对其他产品无影响，其他产品和功能不需要受牵连进行改动。

可扩展架构的主要手段是事件驱动架构和分布式服务。



#### 安全

互联网是开放的,任何人在任何地方都可以访问系统。系统的安全架构就是保护系统不受恶意访问和攻击,保护网站的重要数据不被窃取。        

衡量系统安全架构的标准就是针对现存和潜在的各种攻击与窃密手段,是否有可靠的应对策略。





### 互联网架构技术一览

![1610165845797](ArchitectureAdvanced.assets/1610165845797.png)



#### 前端架构

- App 及 Web 开发技术
- 浏览器及HTTP优化技术
- CDN
- 动静分离
- 图片服务
- 反向代理
- DNS



#### 网关及应用层架构

- 网关架构
- 负载均衡
- 动态页面静态化
- 业务拆分



#### 服务层架构

- 微服务框架
- 分布式消息队列
- 分布式缓存
- 分布式一致性（锁）服务



#### 存储层架构

- 分布式文件
- 分布式关系数据库
- NoSQL数据库



#### 后台架构

- 大数据平台
- 搜索引擎
- 推荐引擎
- 数据仓库



#### 运维与安全

- 数据采集与展示
- 数据监控与报警
- 攻击与防护
- 数据加密与解密



### 推荐书籍

- 大型网站技术架构

![1610166282240](ArchitectureAdvanced.assets/1610166282240.png)



### 维基百科技术架构

- https://zh.wikipedia.org/wiki/Wikipedia:%E9%A6%96%E9%A1%B5
- https://en.wikipedia.org/wiki/Main_Page

![1610166348490](ArchitectureAdvanced.assets/1610166348490.png)



### 淘宝业务发展及技术架构

参考：[淘宝业务发展及技术架构](Data/淘宝业务发展及技术架构.pdf)



### 宅米网技术变迁 - 橱窗互联网公司的技术发展之路

参考：[宅米网技术变迁](Data/宅米网技术变迁-初创互联网公司的技术发展之路.pdf)



### 微博架构与平台安全

参考：[微博架构与平台安全](Data/微博架构与平台安全.pdf)



### 课后练习

一个典型的大型互联网应用系统使用了哪些技术方案和手段，主要解决什么问题？请列举描述。



## 分布式技术选型

### 分布式缓存架构

#### 什么是缓存 Cache

缓存: 存储在计算机上的一个原始数据复制集,以便于访问  -- 维基百科        

缓存是介于数据访问者和数据源之间的一种高速存储, 当数据需要多次读取的时候,用于加快读取的速度。        

缓存( Cache)和缓冲(Buffer)的分别?

> 缓冲是两种数据传输速率不同的时候，防止高速率等待低速率的操作，一般使用缓冲保证总体传输速率的性能。



#### 无处不在的缓存        

- CPU缓存    
- 操作系统缓存    
- 数据库缓存    
- JVM编译缓存       

- CDN缓存    
- 代理与反向代理缓存    
- 前端缓存    
- 应用程序缓存    
- 分布式对象缓存



#### 缓存数据存储（Hash表）

- 哈希表，一般使用数组随机访问的时间复杂度为O(1)的特性，作为底层存储结构

![1610280764079](ArchitectureAdvanced.assets/1610280764079.png)



#### 缓存的关键指标        

##### 缓存命中率

- 缓存是否有效依赖于能多少次重用同一个缓存响应业务请求,这个度量指标被称作缓存命中率 。
- 如果查询一个缓存,十次查询九次能够得到正确结果,那么它的命中率是90%



#### 影响缓存命中率的主要指标

- 缓存键集合大小
- 缓存可使用内存空间
- 缓存对象生存时间



##### 缓存键集合大小        

缓存中的每个对象使用缓存键进行识别,定位一个对象的唯一方式就是对缓存键执行精确匹配。

例如,如果想为每个商品缓存在线商品信息,你需要使用商品ID作为缓存键。  

换句话说,缓存键空间是你的应用能够生成的所有键的数量。从统计数字上看,应用生成的唯一键越多,重用的机会越小。

例如,如果想基于客户IP地址缓存天气数据,则可能有多达40亿个键(这是所有可能的IP地址的数量)。如果要基于客户来源国家缓存天气数据,则可能仅需几百个缓存键(世界上所国家的数量)。

一定要想办法减少可能的缓存键数量。键数量越少,缓存的效率越高。



##### 缓存可使用内存空间        

缓存可使用内存空间直接决定了缓存对象的平均大小和缓存对象数量。

因为缓存通常存储在内存中,缓存对象可用空间受到严格限制且相对昂贵。如果想缓存更多的对象,就需要先删除老的对象,再添加新的对象。替换(清除)对象会降低缓存命中率,因为缓存对象被删除后,将来的请求就无法命中了。

物理上能缓存的对象越多,缓存命中率就越高。



##### 缓存对象生存时间        

缓存对象生存时间称为TTL( Time To Live)。

在某些场景中,例如,缓存天气预报数据15分钟没问题。在这个场景下,你可以设置缓存对象预定义TTL为15分钟。

在其他场景中,你可能不能冒险使用过于陈旧的数据。例如,在一个电子商务系统中,店铺管理员可能在任何时刻修改商品价格,如果这些价格需要准确地展示在整个网站中。在这个场景下,你需要在每次商品价格修改时让缓存失效。

简单讲,对象缓存的时间越长,  缓存对象被重用的可能性就越高。



#### 代理缓存

- 存在用户端

![1610281346894](ArchitectureAdvanced.assets/1610281346894.png)



#### 反向代理缓存

- 存在服务端

![1610281410508](ArchitectureAdvanced.assets/1610281410508.png)



#### 多重反向代理缓存

- 添加前端 Web 缓存 和 Web服务缓存

![1610281444708](ArchitectureAdvanced.assets/1610281444708.png)



#### 内容分发网络（CDN）

- 缓存静态资源等内容
- 中国早期，蓝汛，CDN厂商，ChinaCache

![1610281612379](ArchitectureAdvanced.assets/1610281612379.png)



#### CDN同时配置静态文件和动态内容

![1610281678844](ArchitectureAdvanced.assets/1610281678844.png)



#### 通读缓存（read-through)

- 代理缓存，反向代理缓存，CDN缓存都是通读缓存。
- 通读缓存给客户端返回缓存资源，并在请求未命中缓存时获取实际数据。
- 客户端连接的是通读缓存而不是生成响应的原始服务器。

![1610281767863](ArchitectureAdvanced.assets/1610281767863.png)



#### 旁路缓存（cache-aside）

- 对象缓存是一种旁路缓存,旁路缓存通常是一个独立的键值对(key- -value)存储。    
- 应用代码通常会询问对象缓存需要的对象是否存在,如果存在,它会获取并使用缓存的对象,如果不存在或已过期,应用会连接主数据源来组装对象,并将其保存回对象缓存中以便将来使用。

![1610281895666](ArchitectureAdvanced.assets/1610281895666.png)



#### 浏览器对象缓存

```javascript
// 在 WebStorage 中缓存对象的 JavaScript 代码
var preferences = { /* data object to be stored */}
localStorage.setItem('preferences', JSON.stringify(preferences));

// 访问对象缓存对象的 JavaScript 代码
var cachedData = localStorage.getItem('preference');
var preferenced = JSPN.parse(cachedData);
```



#### 本地对象缓存

- 对象直接缓存在应用程序内存中。  
- 对象存储在共享内存,同一台机器的多个进程可以访问它们。    
- 缓存服务器作为独立应用和应用程序部署在同一个服务器上。



##### 本地对象缓存构建分布式集群

- 注意：这种方式构建的集群，由于会同步所有应用服务器之间的数据，必然会造成缓存的效率不高，并且应用服务器的性能也会受到影响。

![1610282618209](ArchitectureAdvanced.assets/1610282618209.png)



#### 远程分布式对象缓存

- 直接将缓存单另为一个服务器，不会影响应用服务器

![1610282722620](ArchitectureAdvanced.assets/1610282722620.png)



#### Memcached 分布式对象缓存

```php
// PHP客户端访问 Memcached集群    
$m = new Memcached();

// 添加服务器集群    
$cache -> add Servers(array(
  array(cache1.example.com, 11211),  
  array(cache2.example.com, 11211),
  array(cache3.example.com, 11211)
));
  
// 写缓存,失效时间5分钟    
$m -> set(userCount, 123, 600);
```

![1610283079067](ArchitectureAdvanced.assets/1610283079067.png)



#### Memcached 分布式缓存访问模型

- Memcached 老一代的缓存技术
- 直接部署的是Memcached的服务器，会配有对应的客户端SDK
- 只需要调用SDK的API就可以，剩下的全部交给 Memcached 客户端和服务端完成

![1610283138078](ArchitectureAdvanced.assets/1610283138078.png)



#### 一致性 hash 算法

##### 什么是一致性 hash 算法？

- 解决分布式缓存系统中缓存集群扩容，产生的数据一致性问题
- 建立一个 2^32 的环，把服务器结点的虚拟节点的hash值，放到环上；把要缓存的数据的key值的hash值，也放到环上；
- 从这个环上，顺时针查找距离key值的hash值的最近的服务器节点。



##### 分布式对象缓存的一致性 hash 算法

- int 类型的正整数为 2^32-1个
- hash 的数值，也在这个int的范围内
- 可以避免直接进行取模，分片数据带来的，添加服务器，缓存失效问题

![1610283257568](ArchitectureAdvanced.assets/1610283257568.png)



##### 一致性Hash节点扩容

- 扩容的时候，会出现影响范围较小的效果
- 但是，对于整个缓存的负载分担并不均匀，随机性太强

![1610283458596](ArchitectureAdvanced.assets/1610283458596.png)



##### 基于虚拟节点的一致性 Hash 算法

- 将一个服务器虚拟成为固定数量的虚拟节点
- 将虚拟节点随机分配到整个hash链上，可以解决负载分担不均匀的问题

![1610283655720](ArchitectureAdvanced.assets/1610283655720.png)



#### 各种介质数据访问延迟

- 跨越大西洋一来回需要 300 ms 的时候

![1610283691997](ArchitectureAdvanced.assets/1610283691997.png)



#### 技术栈各个层次的缓存

- 越靠近客户端效果越好
- 对于视频，直播类网站，CDN是不可或缺的缓存方案

![1610283823991](ArchitectureAdvanced.assets/1610283823991.png)



#### 缓存为什么能显著提升性能

- 缓存数据通常来自内存,比磁盘上的数据有更快的访问速度。        
- 缓存存储数据的最终结果形态,不需要中间计算,减少CPU资源的消耗。        
- 缓存降低数据库、磁盘、网络的负载压力,使这些设备获得更好的响应特性。



#### 缓存是系统性能优化的大杀器

- 技术简单
- 性能提升显著
- 应用场景多



#### 合理使用缓存

使用缓存对提高系统性能有很多好处,但是不合理的使用缓存可能非但不能提高系统的性能,还会成为系统的累赘,甚至风险。

实践中, 缓存滥用的情景屡见不鲜一一过分依赖缓存、不合适的数据访问特性等

- 频繁修改的数据:
  - 这种数据如果缓存起来,由于频繁修改,应用还来不及读取就已失效或更新,徒增系统负担。
  - 一般说来,数据的读写比在2:1以上,缓存才有意义。
- 没有热点的访问:
  - 缓存使用内存作为存储,内存资源宝贵而有限,不能将所有数据都缓存起来,如果应用系统访问数据没有热点,不遵循二八定律,
  - 即大部分数据访问不是集中在小部分数据上,那么缓存就没有意义,
  - 因为大部分数据还没有被再次访问就已经被挤出缓存了。
  - LRU 
    - Least Recently Used
    - 最近最少使用算法
    - ![1610284607990](ArchitectureAdvanced.assets/1610284607990.png)
- 数据不一致与脏读:
  - 一般会对缓存的数据设置失效时间,一旦超过失效时间,就要从数据库中重新加载。
  - 因此应用要容忍一定时间的数据不一致,
  - 如卖家已经编辑了商品属性,  但是需要过一段时间才能被买家看到。在互联网应用中,这种延迟通常是可以接受的,  但是具体应用仍需慎重对待。
  - 还有一种策略是数据更新时立即更新缓存,不过也会带来更多系统开销和事务一致性的问题。
  - 因此数据更新时通知缓存失效,删除该缓存数据,  是一种更加稳妥的做法。
  - “计算机科学中只有三件事最困难：缓存失效,命名事物,计数错误。”    --Phil Karlton
- 缓存雪崩:
  - 缓存是为了提高数据读取性能的,缓存数据丢失或者缓存不可用不会影响到应用程序的处 一一 它可以从数据库直接获取数据。
  - 但是随着业务的发展,缓存会承担大部分的数据访问压力,数据库已经习惯了有缓存的日子,所以当缓存服务崩溃的时候,  数据库会因为完全不能承受如此大的压力而宕机,进而导致整个网站不可用。
  - 这种情况,  被称作缓存雪崩,发生这种故障,甚至不能简单的重启缓存服务器和数据库服务器来恢复网站访问。
- 缓存预热：
  - 缓存中存放的是热点数据，热点数据又是缓存系统利用LRU（最近最久未用）算法对不断访问的数据筛选淘汰出来的，这个过程需要花费较长的时间，
  - 在这段时间，系统的性能和数据库负载都不太好，那么最好在缓存系统启动的时候就把热点数据加载好，这个缓存预加载手段叫做缓存预热（warm up）。
  - 对于一些元数据如城市地名列表类目信息，可以启动时加载数据库中全部数据到缓存进行预热。
- 缓存穿透:
  - 如果不恰当的业务、或者恶意攻击持续高并发的请求某个不存在的数据,因为缓存没有保存该数据,所有的请求都会落到数据库上,会对数据库造成很大的压力,  甚至崩溃。
  - 一个简单的对策是将不存在的数据也缓存起来(其 value值为null),并设定一个较短的失效时间。



#### Redis vs Memcached

- Redis支持复杂的数据结构    
- Reds支持多路复用异步高性能  
- Redis支持主从复制高可用  
- Redis原生集群与 share nothing集群模式

![1610285124148](ArchitectureAdvanced.assets/1610285124148.png)



#### Redis集群

- Redis集群预分好16384个桶，当需要在Redis 集群中放置一个key-value时，根据CRC16(key)mod 16384的值，决定将一个key放到哪个桶中。
- redis-cluster 把所有的物理节点映射到[0-16383]slot上(不一定是平均分配），
- cluster 负责维护slot与服务器的映射关系。
- 客户端与Redis节点直连，客户端不需要连接集群所有节点，连接集群中任何一个可用节点即可。
- 所有的Redis 节点彼此互联。

![1610285350597](ArchitectureAdvanced.assets/1610285350597.png)



### 作业与实践

- 用你熟悉的编程语言实现一致性 hash 算法
- 编写测试用例测试这个算法，测试 100万 KV 数据，10个服务器节点的情况下，计算这些 KV 数据在服务器上分布数量的标准差，以评估算法的存储负载不均衡性。
- 示例程序：

```java
SortedMap<Integer, Node> hashCircle = new TreeMap<Integer, Node>();

// 初始化一致性 hash 环
for (Node node : nodes) {
    for (int i = 0; i < virtualNums; i++) {
        hashCircle.put(hash(node.toString() + i), node);
    }
}

// 计算key 对应的服务器node
int hash = getHash(key);  // 计算 key 的hash值
if (!hashCircle.containsKey(hash)) {  // key 的 hash 值是否和虚拟节点的hash相同
    SortedMap<Integer, Node> tailMap = hashCircle.tailMap(hash);  // key 的右子树
    hash = tailMap.isEmpty() ? hashCircle.firstKey() : tailMap.firstKey();
}

return hashCircle.get(hash);
```

- 一个比一致性 hash 算法还快的分区路由算法
- 基于虚拟节点的一致性 Hash 算法
- https://github.com/itisaid/Doris/tree/master/common/doris.common/doris.algorithm/src/main/java/com/alibaba/doris/algorithm/vpm







### 消息队列与异步架构

#### 同步调用 vs 异步调用

##### 同步调用

- 需要发送一个邮件，会花费比较长的时间

![1610358918421](ArchitectureAdvanced.assets/1610358918421.png)



##### 多个耗时操作同步调用

- 不仅仅发送邮件，还需要更新数据库，花费时间更多

![1610359196608](ArchitectureAdvanced.assets/1610359196608.png)



##### 异步调用

- 使用队列 Queue 实现，操作的异步化，
- 保证请求快速返回

![1610359221598](ArchitectureAdvanced.assets/1610359221598.png)



##### 有回调的异步调用

- 异步调用成功或者失败之后，会通知 callback ，处理的结果

![1610359235948](ArchitectureAdvanced.assets/1610359235948.png)





##### 多次异步调用

- 不阻塞应用线程
- 分别调用邮件服务和数据库服务

![1610359264025](ArchitectureAdvanced.assets/1610359264025.png)



#### 消息队列构建异步调用架构

- 消息队列主要解决，请求的写操作（缓存主要解决，请求的读操作）
- 消息生产者
- 消息队列
- 消息消费者

![1610359433266](ArchitectureAdvanced.assets/1610359433266.png)



##### 点对点模型

- 消息队列，隔开了 生产者和消费者
- 使得两者互不关心对方的状态
- 典型的一对一操作

![1610359449749](ArchitectureAdvanced.assets/1610359449749.png)



##### 发布订阅模型

- 使用订阅主题这一操作，保证可以一条消息，对个订阅者消费
- 典型的一对多操作

![1610359591840](ArchitectureAdvanced.assets/1610359591840.png)



#### 消息队列的好处

##### 提升处理性能

- 实现异步处理，提升处理性能
- 异步明显快于同步

![1610359662754](ArchitectureAdvanced.assets/1610359662754.png)



##### 更好的伸缩性

- 可以随时添加后端的工作者
- 一个图片文件渲染的例子

![1610359726296](ArchitectureAdvanced.assets/1610359726296.png)



##### 削峰填谷

- 消息队列类似于水库一样，防止旱涝（系统压力与负载过大）
- 保证系统以一定的处理能力工作，而不是一下冲垮

![1610359740343](ArchitectureAdvanced.assets/1610359740343.png)



##### 失败隔离和自我修复

因为发布者不直接依赖消费者，所以消息系统可以将消费者系统错误与生产者系统组件隔离。

生产者和消费者互相不受对方失败的影响。

这意味着任何时刻，我们都可以对后端服务器执行维护和发布操作。我们可以重启，添加或删除服务器，而不影响生产者的可用性，这样简化了部署和服务器管理的难度。



##### 解耦

- 生产者和消费者互不关心

![1610360010039](ArchitectureAdvanced.assets/1610360010039.png)



#### 事件驱动架构 EDA

- 基于消息队列，可以将一个用户注册服务，拆分成多个事件
- 并且可以根据不同的事件，进行发布订阅模式设计

![1610360024142](ArchitectureAdvanced.assets/1610360024142.png)

![1610360141518](ArchitectureAdvanced.assets/1610360141518.png)



#### 主要 MQ 产品比较

- RabbitMQ的主要特点是性能好，社区活跃，但是 RabbitMQ用 Erlang 开发，对不熟悉 Erlang的同学而言不便于二次开发和维护。（49M）
- ActiveMQ影响比较广泛，可以跨平台，使用Java开发，对Java比较友好。（27M）
- RocketMQ是阿里推出的一个开源产品，也是使用Java开发，性能比较好，可靠性也比较高。（35M）
- Kafka， Linkedln出品的，Scala开发，专门针对分布式场景进行了优化，因此分布式的伸缩性会比较好。（63M）
- 注：可以根据搜索引擎的搜索结果个数，确定一个社区的活跃度，进而选择合适的技术栈。





### 负载均衡架构

#### 负载均衡架构

- 核心工作：将一个用户的请求，根据某种策略，分发到不同的服务器上，保证每一个服务器的负载相对均衡。

![1610360327202](ArchitectureAdvanced.assets/1610360327202.png)



#### HTTP 重定向负载均衡

- 直接给一个 301或者302 的跳转，请求带上转发后的服务器IP地址

![1610360467574](ArchitectureAdvanced.assets/1610360467574.png)



#### DNS负载均衡

- 直接购买 DNS 资源，直接返回不同的服务器IP
- 一般返回的IP 不是真实应用服务器的IP，因为这样子不安全，
- 所以返回的IP服务器,一般是应用负载均衡服务器

![1610360635649](ArchitectureAdvanced.assets/1610360635649.png)



#### 反向代理负载均衡

- 根据一定策略,直接转发用户的请求到某一台服务器
- 是的服务器集群中的压力相对均衡

![1610360655116](ArchitectureAdvanced.assets/1610360655116.png)



#### IP 负载均衡

- 通过修改IP地址，实现数据中心的服务器集群负载均衡
- 按照一定策略，修改请求中的目的IP，是保证集群负载均衡的关键
- 当后端应用服务器数量过大的时候，修改IP的方式，不适用，由于HTTP请求的包比较大,每一次的

![1610360688551](ArchitectureAdvanced.assets/1610360688551.png)



#### 数据链路层负载均衡

- 请求三角形
- 直接修改请求中的mac地址，由于集群使用的都是同一个公网IP，可以复用同一个TCP连接
- 请求的返回，不需要经过负载均衡服务器

![1610361116518](ArchitectureAdvanced.assets/1610361116518.png)



#### 负载均衡算法

- 轮询： 所有请求被依次分发到每个应用服务器上，适合于所有服务器硬件都相同的场景。
- 加权轮询：根据应用服务器硬件性能的情况，在轮询的基础上，按照配置的权重将请求分发到每个服务器，高性能的服务器分配更多请求。
- 随机：请求被随机分配到各个应用服务器，在许多场合下，这种方案都很简单实用，因为好的随机数本身就很均衡。如果应用服务器硬件配置不同，也可以很容易的使用加权随机算法。
- 最少连接：记录每个应用服务器正在处理的连接数（请求数），将新到的请求分发到最少连接的服务器上，应该说，这是最符合负载均衡定义的算法。
- 源地址散列：根据请求来源的IP地址进行Hash计算，得到应用服务器，该算法可以保证同一个来源的请求总在同一个服务器上处理，实现会话粘滞。



#### 应用服务器集群的Session管理

应用服务器的高可用架构设计主要基于服务无状态这一特性，但是事实上，业务总是有状态的，

- 在交易类的电子商务网站，需要有购物车记录用户的购买信息，用户每次购买请求都是向购物车中增加商品；
- 在社交类的网站中，需要记录用户的当前登录状态、最新发布的消息等以便及时将这些信息通知给他的好友。

Web应用中将这些状态信息称作会话（Session），单机情况下， Session 可交给Web容器管理，在使用负载均衡的集
解不境中、Session 管理主要有以下几种手般。



#### Session复制

- 类似于本地缓存复制
- 复制一时爽，本地崩溃来的更快

![1610361343414](ArchitectureAdvanced.assets/1610361343414.png)



#### Session绑定

- 对用户请求，进行服务器的绑定
- 不利于应用升级和维护，用户一直都请求者服务器，基本上无法进行关机操作

![1610361563381](ArchitectureAdvanced.assets/1610361563381.png)



#### 利用Cookie记录Session

- 在Session消息不大的时候，可以使用
- 当session 比较大的时候，传输中的网络带宽就比较大了

![1610361577621](ArchitectureAdvanced.assets/1610361577621.png)



#### Session服务器

- 使用 Redis 作为 Session 服务器，应用服务器无状态，直接调用Session服务
- 最终解决方案

![1610361647433](ArchitectureAdvanced.assets/1610361647433.png)





### 分布式数据库

#### MySQL复制

##### MySQL主从复制

- 使用 MySQL的 binlog ，实现数据的复制
- 从库执行 relaylog，保证数据的一致性

![1610361802009](ArchitectureAdvanced.assets/1610361802009.png)



##### MySQL一主多从复制

- 使用多个从库，同步主库的数据
- 从库主要是保证数据的读操作，不进行写

![1610361824012](ArchitectureAdvanced.assets/1610361824012.png)



##### 一主多从复制的优点

- 分摊负载
- 专机专用
- 便于冷备
- 高可用



##### MySQL主主复制

- 类似于做了一个镜像操作
- 同样使用的是 binlog  和 relaylog

![1610362042985](ArchitectureAdvanced.assets/1610362042985.png)



##### MySQL主主失效恢复

- 当一个主失效的时候，直接切换到另一台主上
- 属于数据库冗余部署

![1610362057866](ArchitectureAdvanced.assets/1610362057866.png)



##### MySQL主主失效的维护过程

- 一般MySQL主失效的时序图
- 只要检测到故障的时间足够短，就可以保证服务的高可用，
- 可以使用IP飘逸技术，实现感知故障并立即切换

![1610362131202](ArchitectureAdvanced.assets/1610362131202.png)



##### MySQL复制注意事项

- 主主复制的两个数据库不能并发写入
- 复制只是增加了数据的读并发处理能力，没有增加写并发能力和存储能力
- 更新表结构会导致巨大的同步延迟



#### 数据分片

- 分片目标
- 分片特点
- 分片原理



##### 硬编码实现数据分片

- 根据 ID 值，将数据直接取模分片，连接不同的服务器
- 需要应用程序参与

![1610434866856](ArchitectureAdvanced.assets/1610434866856.png)



##### 映射表外部存储实现数据分片

- 提供一个数据与服务器的映射存储表，请求数据的时候，需要查表
- 需要应用程序参与

![1610434945397](ArchitectureAdvanced.assets/1610434945397.png)



##### 数据分片的挑战

- 需要大量的额外代码，处理逻辑因此变得更加复杂
- 无法执行多分片的联合查询
- 无法使用数据库的事务
- 随着数据的增长，如何增加更多的服务器



#### 分布式数据库中间件

- Mycat 中间件产品
- 支持根据省份，进行不同数据库的分片查询

![1610435167782](ArchitectureAdvanced.assets/1610435167782.png)



##### Amoeba/Cobar 架构

- 直接进行中间件的服务器集群部署

![1610435321008](ArchitectureAdvanced.assets/1610435321008.png)



##### Cobar 系统组件模型

- 可以在 SQL解析的过程中，进行省份的划分，去相应的数据库获取数据

![1610435336920](ArchitectureAdvanced.assets/1610435336920.png)



##### 路由配置示例

- 根据取模运算，访问不同的数据库实例

![1610435356028](ArchitectureAdvanced.assets/1610435356028.png)



##### 如何做集群的伸缩

- 首先，根据主从复制，复制需要迁移数据库的实例的数据
- 然后，进行数据库路由配置的变更，访问新数据库
- 此时会有几秒的数据问题，需要人工干预
- 或者，直接根据主服务器的binlog，进行从数据库的增量备份，后期停机一定的时间，一般是停机的时间，只需要复制后续24小时的数据到从库就可以，然后进行数据块切换。

![1610435670214](ArchitectureAdvanced.assets/1610435670214.png)



##### 实践中的扩容策略

- 在一个服务器中，部署多个数据库实例
- 数据迁移，扩容的时候，只需要迁移某一个数据库实例，先进行主从复制，后续进行配置变更即可

![1610435683706](ArchitectureAdvanced.assets/1610435683706.png)



#### 数据库部署方案

##### 单一服务与单一数据库

- 业务刚开始的时候，请求少，数据少的方案

![1610435698152](ArchitectureAdvanced.assets/1610435698152.png)



##### 主从复制实现伸缩

- 主从复制方案

![1610435902933](ArchitectureAdvanced.assets/1610435902933.png)



##### 两个Web服务及两个数据库

- 进行服务的拆分，对应的数据库表也会垂直拆分
- 此时的整个系统的负载降低很多

![1610435919694](ArchitectureAdvanced.assets/1610435919694.png)



##### 综合部署

- 由于用户数据库访问压力大，实现数据分片
- 即，进行用户表的水平拆分，实现更高的性能

![1610435934393](ArchitectureAdvanced.assets/1610435934393.png)



### NoSQL

#### CAP原理

- 一致性
- 可用性
- 分区耐受性

![1610436037799](ArchitectureAdvanced.assets/1610436037799.png)



##### 一致性 Consistency

一致性是说，每次读取的数据都应该是最近写入的数据或者返回一个错误（Every read receives the most recent write or an error），而不是过去数据，也就是说，数据是一致的。



##### 可用性 Availability

可用性是说，每次请求都应该得到一个响应，而不是返回一个错误或者失去响应，不过这个响应不需要保证数据是最近写入的（ Every request receives a （ non-error） response , without the guarantee that it contains the most recent write ），也就是说系统需要一直都是可以正常使用的，不会引起调用者的异常，但是并不保证响应的数据是最新的。



##### 分区耐受性 Partition tolerance

分区耐受性说，即使因为网络原因，部分服务器节点之间消息丢失或者延迟了，系统依然应该是可以操作的（The system continues to operate despite an arbitrary number of messages being dropped (or delayd) by the network between nodes）。





##### CAP 原理

当网络分区失效发生的时候，我们要么取消操作，这样数据就是一致的，但是系统却不可用；要么我们继续写入数据，但是数据的一致性就得不到保证。

对于一个分布式系统而言，网络失效一定会发生，也就是说，分区耐受性是必须要保证的，那么在可用性和一致性上就必须二选一。

当网络分区失效，也就是网络不可用的时候，如果选择了一致性，系统就可能返回一个错误码或者干脆超时，即系统不可用。如果选择了可用性，那么系统总是可以返回一个数据，但是并不能保证这个数据是最新的。

所以，关于 CAP 原理，更准确的说法是，在分布式系统必须要满足分区耐受性的前提下，可用性和一致性无法同时满足。



#### CAP原理与数据一致性冲突

- 当数据中心之间的通信失败的时候，网络抖动等，客户端得到的数据是不一致的

![1610436634785](ArchitectureAdvanced.assets/1610436634785.png)



##### 最终一致性

- 将实时一致性放宽松至最终一致性
- 只需要数据最终是正确的就行，不管当时的返回响应数据是否一致

![1610436863226](ArchitectureAdvanced.assets/1610436863226.png)



##### 最终一致写冲突

简单冲突处理策略：根据时间戳，最后写入覆盖

地区不一样，时间戳也会不一致。

![1610436875170](ArchitectureAdvanced.assets/1610436875170.png)



##### 客户端冲突解决

- 对于两次数据的修改进行读合并，展示出最终一致性的内容

![1610437034711](ArchitectureAdvanced.assets/1610437034711.png)



##### 投票解决冲突（Cassandra）

- 同时从三个数节点中读数据，取出这三个节点中最新的数据，进行返回

![1610437049965](ArchitectureAdvanced.assets/1610437049965.png)



#### Cassandra 分布式解决方案

- Cassandra 集群内部会进行计算，选择节点写入数据，
- 为了保证数据的一致性，并不需要全部都写好才返回，只要写入两个就可以返回
- 并且写入数据连接的节点，也是随机选择一个都可以，没有主从的区分

![1610437297394](ArchitectureAdvanced.assets/1610437297394.png)



#### Hbase 架构

- Hbase 中，数据的最终存储是在Hadoop中，使用分布式 HDFS 进行存储
- 每一个数据写入 HFile ，Hadoop会进行自动的数据备份存储，缺省是三分冗余
- 通过Hmaster 访问数据对应的 HregionServer，进行数据的访问
- 一旦HregionServer宕机的时候，数据库就不能保证可用性，但是数据的一致性保证很好

![1610437310046](ArchitectureAdvanced.assets/1610437310046.png)

![1610437515941](ArchitectureAdvanced.assets/1610437515941.png)



#### Log Structed Merge Tree(LSM树)

- 根据数据的key，进行排序，组成一个顺序树，
- 当内存中的树变大之后，通过与硬盘中的树合并，成为更大的树，通过顺序的写入方式，实现机械硬盘也可以高效的数据跌入

![1610438125658](ArchitectureAdvanced.assets/1610438125658.png)



#### ACID 与 BASE

##### ACID

- ACID 是相对于关系型数据库的，对于数据库事务而言的

- 原子性( Atomicity): 事务要么全部完成,要全部取消。如果事务崩溃,状态回到事务之前(事务回滚）。    
- 隔离性( Isolation): 如果2个事务T1和T2同时运行,事务T1和T2最终的结果是相同的,不管T1和T2谁先结束,隔离性主要依靠锁实现。
- 持久性( Durability): 一旦事务提交,不管发生什么(崩溃或者出错),数据要保存在数据库中。
- 一致性( Consistency): 只有合法的数据(依照系约束和函数约束)才能写入数据库。





##### BASE  

- 基本可用( Basically Available) 系统在出现不可预知故障时,允许损失部分可用性,如响应时间上的损失或功能上的损失。    
- Soft state(弱状态)软状态, 指允许系统的二数据存在中间状态,并认为该中间状态的存在不会影响系统的整体可用性,即允许系统在不同节点的数据副本之间进行数据同步的过程存在延时。  
- Eventually consistent(最终一致性) 指系统中所有的数据副本,在经过一段时间的同步后,最终能够达到一个一致的状态,因此最终一致性的本质是需要系统保证数据能够达到一致,而不需要实时保证系统数据的强一致性。



### Doris – 海量 KV Engine

#### 参考资料

- [海量分布式存储系统Doris的高可用架构设计分析](Data/海量分布式存储系统Doris的高可用架构设计分析.pdf)



#### 当前现状

网站关键业务有许多海量KV数据存储和访问需求。

**站UDAS使用。

- 存在问题：扩容困难、写性能较低、实时性低等

网站有多套KV方案，接口不统一，运维成本高。

- **站 UDAS - BDB
- **站：TT

飞天 KV Engine（Aspara）问题。

- 使用复杂
- 性能较低



#### 产品需求

产品定位：海量分布式透明化 KV 存储引擎

解决问题：

- 替换 UDAS：解决扩容迁移复杂，维护困难的问题。
- **站海量KV数据存储
  - Global SEO，1亿 Product，2.4T 数据量
  - 2011年底：3.1
- **站
  - WholeSale Global SEO
  - Product 数：1600 w， 2.8T
  - 2011年底：3400w，5.8T
- **站
  - 风控用户行为日志：每月2亿，40G，增长很快



#### 产品目标

功能目标          

- KV存储 Engine  
- 逻辑管理: Namespace  
- 二级索引 

非功能目标:                          

- 海量存储:透明集群管理,存储可替换  
- 伸缩性:线性伸缩,平滑扩容  
- 高可用:自动容错和故障转移  
- 高性能:低响应时间,高并发  
- 扩展性:灵活扩展新功能 
-  低运维成本
  - 易管理  
  - 可监控

约束

- 一致性:最终一致性



#### 技术指标

![1610516107148](ArchitectureAdvanced.assets/1610516107148.png)



#### 逻辑架构

二层架构 - Client、DataServer + Store

四个核心组件 - Client、DataServer 、 Store、Administration

![1610516219522](ArchitectureAdvanced.assets/1610516219522.png)



#### KV Storage 概念模型

- Machine: 物理机
- Node: 分区单元，一台 Machine 可运行多个 Node
- Namespace: 数据的逻辑划分 Tag，Client 可识别。数据管理无需识别。

![1610516346997](ArchitectureAdvanced.assets/1610516346997.png)



#### 关键技术 - 数据分区

- 解决海量数据存储    
- 客户端计算分区    
- 分区算法(Partition Policy)    
- Client向 Config Server抓取分区配置

![1610516479886](ArchitectureAdvanced.assets/1610516479886.png)



##### 基于虚拟节点的分区算法

均衡性：数据分布均衡

波动性：X（M+X），优于一致性Hash的X/M。

![1610516575970](ArchitectureAdvanced.assets/1610516575970.png)



##### 物理节点由2个扩充到3个，映射关系变化

每个虚拟节点对应两个对等物理节点，Primary节点公式：

![1610516763768](ArchitectureAdvanced.assets/1610516763768.png)

Secondary节点：  S=N+1-P

- z: 虚拟节点下标
- N: 虚拟节点总数
- x: 物理节点下标（一维下标）
- y: 物理节点对应虚拟节点下标（二维下标）

![1610516821303](ArchitectureAdvanced.assets/1610516821303.png)



##### 基本访问架构

对等Node 访问

双写保证可用性（W=2，R=1）

基于分区算法查找两个 Node

- Copy 1 Node
- Copy  2 Node

数据恢复和数据同步

- Redo Log
- Update Log

![1610516973556](ArchitectureAdvanced.assets/1610516973556.png)



#### 集群管理 - 健康检查和配置抓取

检查1: ConfigServer 对 DataServer心跳检查    

检查2: Client 访问时Fail报告

其他 Client定时配置抓取

![1610517175062](ArchitectureAdvanced.assets/1610517175062.png)



#### 关键技术 - 可用性关键场景

瞬时失效    

临时失效              

- 服务端升级或者网络暂时不可用  
- 失效机器在短时内可恢复(例如:2小时内)  
- 恢复后数据和失效前一致

永久失效

- 机器下线



#### 关键技术 - 临时失效的 fail over

物理节点2临时失效,并在可接受时间内恢复    

物理节点x:备用节点,临时存放失效的物理节点2的数据,物理节点2恢复后迁移回物理节点2    

物理节点2临时失效及恢复期间物理节点1承担所有read操作(虽然有点冒险，但是需要赌一把物理节点1不会宕机)

![1610517429615](ArchitectureAdvanced.assets/1610517429615.png)



#### 关键技术 - 永久失效的 fail over

每份 Data 写两份保证高可用：Copy1, Copy2

一致性处理： version(timestamp)

- Conflict Check & Merge

![1610517545758](ArchitectureAdvanced.assets/1610517545758.png)



#### 关键技术 - 扩容实施数据迁移

##### 基本原理

集群扩容,新增 Node X.    

旧路由算法: Route1(key1)={pn1,pn2}    

新路由算法: Route2(key1)={pn1,pnx}    

新旧算法有一个Node相同,因此只需要迁移一个Node

Pn2 数据迁移到 pnx，client 不再对pn2 数据操作

- R 操作 只在 pn1上
- W/R操作指向 {pn1,pnx}    

Client 对等结点中的一个pn1不变（路由算法保证）

![1610517902623](ArchitectureAdvanced.assets/1610517902623.png)



##### 迁移过程

基本原理:基于遍历的路由对比迁移(描述见备注)

- 迁移时,计算两个 Route算法。不相同则迁移。
- 采用改进的分区路由算法,减少迁移量:X(M+X)

![1610517984419](ArchitectureAdvanced.assets/1610517984419.png)



#### 数据可识别功能 - 逻辑数据结构

Namespace: 一个业务实体数据的集合

Data  Definition

- Namespace 的 MetaData 数据结构定义，满足“数据定义可描述”的需求。

![1610518114747](ArchitectureAdvanced.assets/1610518114747.png)



#### 产品规划

##### Doris 和平台产品关系

![1610518184445](ArchitectureAdvanced.assets/1610518184445.png)



##### 产品规划（功能和版本）

![1610518238706](ArchitectureAdvanced.assets/1610518238706.png)



#### Doris Q2研发计划 

##### 功能需求

数据模型        

- Key- Value结构  
- Namespace支持      

数据访问

- 基本KV AP规范
- KV Client:抽象AP, 调用框架  
- 高性能通信





##### 非功能需求

非功能需求      

- 分区和线性伸缩:改进的分区路由算法    
- 可用性:对等Node,写2, Failover  
- 透明集群管理和配置抓取  
- 实时平滑扩容  
- 存储可替换和BDB实现

管理和运维

- 集群管理  
- 基本集群监控(接入 Dragoon)





#### Doris 0.1.0项目计划

- DEV: 3+2
- QA: 2

![1610518529872](ArchitectureAdvanced.assets/1610518529872.png)



#### 实时计划 Q3 - Q4

*站** (Product多语言)

- 业务范围: Product,产品摘要,产品描述,产品属性, Company    
- 当前UDAS支持情况      
  - 数据量:2.4T, Product数1亿,机器:10台
  - 商业pV:800w, KV PV:1.08亿,14ms-100ms, tps:250  
- 2011年底:产品数和存储量+30%,3.1T

*站**  

- Product数:1600w
- 存储量:2.8    
- 2011年底: Product3400w,5.8T
                          



#### Q/A

- 进行项目的问答环节



#### Doris 项目申请专利

- 路由信息更新方法及装置
- 一种分布式存储系统的数据迁移方法、设备和系统
- 分布式存储系统管理装置及方法

![1610518857153](ArchitectureAdvanced.assets/1610518857153.png)

![1610518874653](ArchitectureAdvanced.assets/1610518874653.png)

![1610518892435](ArchitectureAdvanced.assets/1610518892435.png)



#### 算法

- 基于虚拟节点的一致性 Hash 算法
- https://github.com/itisaid/Doris/tree/master/common/doris.common/doris.algorithm/src/main/java/com/alibaba/doris/algorithm/vpm
- Doris/common/doris.common/doris.algorithm/src/main/java/com/alibaba/doris/algorithm/vpm/VpmRouterAlgorithm.java







### 作业与实践

下面两题，至少选做一题：

1. 请简述 CAP 原理

2. 针对 Doris 案例，请用 UML 时序图描述 Doris 临时失效的处理过程（包括判断系统进入临时失效状态，临时失效中的读写过程，失效恢复过程）

   参考资料：[海量分布式存储系统Doris 的高可用架构设计分析](Data/海量分布式存储系统Doris的高可用架构设计分析.pdf)

   参考软件：https://app.diagrams.net/

![drawio.doris](ArchitectureAdvanced.assets/drawio.doris.png)





### 分布式一致 Zookeeper

#### 分布式系统脑裂

在一个分布式系统中,不同服务器获得了互相冲突的数据信息或者执行指令,导致整个集群陷入混乱,数据损坏,被称作分布式系统脑裂。



#### 数据库主主备份

- 使用主主备份，保证一旦某个主故障，可以直接顶上去

![1610526012431](ArchitectureAdvanced.assets/1610526012431.png)



#### 分布式一致性算法 Paxos

三个角色：

- Proposer
- Acceptor
- Learner

![1610526109560](ArchitectureAdvanced.assets/1610526109560.png)

第一阶段: Prepare阶段。 Proposer向 Acceptors发出 Prepare请求, Acceptors针对收到的 Prepare请求进行 Promise承诺。    

第二阶段: Accept阶段。 Proposer收到多数 Acceptors承诺的 Promise后,向  Acceptors发出 Propose请求, Acceptors针对收到的 Propose请求进行 Accept 处理。    

第三阶段: Learn阶段。 Proposer在收到多数 Acceptors的 Accept之后,标志着本次 Accept成功,决议形成,将形成的决议发送给所有 Learners。

![1610526211045](ArchitectureAdvanced.assets/1610526211045.png)

Proposer 生成全局唯一且递增的Proposal ID（可使用时间戳加Server ID)，向所有Acceptors 发送Prepare 请求，这里无需携带提案内容，只携带 Proposal ID即可。

Acceptors 收到Prepare和Propose 请求后

- 不再接受Proposal ID小于等于当前请求的Prepare请求。
- 不再接受Proposal ID小于当前请求的Propose 请求。



#### Zookeeper 架构

- 所有的 server 有一个 Leader

![1610526292323](ArchitectureAdvanced.assets/1610526292323.png)



#### Zab 协议

- 一个 Leader 有多个 Follower

![1610526350901](ArchitectureAdvanced.assets/1610526350901.png)

![1610526421374](ArchitectureAdvanced.assets/1610526421374.png)



#### Zookeeper 的树状记录结构

![1610526470540](ArchitectureAdvanced.assets/1610526470540.png)



#### Zookeeper API

- String create(path,data,acl,flags)
- void delete(path,expectedVersion)
- Stat setData(path,data,expectedVersion)
- (data,Stat)getData(path,watch)
- Stat exists(path,watch)
- Stringl] getChildren(path,watch)
- void sync(path)
- List multi(ops)





#### 配置管理

Administrator

- setData（"/config/param1”,"value",-1)

Consumer

- getData(（"/config/param1",true)

![1610526610527](ArchitectureAdvanced.assets/1610526610527.png)



#### 选 master

1.getdata("/servers/leader",true)
2.if successful follow the leader described in the data and exit
3.create("/servers/leader",hostname,EPHEMERAL)
4.if successful lead and exit
5.goto step1

![1610526693621](ArchitectureAdvanced.assets/1610526693621.png)



#### 选 master(python)

```python
# zookeeper 选主 Python 示例代码
handle = zookeeper.init("localhost:2181", my_connection_watcher, 10000, 0)

(data, stat) = zookeeper.get(handle, "/app/leader", True)

if stat is None:
    path = zookeeper.create(handle, "/app/leader", hostname:info, [ZOO_OPEN_ACL_UNSAFE], zookeeper.EPHEMERAL)

    if path is None:
        (data, stat) = zookeeper.get(handle, "/app/leader", True)
        # someone else is the leader
        # parse the string path that contains the leader address
    else:
    # we are the leader continue leading

else:
    # someone else is the leader
    # parse the string path that contains the leader address
```



#### 集群管理（负载均衡）

Monitoring process:
1.Watch on /nodes
2.On watch trigger do getChildren(/nodes,true)
3.Track which nodes have gone away

Each Node:
1.Create /nodes/node-\${i}) as ephemeral nodes 
2.Keep updating /nodes/node-\${i}periodically for node status changes(status updates could be load/iostat/cpu/others)

![1610527542675](ArchitectureAdvanced.assets/1610527542675.png)



#### Zookeeper 性能

- 随着 server 的增加，写多的时候，请求变慢，是由于需要更多的server统一
- 读多的时候，请求飞起，由于提供了更多的server提供读

![1610527652080](ArchitectureAdvanced.assets/1610527652080.png)



### 搜索引擎

#### 互联网搜索引擎整体架构

![1610545521128](ArchitectureAdvanced.assets/1610545521128.png)



#### 爬虫系统架构

![1610545534948](ArchitectureAdvanced.assets/1610545534948.png)



#### 爬虫禁爬协议

![1610545552786](ArchitectureAdvanced.assets/1610545552786.png)



#### 文档矩阵与倒排索引

![1610545674358](ArchitectureAdvanced.assets/1610545674358.png)



#### 文档与倒排索引

![1610545723477](ArchitectureAdvanced.assets/1610545723477.png)



#### 带词频的倒排索引

![1610545765156](ArchitectureAdvanced.assets/1610545765156.png)



#### 带词频与位置的倒排索引

![1610545811924](ArchitectureAdvanced.assets/1610545811924.png)



#### Lucene 架构

![1610545824503](ArchitectureAdvanced.assets/1610545824503.png)



#### Lucene 倒排索引

![1610545891127](ArchitectureAdvanced.assets/1610545891127.png)



#### Lucene 索引文件准实时更新

索引有更新，就需要重新全量创建一个索引来替换原来的索引。这种方式在数据量很大时效率很低，并且由于创建一次索引的成本很高，性能也很差。

Lucene 中引入了**段**的概念，将一个索引文件拆分为多个子文件，每个子文件叫做段，每个段都是一个独立的可被搜索的数据集，索引的修改针对段进行操作。

- 新增：当有新的数据需要创建索引时，原来的段不变，选择新建一个段来存储新增的数据。
- 删除：当需要删除数据时，在索引文件新增一个.del的文件，用来专门存储被删除的数据ID。当查询时，被删除的数据还是可以被查到的，只是在进行文档链表合并时，才把已经删除的数据过滤掉。被删除的数据在进行段合并时才会被真正被移除。
- 更新：更新的操作其实就是删除和新增的组合，先在.del文件中记录旧数据，再在新段中添加一条更新后的数据。

为了控制索引里段的数量，我们必须定期进行段合并操作





#### ElasticSearch 架构

- 索引分片，实现分布式
- 索引备份，实现高可用
- API更简单，更高级

![1610546089601](ArchitectureAdvanced.assets/1610546089601.png)



#### ES 分片预分配与集群扩容

- shard = hash（routing）% number_of_primary_shards

![1610546179910](ArchitectureAdvanced.assets/1610546179910.png)



#### 网页排名算法 PageRank

PageRank，网页排名，又称为网页级别，Google 左侧排名或佩奇排名，是一种由搜索引擎根据网页之间相互的超链接计算的技术，而作为网页排名的要素之一，以Google公司创始人 拉里·佩奇（Larry Page）之姓来命名。



#### PageRank 让链接来投票

PageRank 通过网络浩瀚的超链接关系来确定一个页面的等级。

Google 把从A页面到B页面的链接解释为A页面给B页面投票， Google根据投票来源（甚至来源的来源，即链接到A页面的页面）和投票目标的等级来决定新的等级。简单的说，一个高等级的页面可以使其他低等级页面的等级提升。

一个页面的「得票数」由所有链向它的页面的重要性來决定，到一个页面的超链接相当于对该页投一票。一个页面的 PageRank是由所有链向它的页面（「链入页面」）的重要性经过递归算法得到的。一个有较多链入的页面会有较高的等级，相反如果一个页面没有任何链入页面，那么它没有等级。

![1610546485462](ArchitectureAdvanced.assets/1610546485462.png)



#### PageRank 算法

假设一个 由4个页面组成的小团体：A，B，C和D。如果所有页面都链向A，那么A的PR（PageRank）值将是 B，C和D的 PageRank 总和。

![1610546606409](ArchitectureAdvanced.assets/1610546606409.png)

继续假设B也有链接到C,并且D也有链接到包括A的3个页面。一个页面不能投票2  次。所以B给每个页面半票。以同样的逻辑,D投出的票只有三分之一算到了A的  PageRank上。

![1610546673741](ArchitectureAdvanced.assets/1610546673741.png)

换句话说，根据链出总数平分一个页面的 PR 值。

![1610546724919](ArchitectureAdvanced.assets/1610546724919.png)

互联网中一个网页只有对自己的出链，或者几个网页的出链形成一个循环圈。那么在不断地迭代过程中，这一个或几个网页的PR值将只增不减，显然不合理。

如下图中的C网页，就是刚刚说的是有对自己的出链的网页。

![1610546738204](ArchitectureAdvanced.assets/1610546738204.png)

为了解决这个问题。我们想象一个随机浏览网页的人,假定他有一个确定的概率会输入网址直接跳转到一个随机的网页,并且跳转到每个网页的概率是一样的。于是则此图中A  的PR值可表示为：

![1610546902180](ArchitectureAdvanced.assets/1610546902180.png)

PageRank 计算公式：

![1610546936925](ArchitectureAdvanced.assets/1610546936925.png)

PageRank值是一个特殊矩阵中的特征向量。这个特征向量为：

![1610546983011](ArchitectureAdvanced.assets/1610546983011.png)

![1610546993931](ArchitectureAdvanced.assets/1610546993931.png)



#### 一个电影搜索引擎案例

- 豆瓣：https://www.douban.com/

![1610547086971](ArchitectureAdvanced.assets/1610547086971.png)



##### 文档文件 subject.dat

![1610547156493](ArchitectureAdvanced.assets/1610547156493.png)



##### 倒排索引文件

![1610547172439](ArchitectureAdvanced.assets/1610547172439.png)



#### 加权词频排序算法

![1610547292248](ArchitectureAdvanced.assets/1610547292248.png)



##### 源码

https://github.com/itisaid/sokeeper Web 应用
https://github.com/itisaid/cmdb 爬虫，倒排索引构建



#### 汉语处理组件包（汉语分词）

https://github.com/hankcs/HanLP

![1610547397295](ArchitectureAdvanced.assets/1610547397295.png)



#### 一个智能助理机器人案例

- https://github.com/zhihuili/robot

![1610547481818](ArchitectureAdvanced.assets/1610547481818.png)

![1610547493376](ArchitectureAdvanced.assets/1610547493376.png)





## 分布式系统性能优化

### 性能测试

#### 性能测试

性能测试是性能优化的前提和基础，也是性能优化结果的检查和度量标准。不同视角下的网站性能有不同的标准，也有不同的优化手段。

主观视角：用户感受到的性能（打开一个网页，是等所有数据全部到达后显示，还是到了的数据先展示，用户的感受是不同的）

客观视角：性能指标衡量的性能



#### 性能测试指标

不同视角下有不同的性能标准,不同的标准有不同的性能测试指标, 网站性能测试的主要指标有响应时间、并发数、吞吐量、性能计数器等。



##### 响应时间

响应时间: 指应用系统从发出请求开始到收到最后响应数据所需要的时间。

响应时间是系统最重要的性能指标,直观的反映了系统的“快慢”。



##### 并发数        

并发数: 系统能够同时处理请求的数目,这个数字也反映了系统的负载特性。

对于网站而言,并发数即系统并发用户数,指同时提交请求的用户数目,于此相对应,还有在线用户数(当前登录系统的用户数)和系统用户数(可能访问系统的总用户数)。



##### 吞吐量        

吞吐量: 指单位时间内系统处理的请求的数量,体现件系统的处理能力。

对于网站,可以用“请求数/秒”或是“页面数/秒”来衡量,也可以用“访问人数/天”或是“处理的业务数/小时”等来衡量    

TPS(每秒事务数)也是吞吐量的一个指标,此外还有HPS(每秒HTTP请求数)  QPS(每秒查询数)等

吞吐量 = （1000 / 响应时间ms）x 并发数



##### 性能计数器        

性能计数器: 是描述服务器或操作系统性能一些数据指标。

包括 System Load、对象与线程数、内存使用、CPU使用、磁盘与网络I/O等指标。这些指标也是系统监控的重要参数,对这些指标设置报警阀值,当监控系统发现性能计数器超过阀值的时候,就向运维和开发人员报警,及时发现处理系统异常。



#### 性能测试方法

性能测试时一个总称，具体可细分为性能测试，负载测试，压力测试，稳定性测试。



##### 性能测试        

性能测试: 以系统设计初期规划的性能指标为预期目标,对系统不断施加压力,验证系统在资源可接受范围内,是否能达到性能预期。



##### 负载测试

负载测试：对系统不断地增加并发请求以增加系统压力，直到系统的某项或多项性能指标达到安全临界值，如某种资源已经呈饱和状态，这时候继续对系统施加压力，系统的处理能力不但不能提高，反而会下降。



##### 压力测试        

压力测试: 超过安全负载的情况下,对系统继续施加压力,直到系统崩溃或不能再处理任何请求,以此获得系统最大压力承受能力。



##### 稳定性测试       

稳定性测试: 被测试系统在特定硬件、软件、网络环境条件下,给系统加载一定业务压力,使系统运行一段较长时间,以此检测系统是否稳定。

在生产环境,请求压力是不均匀的,呈波浪特性,因此为了更好地模拟生产环境,稳定性测试也应不均匀地对系统施加压力。



##### 性能测试示例

- TPS 与并发数关系

![1610541893408](ArchitectureAdvanced.assets/1610541893408.png)

- 响应时间 与并发数关系

![1610541911352](ArchitectureAdvanced.assets/1610541911352.png)

- 性能测试表格

![1610542016828](ArchitectureAdvanced.assets/1610542016828.png)



#### 基于Flower的应用重构性能测试

![1609080436943](ArchitectureAdvanced.assets/1609080436943.png)



#### 性能测试压测可用性

- 重构前，由于网关转发请求到服务器1上，因为慢查询导致网关的所有线程全部占用，不能为服务2提供工作，引发雪崩效应
- 重构后，异步网关执行，服务1的慢查询，不会影响服务2 的请求

![1610542265288](ArchitectureAdvanced.assets/1610542265288.png)

![1610542304791](ArchitectureAdvanced.assets/1610542304791.png)



### 全链路压测（天猫双十一）

#### 全链路压测的目的

全链路压测其实指的就是在特定的业务场景下,将相关的链路完整的串联起来同时施压,  尽可能模拟出真实的用户行为,当系统整站流量都被打上来的时候,必定会暴露出性能瓶颈,才能够探测出系统整体的真实处理能力,以及有指导的在大促前进行容量规划和性能优化,这便是线上实施全链路压测的真正目的。



#### 全链路压测的挑战

- 压测相关的业务系统上众多,并且牵涉到整条链路上所有的基础设施和中间件,如何确保压测流量能够通畅无阻,没有死角?压测的数据怎么构造(亿万级的商品和用  户),数据模型如何与真实贴近?   
- 全链路压测直接在线上的真实环境进行模拟,怎么样来保障对线上无影响?    
- 大型促销活动所带来的巨大流量要怎么样制作出来?



#### 数据构造

![1611217579936](ArchitectureAdvanced.assets/1611217579936.png)



#### 数据隔离

- 逻辑隔离,直接把测试数据和正常数据写到一起,通过特殊的标识能够区分开        
  - 可能污染线上数据,破坏线上数据安全性
- 虚拟隔离,在所有写数据的地方做mock,并不真正的写进去   
  - 这个方案不会对线上产生污染,但是mock对测结果的准确性会产生干扰     
- 物理隔离,所有写数据的地方对压测流量进行识别,判断一旦是压测流量的写,就写到隔离的位置,包括存储、缓存、搜索引擎等等。



#### 流量构造

天猫双十一全链路压测的流量平台是一个典型的 master+ slave结构, master作为压测管控台管理 着上千个slave节点; slave节点 作为压测引擎,负责具体的请求 发送。 

Master作为整个压测平台的大脑,负责的整个平台的运转 控制、命令发送、数据收集、决 策等。 slave节点部署在全球各地的cdn节点上,从而模拟从全球各地过来的用户请求。

整套全链路压测的流量平台在压测过程当中平稳输出1000w+/s的用户请求、同时保持过亿的无线用户长链接。

![1611217862399](ArchitectureAdvanced.assets/1611217862399.png)



#### 全链路压测平台化

![1611217904314](ArchitectureAdvanced.assets/1611217904314.png)



### 性能优化

#### 软件性能优化的两个基本原则

- 你不能优化一个没有测试的软件
- 你不能优化一个你不了解的软件



#### 性能测试的主要指标

- 响应时间:完成一次任务花费的时间       
- 并发数:同时处理的任务数        
- 吞吐量:单位时间完成的任务数       
- 性能计数器: System Load,线程数,进程数,CPU、内存、磁盘、网络使用率



#### Spark 应用性能测试

- Task-Time，CPU，网路，内存，磁盘

 ![1610542990372](ArchitectureAdvanced.assets/1610542990372.png)



#### 性能优化的一般方法

- 性能测试，获得性能指标
- 指标分析，发现性能与资源瓶颈点
- 架构与代码分析，寻找性能与戏院瓶颈关键所在
- 架构与代码优化，优化关键技术点，平衡资源利用
- 性能测试，进入性能优化闭环



#### 系统性能优化的分层思想

- 机房与骨干网络性能优化    
- 服务器与硬件性能优化    
- 操作系统性能优化    
- 虚拟机性能优化    
- 基础组件性能优化    
- 软件架构性能优化    
- 软件代码性能优化



#### 机房与骨干网络性能优化  

- 异地多活 的多机房架构
- 专线网络与自主CDN建设

![1610543223341](ArchitectureAdvanced.assets/1610543223341.png)



#### 服务器与硬件性能优化

使用更优的CPU，硬盘，内存，网卡，对软件的性能优化可能是数量级的，有时候远远超过代码和架构的性能优化。

![1610543308063](ArchitectureAdvanced.assets/1610543308063.png)



#### 硬件性能优化案例

Spark 作业过程需要传输大量数据，进行资源瓶颈分析，发现大量时间消耗在网络传输上（网络负载打满，打平）。

优化方案，升级网卡，10G网卡代替1G网卡

![1610543391735](ArchitectureAdvanced.assets/1610543391735.png)



#### 操作系统性能优化案例

资源利用分析，发现大量CPU操作为sys类型，消耗大量计算资源（资源都被系统消耗了）。

调查发现，起因是部分 Linux 版本缺省情况打开 transparent huge page（运行时动态分配内存资源） 导致。

优化方案：关闭  transparent huge page。

![1610543740511](ArchitectureAdvanced.assets/1610543740511.png)



#### 虚拟机性能优化

- 串行，并行，CMS，G1
- 都会有短暂的 STW，stop the world.

![1610543876307](ArchitectureAdvanced.assets/1610543876307.png)



#### 基础组件性能优化

- 阿里巴巴应用服务器升级项目

![1610543939031](ArchitectureAdvanced.assets/1610543939031.png)



#### 软件架构性能优化三板斧

- 缓存
- 异步
- 集群



##### 缓存

- 从内存获取数据,减少响应时间    
- 减少数据库访问,降低存储设备负载压力    
- 缓存结果对象,而不是原始数据,减少CPU计算    
- 缓存主要优化读操作

![1610544036769](ArchitectureAdvanced.assets/1610544036769.png)

##### 异步

- 即时响应，更好的用户体验
- 控制消费速度，合适的负载压力
- 异步主要优化写操作

![1610544050144](ArchitectureAdvanced.assets/1610544050144.png)



##### 集群

古老谚语:如果一匹马拉不动车,无需换一匹更强的马,而是用两匹马拉车。    

互联网技术的发展路径就是: 更多的用户访问需要消耗更多的计算资源,单一服务器计算资源的增加是有极限的,所以需要增加更多的服务器。关键是如何利用起来这些服务器。    

集群的技术目标只有一个:如何使很多台服务器对使用者而言看起像一台服务器。

![1610544169563](ArchitectureAdvanced.assets/1610544169563.png)



#### 软件代码性能优化

遵循面向对象的设计原则与设计模式编程,很多时候程序性能不好不是因为性能上有什么技术挑战,仅仅就是因为代码太烂了。    

并发编程,多线程与锁

资源复用,线程池与对象池    

异步编程,生产者消费者    

数据结构,数组、链表、hash表、树



#### 代码优化案例

Spark 任务文件初始化调优

- 资源分析，发现第一个 stage 时间特别长，耗时长达 14s，CPU和网络通信都有一定开销，不符合应用代码逻辑

![1610544373122](ArchitectureAdvanced.assets/1610544373122.png)

- 打开Spark作业log，分析这段时间的Spark 运行状况。
- 根据log分析结果，阅读Spark 相关源码。
- 发现Spark在任务初始化加载应用代码的时候，每个Executor都加载一次应用代码，当时每台服务器最多可启动48个 Executor，每个应用代码包17M大小，导致加载开销巨大。
- 优化方案：Executor 加载应用程序包启用本地文件缓存模式。[SPARK-2713]
- 优化效果：Stage1运行时间从14s下降到不到1s。

![1610544386950](ArchitectureAdvanced.assets/1610544386950.png)



### 作业与实践

以下两题，至少选做一题

1.性能压测的时候，随着并发压力的增加，系统响应时间和吞吐量如何变化，为什么？

2.用你熟悉的编程语言写一个web性能压测工具，

- 输入参数： URL，请求总次数，并发数。
- 输出参数：平均响应时间，95%响应时间。
- 用这个测试工具以10并发、100次请求压测 www.baidu.com
- 示例程序：[PressureTest.](Data/PressureTest.java)





### 操作系统

#### 程序运行时架构

- 程序是静态的
- 程序运行起来以后，被称为进程。

![1610619792095](ArchitectureAdvanced.assets/1610619792095.png)



#### 操作系统多任务运行环境

计算机的CPU核心数是有限的。但是,服务器可以同时处理数以百计甚至数以千计的并发用户请求。        

那么,计算机如何做到的? 

- 进程分时执行



#### 进程的运行期状态

运行:当一个进程在CPU上运行时,则称该进程处于运行状态。处于运行状态的进程的  数目小于等于CPU的数目。        

就绪:当一个进程获得了除CPU以外的一切需资源,只要得到CPU即可运行,则称此进程处于就绪状态,就绪状态有时候也被称为等待运行状态。        

阻塞:也称为等待或睡眠状态,当一个进程正在等待某一事件发生(例如等待I/0完成,  等待锁…而暂时停止运行,这时即使把CPU分配给进程也无法运行,故称该进程处于阻塞状态。



#### 进程 VS 线程

不同进程轮流在CPU上执行,每次都要进行进程间CPU切换,代价非常大。因此服务器应用通常是单进程多线程。        

进程从操作系统获得基本的内存空间,所有的线程共享着进程的内存地址空间。而每个线程也会拥有自己私有的内存地址范围,其他线程不能访问。

![1610624799535](ArchitectureAdvanced.assets/1610624799535.png)



#### 线程栈

```java
void f(){
  int x = g(1);
  x++;  // g 函数返回，当前堆栈顶部为 f 函数栈帧，在当前栈帧继续执行 f 函数的代码
}

int g(int x){
  return x + 1;
}
```

![1610624928840](ArchitectureAdvanced.assets/1610624928840.png)



#### Java Web 应用多线程运行时视图

- 物理服务器
- 操作系统
- JVM进程
- Tomcat容器
- 应用程序

![1610625063666](ArchitectureAdvanced.assets/1610625063666.png)



#### 线程安全

当某些代码修改内存堆（进程共享内存）里的数据的时候，如果有多个线程在同时执行，就可能会出现同时修改数据的情况。

比如，两个线程同时对一个堆中的数据执行+1操作，最终这个数据只会被加一次，这就是人们常说的线程安全问题，实际上线程的结果应该是依次加一，即最终的结果应该是+2。

![1610625146514](ArchitectureAdvanced.assets/1610625146514.png)



#### 临界区

多个线程访问共享资源的这段代码被称为临界区,解决线程安全问题的主要方法是使用锁,将临界区的代码加锁,只有获得锁的线程才能执行临界区代码。

```java
lock.lock();  // 线程获得锁
i++;  // 临界区代码，i位于堆中
lock.unlock();  // 线程释放锁
```



#### 阻塞导致高并发系统崩溃

锁（IO）会引起线程阻塞。

阻塞导致线程既不能继续执行，也不能释放资源。进而导致资源耗尽，最终导致系统崩溃。

![1609080423706](ArchitectureAdvanced.assets/1609080423706.png)



#### 避免阻塞引起的崩溃

限流:控制进入计算机的请求数,进而减少创建的线程数。        

降级:关闭部分功能程序的执行,尽早释放线程。        

反应式:异步;无临界区(Actor模型)



### 锁

#### 锁原语 CAS

CAS(V, E, N)         

-  V表示要更新的变量  
- E表示预期值  
- N表示新值

如果V值等于E值,则将V的值设为N,若值和E值不同,什么都不做。        

CAS是一种系统原语,原语的执行必须是连续的,在执行过程中不允许被中断。



#### Java通过CAS原语在对象头中修改Mark Word实现加锁

- 正常
- 偏向锁
- 轻量级锁
- 重量级锁

![1610625615730](ArchitectureAdvanced.assets/1610625615730.png)



#### 偏向锁、轻量级锁、重量级锁

偏向锁：指一段同步代码一直被一个线程所访问，那么该线程会自动获取锁，降低获取锁的代价

轻量级锁：指当锁是偏向锁时，被另一个线程所访问，偏向锁就会升级为轻量级锁，其他线程会通过自旋的形式尝试获取锁，不会阻塞，提高性能

重量级锁：指当锁是轻量级锁时，另一个线程虽然自旋，但自旋不会一直持续下去，当自旋到一定次数时，还没获取到锁，就会进入阻塞，该锁膨胀为重量级锁，重量级锁会让其他申请的线程进入阻塞，性能降低



#### 多CPU情况下的锁

- 缓存一致性协议，总线锁机制

![1610626093700](ArchitectureAdvanced.assets/1610626093700.png)



#### 总线锁与缓存锁

总线锁：使用处理器的LOCK#信号，当一个处理器在内存总线上输出此信号的时候，其他处理器的请求将被阻塞，该处理器独占内存。

缓存锁：是指内存区域如果被缓存在处理器的缓存行中，并且在Lock操作期间被锁定，那么当它执行锁操作回写到内存时，处理器不在总线上声言LOCK#信号，而是修改内部的内存地址，并允许它的缓存一致性机制来保证操作的原子性，因为缓存一致性机制会阻止同时修改由两个以上处理器缓存的内存区域数据，当其他处理器回写已被锁定的缓存行数据时，会使缓存行无效。



#### 公平锁、非公平锁

公平锁就是多个线程按照申请锁的顺序来获得锁的。

非公平锁就是多个线程获取锁的顺序并不是按照申请锁的顺序，有可能后申请的线程比先申请的线程优先获取锁，可能会造成饥饿现象。



#### 可重入锁

可重如就是说某一个线程已经获得某个锁，可以再次获取锁而不会出现死锁。



#### 独享锁/互斥锁、共享锁、读写锁

独享锁/互斥锁：该锁一次只能被一个线程所持有

共享锁：该锁可以被多个线程锁持有

读写锁：多个读线程之间并不互斥，而写线程则要求与任何线程互斥



#### 乐观锁、悲观锁

悲观锁认为对于同一个数据的并发操作，一定是会发生修改的，哪怕没有修改，也会认为修改。因此对于同一个数据的并发操作，悲观锁采取加锁的形式。悲观的认为，不加锁的并发操作一定会出问题。

乐观锁则认为对于同一个数据的并发操作，是不会发生修改的。在更新数据的时候，检查是否已经被修改过，如果修改过，就放弃。



#### 分段锁

分段锁的设计目的是细化锁的粒度，当操作不需要更新整个数组的时候，就仅仅针对数组的一段进行加锁操作。

JDK ConcurrentHashMap 是通过分段锁的形式来实现高效并发操作的。



#### 自旋锁

自旋锁是指尝试获取锁的线程不会立即阻塞，而是采用循环的方式去尝试获取锁，这样的好处是减少线程上下文切换的消耗，缺点是循环会消耗CPU。









### 异步并发分布式编程框架akka

#### Akka's vision

Simpler concurrency (scale up)

Simpler distribution (scale out)

Simpler fault-tolerance (self healing)

All of that with a single unified programming model

![1610627075194](ArchitectureAdvanced.assets/1610627075194.png)

![1610627098198](ArchitectureAdvanced.assets/1610627098198.png)



#### The Akka toolkit

Akka runs on the JVM

Akka can be used from java and acala

Akka can be integrated with common infrastructure, e.g. Spring, etc.





#### Core concept: Actor

Carl Hewitt (1973): Fundamental unit of computation

- Behavior - react on messages it receives
- State - shielded from the rest of the world, no need for synchronization
- Communication - interact with other actors exclusively via mesages



#### The Akka Actor

![1610627380429](ArchitectureAdvanced.assets/1610627380429.png)

![1610627401846](ArchitectureAdvanced.assets/1610627401846.png)





#### Receive message

- One at a time

```java
public class Hello extends UntypedActor {
  
    @Override
    public void onReceive(Object message) {
        System.out.println("Hello, world!");
    }
}
```



#### Send message

- Asynchronous and nonblocking

```java
ActorRef hello = ...;

hello.tell("Hi!");
```



#### ActorRef path

Local

- Akka: //Master/user/master

Remote

- Akka.tcp: //Master@sr148:2054/user/master



#### The Akka ActorSystem

![1610627751759](ArchitectureAdvanced.assets/1610627751759.png)



#### Create an actor system

```java
ActorSystem system = ActorSystem.create("hello");
```





#### Create a top-level actor

```java
ActorRef hello = system.actorOf(new Props(new hello()));
```



#### Create a child actor

```java
ActorRef child = context().actorOf(new Props(new Child()));
```



#### Router for cluster

```java
val router = system.actorOf(Props[SomeActor].withRouter(RoundRobinRouter(nrOfInstances = 5)));
```



#### Enbrace failure

Let it crash!

Supervision: Like in real life, parents supervise their children (manage children's failures)

Depending on the parents supervisor strategy, failing actors can get stopped, restarted or resumed

```java
private SupervisorStrategy strategy = new OneForStrategy(
		10,
    Duration.parse("1 minute"),
    new Function<Throwable, Directive>() {
        @Override
        public Directive apply(Throwable t) {
            if (t instanceof ArithmeticException) return resume();
            else if (t instanceof NullPointerException)  return restart();
            else  return escalate();
        }
    }
);

@Override
public SupervisorStrategy supervisorStrategy() {
    return strategy;
}
```





#### The HakkyHour bar

Our drinks: Ajjarita, MaiPlay, PinaScalada

Our actors: guests, waiters, head waiter, barkeepers

Our messages: Order, drink served, complaint, etc

Our failure: Guest drunk, waiter frustrated





#### HakkyHour message

![1610628715906](ArchitectureAdvanced.assets/1610628715906.png)



#### Benefits of using Akka actors

You don't have to deal with concurrency details

You can manage failures easily

Distribute is just a deployment decision (not convered here)

```properties
akka {
	actor {
		deployment {
			"/creationActor/*" {
				remote = "akka.tcp://CalculatorWorkerSystem@127.0.0.1:2552"
			}
		}
	}
}
```



#### Akka 在金融借贷领域的应用

![1610629015946](ArchitectureAdvanced.assets/1610629015946.png)



### 文件与硬盘I/O

#### 机械硬盘

![1610630726248](ArchitectureAdvanced.assets/1610630726248.png)



#### 固态硬盘

![1610630915123](ArchitectureAdvanced.assets/1610630915123.png)



#### B+树

![1610630928050](ArchitectureAdvanced.assets/1610630928050.png)



#### LSM 树

- Log Structed Merge Tree(LSM树)

![1610630939610](ArchitectureAdvanced.assets/1610630939610.png)



#### 文件控制块

文件系统将硬盘空间以块为单位进行划分，每个文件占据若干个块，然后再通过一个文件控制块 FCB 记录每个文件占据的硬盘数据块。

![1610630953006](ArchitectureAdvanced.assets/1610630953006.png)



#### Linux INode 文件控制块

- inode 中记录着文件权限、所有者、修改时间和文件大小等文件属性信息，以及文件数据块硬盘地址索引。
- inode是固定结构的，能够记录的硬盘地址索引数也是固定的，只有 15个索引。
- 每个inode最多可以存储12+256+256*256+256*256*256个数据块，如果每个数据块的大小为4k，也就是单个文件最大不超过70G。

![1610631160714](ArchitectureAdvanced.assets/1610631160714.png)



#### RAID 独立硬盘冗余阵列

- RAID 0
- RAID 1
- RAID 10
- RAID 5 （常用）
- RAID 6

![1610631204528](ArchitectureAdvanced.assets/1610631204528.png)

![1610631266477](ArchitectureAdvanced.assets/1610631266477.png)



#### 分布式文件系统 HDFS

- NameNode
- DataNode

![1610631302658](ArchitectureAdvanced.assets/1610631302658.png)









### 作业与实践

#### 第一题

有两个单向链表（链表长度分别为m, n），这两个单项链表有可能在某个元素合并，如下图所示的这样，也可能不合并。

现在给定两个链表的头指针，在不修改链表的情况下，如何快速地判断这两个链表是否合并？如果合并，找到合并的元素，也就是图中的X元素。

请用（伪）代码描述算法，并给出时间复杂度和空间复杂度。

![1610630272471](ArchitectureAdvanced.assets/1610630272471.png)

参考答案：

- [answer1](Data/linkedlist1.1.md)
- [answer2](Data/linkedlist1.2.md)



#### 第二题

请画出 DataNode 服务器节点宕机的时候，HDFS的处理程序时序图。

![HDFSDataNodeNameNode](ArchitectureAdvanced.assets/HDFSDataNodeNameNode.jpg)





### 数据结构与算法

#### 时间复杂度与空间复杂度

时间复杂度

- 并不是计算程序具体运行的时间，而是算法执行语句的次数
- O(2^n) 表示对n数据处理需要进行 2^n 次计算
- O(1)，O(log(n))，O(n^a) 多项式时间复杂度
- O(a^n) 和 O(n!) 非多项式时间复杂度

空间复杂度

- 一个算法在运行过程中临时占用存储空间大小的量度
- O(n) 表示需要临时存储 n 个数据

![1610712040350](ArchitectureAdvanced.assets/1610712040350.png)



#### NP 问题

P问题：能在多项式时间复杂度内解决的问题

NP问题：能在多项式时间复杂度内验证答案正确与否的问题。

NP？=P

NP-hard问题：比NP问题更难的问题（NP问题的解法可以规约到NP-hard问题的解法）

NP完全问题：是一个NP-hard问题，也是一个NP问题

![1610712056534](ArchitectureAdvanced.assets/1610712056534.png)





#### 数组

创建数组必须要内存中一块连续的空间。

数组中必须存放相同的数据类型。

随机快速读写是数组的一个重要特性，根据数组的下标访问数据，时间复杂度为O(1)。

![1610712155935](ArchitectureAdvanced.assets/1610712155935.png)



#### 链表

链表可以使用零散的内存空间存储数据。

所以链表中的每个数据元素都必须包含一个纸箱下一个数据元素的内存地址指针。

要想在链表中查找一个数据，只能遍历链表，所以链表的朝招复杂度总是O(N)。

![1610712279947](ArchitectureAdvanced.assets/1610712279947.png)



##### 链表中增删数据要比数组性能好的多

- 链表只需要接入新的节点之后，将原来结点指向新的结点即可

![1610712478976](ArchitectureAdvanced.assets/1610712478976.png)

数组链表结合，实现快速查找和快速增删

![1610712498719](ArchitectureAdvanced.assets/1610712498719.png)



#### Hash 表

如何既快速访问数据，又快速增删数据？

Hash  表本质在数组中，存储的是一个内存地址，指向的是一个链表。

![1610712603397](ArchitectureAdvanced.assets/1610712603397.png)



##### Hash 冲突

- 当 key 相同，或者 Hash 的结果相同的时候，就使用链表进行存储

![1610712702202](ArchitectureAdvanced.assets/1610712702202.png)



#### 栈

数组和链表都被称为线性表。

栈就是在线性表的基础上加了这样的操作限制条件：后面添加的数据，再删除的时候必须先删除，即通常所说的“后进先出”。

线程运行时专有内存为什么被称为线程栈？

![1610712716058](ArchitectureAdvanced.assets/1610712716058.png)



##### 线程调用栈

```java
void f(){
  int x = g(1);
  x++;  // g 函数返回，当前堆栈顶部为 f 函数栈帧，在当前栈帧继续执行 f 函数的代码
}

int g(int x){
  return x + 1;
}
```

![1610624928840](ArchitectureAdvanced.assets/1610624928840.png)



#### 队列

队列也是一种操作受限的线性表，栈是后进先出，而队列式先进先出。

典型应用场景：生产者消费者，阻塞等待的线程被放入队列。

![1610713008057](ArchitectureAdvanced.assets/1610713008057.png)



##### 用队列搜索好友中关系最近的有钱人

- 你的微信朋友圈的朋友就是马云

![1610713046144](ArchitectureAdvanced.assets/1610713046144.png)



##### 用队列搜索最短路径

- 类似于广度搜索

![1610713157818](ArchitectureAdvanced.assets/1610713157818.png)



#### 树

![1610713170729](ArchitectureAdvanced.assets/1610713170729.png)



##### 二叉搜索树

左子数上所有结点的值，均小于或等于它的根节点的值。

右子数上所有结点的值，均大于或等于它的根节点的值。

左，右子树也分别为二叉排序树。

![1610713312669](ArchitectureAdvanced.assets/1610713312669.png)



##### 不平衡的二叉排序树

- 树退化为链表

![1610713325964](ArchitectureAdvanced.assets/1610713325964.png)



##### 平衡二叉（排序）树

从任何一个结点出发，左右子树深度之差的结对之不超过1。

左右子树仍然为平衡二叉树。

![1610713422436](ArchitectureAdvanced.assets/1610713422436.png)



##### 旋转二叉树恢复平衡

插入时，最多只需要两次旋转就会重新恢复平衡。

删除时，需要维护从被删节点到根节点这条路径上所有节点的平衡性，时间复杂度O（logN）

![1610713496657](ArchitectureAdvanced.assets/1610713496657.png)



##### 红黑（排序）树

每个节点只有两种颜色：红色和黑色。

根节点是黑色的。

每个叶子节点 （NIL）都是黑色的空节点。

从根节点到叶子节点，不会出现两个连续的红色节点。

从任何一个节点出发，到叶子节点，这条路径上都有相同数目的黑色节点。

![1610713601319](ArchitectureAdvanced.assets/1610713601319.png)

增删节点的时候，红黑树通过染色和旋转，保持红黑树满足定义

![1610713612019](ArchitectureAdvanced.assets/1610713612019.png)



##### 红黑树 VS 平衡二叉树

红黑树最多只需3次旋转就会重新达成红黑平衡，时间复杂度 O(1)。

在大量增删的情况下，红黑树的效率更高。

红黑树的平衡性不如平衡二叉树，查找效率更差一些。





#### 跳表

![1610713782924](ArchitectureAdvanced.assets/1610713782924.png)



#### 常用算法

- 穷举算法
- 递归算法
- 贪心算法
- 动态规划



##### 递归算法（快速排序算法）

时间复杂度：n* log(n)

![1610713901042](ArchitectureAdvanced.assets/1610713901042.png)



##### 贪心算法

背包问题：小偷背了一个 4 磅背包去商城偷东西，将那些商品装入背包才能受益最大化。

![1610713977615](ArchitectureAdvanced.assets/1610713977615.png)



##### 改进贪心算法 - 迪杰斯特拉算法（最快路径）

- 迪杰斯特拉算法（最快路径）

![1610714064973](ArchitectureAdvanced.assets/1610714064973.png)

1.找出“最便宜”的节点，即可在最短时间内到达的节点。

2.更新该节点的邻居的开销，检查是否有前往它们的更短路径，如果有，就更新其开销。

3.重复这个过程，直到对图中的每个节点都这样做了

4.计算最终路径。

![1610714161585](ArchitectureAdvanced.assets/1610714161585.png)

地杰斯特拉算法的核心是找到起点到每个节点的最快路径。

![1610714188544](ArchitectureAdvanced.assets/1610714188544.png)

![1610714204382](ArchitectureAdvanced.assets/1610714204382.png)





##### 动态规划算法解决背包问题

通过找到合适的角度，将所求解的目标值在某（几）个维度上展开，将一个大问题拆解为若干个小问题，从小问题的最优解，寻找大问题的最优解。

![1610713977615](ArchitectureAdvanced.assets/1610713977615.png)

每个动态规划算法都从一个网格开始，背包问题的网格如下

![1610714408222](ArchitectureAdvanced.assets/1610714408222.png)

![1610714426489](ArchitectureAdvanced.assets/1610714426489.png)



#### 遗传算法解决背包问题

遗传算法（Genetic Algorithm， GA）是模拟达尔文生物进化论的自然选择和遗传学机理的生物进化过程的计算模型，是一种通过模拟自然进化过程搜索最优解的方法。

遗传算法以一种群体中的所有个体为对象，并利用随机化技术指导对一个被编码的参数空间进行高效搜索。其中，选择、交叉和变异构成了遗传算法的遗传操作；参数编码、初始群体的设定、适应度函数的设计、遗传操作设计、控制参数设定五个要素组成了遗传算法的核心内容。

80 公斤背包装哪些物品价值最大？

![1610714564859](ArchitectureAdvanced.assets/1610714564859.png)



##### 基因编码与染色体

物品基因编码

![1610714686729](ArchitectureAdvanced.assets/1610714686729.png)

基因组合：染色体

选择初始染色体：随机产生（也可以人为或者算法选择）

![1610714696967](ArchitectureAdvanced.assets/1610714696967.png)



##### 适应函数与控制参数

选择适应度函数，这里为商品总价值

![1610714781561](ArchitectureAdvanced.assets/1610714781561.png)

选择控制参数，这里为重量

![1610714791498](ArchitectureAdvanced.assets/1610714791498.png)

染色体 101011超重，淘汰





##### 选择算法

在剩下的染色体中选择可以被遗产下去的染色体以及繁殖次数

![1610714970191](ArchitectureAdvanced.assets/1610714970191.png)

选择算法

- 轮盘赌选择( Roulette Wheel Selection:是一种回放式随机采样方法。每个染色体进入下一代的概率等于它的适应度值与整体适应度值和的比例。    
- 随机竞争选择(Stochastic Tournament):每次按轮盘赌选择一对个体,然后让这两个个体进行竞争,适应度高的被选中,如此反复,直到选满为止。    
- 均匀排序:对群体中的所有个体按期适应度大小进行排序,基于这个排序来分配各个  个体被选中的概率。



##### 交叉遗传

选择结果：101010 和 010101 各翻番至两次

生产下一代：染色体交叉遗传

![1610715131850](ArchitectureAdvanced.assets/1610715131850.png)

循环迭代，如果连续几代遗传都没有出现更强的染色体（价值总和更大），那么算法收敛，当前最大价值的染色体为最终解。

有时候会在遗传过程中进行基因突变，得到基因突变染色体。





##### 遗传算法得到的不是最优解

遗传算法过程

![1610715172664](ArchitectureAdvanced.assets/1610715172664.png)





### 网络通信协议

#### Web 请求的一次网络通信历程

![1610969391960](ArchitectureAdvanced.assets/1610969391960.png)



#### OSI 七层模型和 TCP/IP 四层模型

- 应用层（HTTP）
- 表示层
- 会话层
- 传输层（TCP，UDP）
- 网络层（IP）
- 数据链路层（mac）
- 物理层

![1610969418331](ArchitectureAdvanced.assets/1610969418331.png)

![1610969458554](ArchitectureAdvanced.assets/1610969458554.png)



#### 网络数据包格式

![1610969908930](ArchitectureAdvanced.assets/1610969908930.png)



#### 物理层

物理层负责数据的物理传输,计算机输入输出的只能是01这样的二进制数据,但是在真正的通信线路里有光纤、电缆、无线各种设备。

光信号和电信号,以及无线电磁信号在物理上是完全不同的,如何让这些不同的设备能够理解、处理相同的二进制数据,这就是物理层要解决的问题。



#### 链路层

链路层就是将数据进行封装后交给物理层进行传输,主要就是将数据封装成数据帧,以帧为单位通过物理层进行通信,有了帧,就可以在帧上进行数据校验,进行流量控制。        

链路层会定义帧的大小,这个大小也被称为最大传输单元。

像HTTP要在传输的数据上添加一个HTTP头一样,数据链路层也会将封装好的帧添加一个帧头,帧头里记录的一个重要信息就是发送者和接受者的MAC地址。MAC地址是网卡的设备标识符,是唯一 的,数据帧通过这个信息确保数据送达到正确的目标机器。



##### 数据链路层负载均衡

![1610361116518](ArchitectureAdvanced.assets/1610361116518.png)



#### 网络层

网络层IP协议使得互联网应用根据IP地址就能访问到目标服务器，请求离开App后，到达运营服务商的交换机，交换机会根据这个IP地址进行路由转发，可能中间会经过很多个转发节点，最后数据到达目标服务器。

网络层的数据需要交给链路层进行处理，而链路层帧的大小定义了最大传输单元，网络层的IP数据包必须要小于最大传输单元才能进行网络传输，这个数据包也有一个IP头，主要包括的就是发送者和接受者的IP地址。





##### IP 负载均衡

![1610360688551](ArchitectureAdvanced.assets/1610360688551.png)



#### 传输层（TCP协议）

IP 协议不是一个可靠的通信协议，不会建立稳定的通信链路，并不会确保数据一定送达。要保证通信的稳定可靠，需要传输层协议 TCP。

TCP协议是一种面向连接的、可靠的、基于字节流的传输层协议。TCP作为一个比较基础的通讯协议，有很多重要的机制保证了TCP协议的可靠性和强壮性：

- 使用序号，对收到的TCP报文段进行排序和检测重复的数据
- 无错传输，使用校验和检测报文段的错误
- 使用确认和计时器来检测和纠正丢包或者延时
- 流量控制，避免主机分组发送得过快而使接收方来不及完全收下
- 拥塞控制，发送方根据网络承载情况控制分组的发送量，以获得高性能同时避免拥塞崩溃丢失包的重传

TCP建立连接的3次握手过程

- 1.App先发送SYN=1,Seq=X的报文,表示请求建立连接,是一个随机数;   
- 2.服务器收到这个报文后,应答SYN=1,  ACK=X+1,Seq=Y的报文,表示同意建立  连接;       
- 3.App收到这个报文后,检查ACK的值为自己发送的Seq值+1,确认建立连接,并发送ACK=Y+1的报文给服务器;
- 服务器收到这个报文后检查ACK值为自己发送的Seq 值+1,确认建立连接。
- 至此,App和服务器  建立起TCP连接,就可以进行数据传输了。

![1610970267861](ArchitectureAdvanced.assets/1610970267861.png)

TCP关闭连接4次挥手

- 客户端向服务器端发送一个FIN,请求关闭数据传输。
- 当服务器接收到客户端的FIN时,向客户端发送一个ACK,其中ACK的值等于FIN+SEQ。
- 然后服务器向客户端发送一个FIN，告诉客户端应用程序关闭。      
- 当客户端收到服务器端的FIN时,回复一个ACK给服务器端。其中ACK 的值等于FIN+SEQ。

![1610970404340](ArchitectureAdvanced.assets/1610970404340.png)



#### 应用层 HTTP 协议

而互联网应用需要在全球范围为用户提供服务，将全球的应用和全球的用户联系在一起，需要一个统一的应用层协议，这个协议就是 HTTP 协议。

![1610970493540](ArchitectureAdvanced.assets/1610970493540.png)



##### HTTP 请求的7中方法

- Get:只读请求,请求处理过程不应该产生副作用,即web应用不应该因为get请求而发生任何状态改变。 
- Head:和get方法一样,但是只返回响应头。    
- Post:提交请求。    
- Put:上传请求。    
- Delete:删除URL标识的资源。    
- Trace:回显服务器收到的请求,用以测试或者诊断。    
- options: 请求服务器返回支持的所有HTTP请求方法,测试服务器是否正常。

![1610970607705](ArchitectureAdvanced.assets/1610970607705.png)



##### HTTP 响应的5种状态

- 1xx消息一请求已被服务器接收,继续处理  
- 2xx成功一请求已成功被服务器接收、理解、并接受    
- 3xx重定向一需要后续操作才能完成这一请求  
- 4x请求错误一一请求含有词法错误或者无法被执行    
- 5x服务器错误一一服务器在处理某个正确请求时发生错误

![1610970683467](ArchitectureAdvanced.assets/1610970683467.png)



##### HTTP 协议版本

1996 年发布了 HTTP/1.0，在HTTP/1.0 中，客户端和服务器之间交换的每个请求/响应都会创建一个新的 TCP 连接，这意味着所有请求之前都需要进行TCP握手连接，因此所有请求都会产生延时。

![1610970951281](ArchitectureAdvanced.assets/1610970951281.png)

HTTP/1.1试图引入保持连接的概念来解决这些问题，它允许客户端复用 TCP连接，从而分摊了建立初始连接和针对多个请求缓慢启动的成本。但任意时刻上每个连接只能执行一次请求/响应交换。

随着网络的发展，网站所需资源（CSS、JavaScript 和图像等）不断增长，浏览器在获取和呈现网页时需要越来越多的并发性。但由于HTTP/1.1只允许客户端同时进行一次HTTP请求/响应交换，因此在网络层上获得并发能力的唯一方法是并行使用多个 TCP连接。

![1610971045530](ArchitectureAdvanced.assets/1610971045530.png)

HTTP/2引入了HTTP“流”的概念，允许将不同的HTTP并发地复用到同一TCP连接上，使浏览器更高效地复用TCP连接。

HTTP/2解决了单个TCP连接的使用效率低的问题，现在可以通过同一连接同时传输多个请求/响应。但是，TCP并不理解HTTP流，当多个HTTP请求复用一个TCP连接，如果前面的请求/响应没有处理完，后面的请求/响应也无法处理，也就是会出现队头堵塞现象。

![1610971134302](ArchitectureAdvanced.assets/1610971134302.png)

HTTP/3不是使用TCP作为会话的传输层而是使用QUIC(一种新的互联网传输协议)。

该协议在传输层将流作为一等公民引入。多个QUIC流共享相同的QUIC连接，因此不需要额外的握手和慢启动来创建新的QUIC流。但QUIC流是独立的,因此在大  多数情况下,只影响一个流的丢包不会影响其他流,这是因为QUIC数据包封装在UDP 数据包。

![1610971249396](ArchitectureAdvanced.assets/1610971249396.png)



### 非阻塞网络 I/O

#### 计算机之间如何进行网络请求？

- Socket，端口

![1610971354632](ArchitectureAdvanced.assets/1610971354632.png)



#### 服务器 - 客户端

![1610971388155](ArchitectureAdvanced.assets/1610971388155.png)



#### 多线程服务器 - 客户端

![1610971426084](ArchitectureAdvanced.assets/1610971426084.png)



#### 线程池服务器

![1610971443214](ArchitectureAdvanced.assets/1610971443214.png)



#### BIO Blocking I/O 阻塞 I/O

阻塞 I/O：进行 I/O 操作时，用户线程会一直阻塞，直到读操作或者写操作完成。

![1610971568984](ArchitectureAdvanced.assets/1610971568984.png)



#### Socket 接收数据，系统内核的处理过程

- socket 缓冲区这个概念

![1610971621729](ArchitectureAdvanced.assets/1610971621729.png)



#### 非阻塞I/O（Non-Blocking I/O）

非阻塞I/O: I/O操作立即返回发起线程不会阻塞等待。    

非阻塞read操作:    

- Socket接收缓冲区有数据,读n个(不保证数据被读完整,因此有可能需要多次读)。    
- Socket接收缓冲区没数据,则返回失败(不会等待)。

非阻塞 write:

- Socket发送缓冲区满,返回失败(不会等待)  
- Socket发送缓冲区不满,写n个数据(不保证一次性全部写入,因此可能需要多次写)

![1610971815286](ArchitectureAdvanced.assets/1610971815286.png)



#### Java NIO (New I/O)

- Selector(选择器)
- Buffer(缓存)
- SelectableChannel(通道)
- SelectionKey

![1610971919856](ArchitectureAdvanced.assets/1610971919856.png)

![1610971984682](ArchitectureAdvanced.assets/1610971984682.png)



#### Java IO 与 NIO 比较

```java
// java IO

ServerSocket serverSocket = new ServerSocket(port);

while (true) {
    final Socket socket = serverSocket.accept();

    new Thread(new Runnable() {
        @Override
        public void run() {
            InputStream in = socket.getInputStream();
            OutputStream out = socket.getOutputStream();

            byte[] content = new byte[1024];
            int len;
            StringBuilder sb = new StringBuilder();

            while ((len = in.read(content)) != -1) {
                sb.append(content, 0, len);
            }
            out.write("Receive Success!\n".getBytes(StandardCharsets.UTF_8));
            out.flush();
            socket.shutdownOutput();

            // ...
        }
    }).start();
    
}
```

```java
// java NIO

InetSocketAddress address = new InetSocketAddress(8888);
ServerSocketChannel server = ServerSocketChannel.open();
server.bind(address);
server.configureBlocking(false);

Selector selector = Selector.open();
server.register(selector, SelectionKey.OP_ACCEPT);

while (true) {
    selector.select();
    Iterator<SelectionKey> keys = selector.selectedKeys().iterator();

    while (keys.hasNext()) {
        SelectionKey key = keys.next();
        ByteBuffer buffer = ByteBuffer.allocate(1024);

        if (key.isAcceptable()) {
            ServerSocketChannel serverSocketChannel = (ServerSocketChannel) key.channel();
            SocketChannel channel = serverSocketChannel.accept();
            channel.configureBlocking(false);
            channel.register(selector, SelectionKey.OP_READ);
        }

        if (key.isReadable()) {
            SocketChannel channel = (SocketChannel) key.channel();
            channel.read(buffer);
            // ...
            channel.register(selector, SelectionKey.OP_WRITE);
        }

        if (key.isWritable()) {
            SocketChannel channel = (SocketChannel) key.channel();
            channel.write(buffer);
            // ...
            channel.register(selector, SelectionKey.OP_READ);
        }

        keys.remove();
    }
}
```



#### 系统 I/O 复用方式：select, poll, epoll

![1610973267775](ArchitectureAdvanced.assets/1610973267775.png)



##### Select（poll）管理下的read过程

![1610973336025](ArchitectureAdvanced.assets/1610973336025.png)



##### epoll 管理下的read过程

![1610973388337](ArchitectureAdvanced.assets/1610973388337.png)



#### 无活动连接时，Selector.select 方法被阻塞

![1610973742321](ArchitectureAdvanced.assets/1610973742321.png)





### 数据库架构原理

#### PreparedStatement 预编译

```java
statement.executeUpdate("UPDATE Users SET stateus 2 WHERE userlD=233");     

PreparedStatement updateUser = con.prepareStatement("UPDATE Users SET stateus=? WHERE userlD=233");    
updateUser.setInt(1, 2);    
updateUser.executeUpdate();
```



#### 数据库架构

- 连接器
- 语法分析器
- 语义分析与优化器
- 执行引擎

![1610973759884](ArchitectureAdvanced.assets/1610973759884.png)



#### 连接器

数据库连接器会为每个连接请求分配一块专用的内存空间用于会话上下文管理。

建立连接对数据库而言相对比较重,需要花费一定的时间,因此应用程序启动的时候,通常会初始化建立一些数据库连接放在连接池里,这样当处理外部请求执行SQL操作的时候,  就不需要花费时间建立连接了。



#### 语法分析器

```sql
select s_grade from staff where s_city not in (select p_city from proj where s_empname=p_pname)
```

![1610974068571](ArchitectureAdvanced.assets/1610974068571.png)

```sh
mysql> explain select* from users whee id=1;    

ERROR 1064(42000): You have an error in your SQL syntax; check the manual that  corresponds to your MySQL server version for the right syntax to use near 'id 1'at line 1
```



#### 语义分析与优化器

语义分析与优化器就是要将各种复杂嵌套的SQL进行语义等价转化,得到有限几种关系  代数计算结构,并利用索引等信息进一步进行优化。                       

```sql
select f.id from orders f join users u on f.user_id=u.id;
-- 相互等价
select f.id from orders f where f user_id =(select id from users);
```



#### 执行计划

> 使用 explain 加 SQL语句，可以看到执行计划。

Key: 索引类型，NULL无索引

Rows: 需要处理的行数

Possible_keys：潜在可以利用的索引

![1610975324742](ArchitectureAdvanced.assets/1610975324742.png)



#### 为什么PrepareStatement更好

PrepareStatement 会预先提交带占位符的 SQL到数据库进行预处理，提前生成执行计划，当给定占位符参数，真正执行SQL的时候，执行引擎可以直接执行，效率更好一点。

PrepareStatement 可以防止 SQL注入攻击。

- select * from users where username = 'Frank'；
- Frank'；drop table users；--
- select * from users where username = 'Frank'；drop table users；--'；
- select * from users where username = ？；





#### B+ 树

- 所有的数据都存储在叶子节点

![1610975444827](ArchitectureAdvanced.assets/1610975444827.png)



#### 聚簇索引

聚簇索引：聚簇索引的数据库记录和索引存储在一起。

MySQL数据库的主键就是聚簇索引，主键ID和所在的记录行存储在一个B+树中。

![1610975564550](ArchitectureAdvanced.assets/1610975564550.png)





#### 非聚簇索引

非聚簇索引在叶子节点记录的就不是数据行记录，而是聚簇索引，也就是主键。

通过非聚簇索引找到主键索引，再通过主键索引找到行记录的过程也被称作回表。

![1610975674970](ArchitectureAdvanced.assets/1610975674970.png)



#### 添加必要的索引优化SQL查询性能

在几百行的数据库中查找一个记录，如果没有索引，就需要全表扫描，检索所有的行记录，才能找到需要的记录。

![1610975774168](ArchitectureAdvanced.assets/1610975774168.png)



#### 合理使用索引

不要盲目添加索引，尤其在生产环境中

- 添加索引的 alter 操作会消耗较长的时间（分钟级）
- alter操作器件，所有数据库的增删改操作全部阻塞，对应用而言，因为连接不能释放，事实上，查询也被阻塞。

删除不用的索引，避免不必要的增删开销。

使用更小的数据类型创建索引

- int 4 字节，bigint 8字节
- Timestamp 4 字节，Datetime  8 字节





#### 数据库事务

事务特性ACID

- 原子性( Atomicity):事务要么全部完成,要么全部取消。如果事务崩溃,状态回到事务之前(事务回滚)。      
- 隔离性( Ilsolation):如果2个事务T1和T2同时运行,事务T1和T2最终的结果是相同的,不管T1和T2谁先结束,隔离性主要依靠锁实现。      
- 持久性( Durability):一旦事务提交,不管发生什么(崩溃或者出错),数据要保存在数据库中。      
- 一致性( Consistency):只有合法的数据(依照关系约束和函数约束)才能写入数据库。

```sql
begin;  -- 开始一个事务
update table set A = A - 1 亿;  -- 伪sql, 仅作为示意
update table set B = B + 1 亿;
-- 其他读写操作
commit;  -- 提交事务
```



#### 数据库事务日志

进行事务操作时,事务日志文件会记录更新前的数据记录,然后再更新数据库中的记录,  如果全部记录都更新成功,那么事务正常结束,如果过程中某条记录更新失败,那么整个事务全部回滚,已经更新的记录根据事务日志中记录的数据进行恢复, 这样全部数据都恢复到事务提交前的状态,仍然保持数据一致性

- LSN:一个按时间顺序分配的唯一事务记录日志序列号。  
- TransID:产生操作的事务ID。  
- PageID:被修改的数据在磁盘上的位置。  
- PreVLSN:同一个事务产生的上一条日志记录的指针  
- UNDO:取消本次操作的方法,按照此方法回滚。  
- REDO:重复本次操作的方法。

![1610976342803](ArchitectureAdvanced.assets/1610976342803.png)



### JVM 虚拟机

#### JVM 组成架构

Java 是一种跨平台的语言，JVM屏蔽了底层系统的不同。为Java字节码文件构造了一个统一的运行环境。

- java org.apache.catalina.startup.Bootstrap "$@" start

![1611054927111](ArchitectureAdvanced.assets/1611054927111.png)



#### Java字节码文件

Java如何实现在不同操作系统、不同硬件平台上，都可以不用修改代码就能顺畅地执行？

计算机领域的任何问题都可以通过增加个中间层（虚拟层）来解决

Java 所有的指令有200个左右，一个字节（8位）可以存储256种不同的指令信息，一个这样的字节称为**字节码**（Bytecode）。

在代码的执行过程中，JVM将字节码解释执行，屏蔽对底层操作系统的依赖，JVM也可以将字节码编译执行，如果是热点代码，会通过JIT动态地编译为机器码，提高执行效率。

- 字节码的标志魔术数字是：cafe babe

![1611055039901](ArchitectureAdvanced.assets/1611055039901.png)



#### 字节码执行流程

- 注意：方法调用计数器加1，表示的是一个方法的调用次数，进行编译和解释执行的判断依据。

![1611055156370](ArchitectureAdvanced.assets/1611055156370.png)



#### Java字节码文件编译过程

- 词法解析
- 语法分析
- 生成字节码

![1611055217102](ArchitectureAdvanced.assets/1611055217102.png)



#### 类加载器的双亲委托模型        

低层次的当前类加载器,不能覆盖更高层次类加载器已经加载的类。如果低层次的类加载器想加载一个未知类,需要上级类加载器确认,只有当上级类加载器没有加载过这个类,也允许加载的时候,才让当前类加载器加载这个未知类。

![1611055301521](ArchitectureAdvanced.assets/1611055301521.png)



#### 自定义类加载器

- 隔离加载类：同一个JVM中不同组件加载同一个类的不同版本。
- 扩展加载源：从网络、数据库等处加载字节码。
- 字节码加密：加载自定义的加密字节码，在ClassLoader中解密。

```java
public class CustomClassLoader extends ClassLoader {

    @Override
    protected Class<?> findClass(String name) throws ClassNotFoundException {
        try {
            byte[] result = getClassFromCustomPath(name);

            if (result == null) {
                throw new FileNotFoundException();
            } else {
                return defineClass(name, result, 0, result.length);
            }

        } catch (Exception e) {
            e.printStackTrace();
        }
        throw new ClassNotFoundException(name);
    }

    private byte[] getClassFromCustomPath(String name) {
        // 从自定义路径中加载指定类
        return new byte[0];
    }

    public static void main(String[] args) {
        CustomClassLoader customClassLoader = new CustomClassLoader();
        try {
            Class<?> clazz = Class.forName("one", true, customClassLoader);
            Object obj = clazz.newInstance();
            System.out.println(obj.getClass().getClassLoader());
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
    
}
```



#### 堆 & 栈

堆：每个JVM实例唯一对应一个堆。应用程序在运行中所创建的所有类实例或数组都放在这个堆中，并由应用所有的线程共享。

堆栈：JVM为每个新创建的线程都分配一个堆栈。也就是说，对于一个Java程序来说，它的运行就是通过对堆栈的操作来完成的。

Java中所有对象的存储空间都是在堆中分配的，但是这个对象的引用却是在堆栈中分配，也就是说在建立一个对象时从两个地方都分配内存，在堆中分配的内存实际建立这个对象，而在堆栈中分配的内存只是一个指向这个堆对象的引用而已。



#### 方法区 & 程序计数器        

方法区主要存放从磁盘加载进来的类字节码,而在程序运行过程中创建的类实例则存放在堆里。

程序运行的时候,实际上是以线程为单位运行的,当JVM进入启动类的main 方法的时候,就会为应用程序创建一个主线程,main方法里的代码就会被这个主线程执行,每个线程有自己的Java栈,栈里存放着方法运行期的局部变量。而当前线程执行 到哪一行字节码指令,这个信息则被存放在程序计数寄存器。

![1611056103665](ArchitectureAdvanced.assets/1611056103665.png)



#### Java （线程）栈

所有在方法内定义的基本类型变量，都会被每个运行这个方法的线程放入自己的栈中，线程的栈彼此隔离，所以这些变量一定是线程安全的。

![1610624928840](ArchitectureAdvanced.assets/1610624928840.png)



#### 线程工作内存 & volatile

Java内存模型规定在多线程情况下，线程操作主内存变量，需要通过线程独有的工作内存拷贝主内存变量副本来进行。

一个共享变量（类的成员变量、类的静态成员变量）被volatile修饰之后，保证了不同线程对这个变量进行操作时的可见性，即一个线程修改了某个变量的值，这新值对其他线程来说是立即可见的。

![1611056276111](ArchitectureAdvanced.assets/1611056276111.png)



#### Java 运行环境

![1611056379267](ArchitectureAdvanced.assets/1611056379267.png)



#### JVM 的垃圾收

JVM垃圾回收就是将JVM堆中的已经不再被使用的对象清理掉，释放宝贵的内存资源。

JVM通过一种**可达性分析算法**进行垃圾对象的识别，具体过程是：从线程栈帧中的局部变量，或者是方法区的静态变量出发，将这些变量引用的对象进行标记，然后看这些被标记的对象是否引用了其他对象，继续进行标记，所有被标记过的对象都是被使用的对象，而那些没有被标记的对象就是可回收的垃圾对象了。

进行完标记以后，JVM就会对垃圾对象占用的内存进行回收，回收主要有三种方法

- 清理：将垃圾对象占据的内存清理掉，其实JVM并不会真的将这些垃圾内存进行清理，而是将这些垃圾对象占用的内存空间标记为空闲，记录在一个空闲列表里，当应用程序需要创建新对象的时候，就从空闲列表中找一段空闲内存分配给这个新对象。
- 压缩：从堆空间的头部开始，将存活的对象拷贝放在一段连续的内存空间中，那么其余的空间就是连续的空闲空间。
- 复制：将堆空间分成两部分，只在其中一部分创建对象，当这个部分空间用完的时候，将标记过的可用对象复制到另一个空间中。

![1611056613156](ArchitectureAdvanced.assets/1611056613156.png)



#### JVM 分代垃圾回收

- 新生代：（Eden 区 、From 区，To 区）
- 老年代

![1611056655801](ArchitectureAdvanced.assets/1611056655801.png)



#### JVM 垃圾回收器算法

- 串行（单核时代）
- 并行
- CMS
- G1
- ZGC

![1611056733792](ArchitectureAdvanced.assets/1611056733792.png)



#### G1 垃圾回收内存管理机制

将整个内存区域分成不同的块，对于每一个块进行垃圾回收。

![1611056802494](ArchitectureAdvanced.assets/1611056802494.png)



#### Java 启动参数

标准参数,所有的JVM实现都必须实现这些参数的功能,而且向后兼容       

-  运行模式- server, -client  
- 类加载路径-cp,- classpath  
- 运行调试- verbose  
- 系统变量-D

非标准参数,默认jvm实现这些参数,但不保证所有jvm实现都实现,且不保证向后兼容                  

- -Xms初始堆大小 
-  Xmx最大堆大小  
- Xmn新生代大小  
- Xss线程堆栈大小

非 Stable参数,此类参数各个jm实现会有所不同,将来可能会随时取消

- -xx: Use ConcMarkSweepGC  启用CMS垃圾回收                                                       



#### JVM 性能诊断工具

基本工具： JPS, JSTAT, JMAP, JSTACK

集成工具：JConsole, JVisualVM



#### JPS        

JPS用来查看host上运行的所有java进程的id ( jvmid), 一般情况下使用这个工具的目的 只是为了找出运行的jvm进程id,即 jvmid,然后可以进一步使用其它的工具来     监控和分析JVM。

常用的几个参数:

- -l 输出java应用程序的 main class的完整包  
- -q 仅显示pid,不显示其它任何相关信息          
- -m 输出传递给main方法的参数
- -v 输出传递给JVM的参数。在诊断JVM相关问题的时候,这个参数可以查看JVM相关参数的设置



#### JSTAT        

JSTAT(“Java Virtual Machine statistics monitoring tool”) 是JDK自带的一个轻量级小工具。

主要对Java应用程序的资源和性能进行实时的命令行的监控,包括了对Heap  size和垃圾回收状况的监控。    

语法结构如下: jstat[Options] vmid [interval] [count]

- Options --选项,我们一般使用 -gcutil 查看gc情况  
- vmid --VM的进程号,即当前运行的java进程号  
- interval --间隔时间,单位为毫秒  
- count --打印次数,如果缺省则打印无数次

```sh
$ jstat -gcutil 7784 1000 10                                              
  S0     S1     E      O      M     CCS    YGC     YGCT    FGC    FGCT     GCT
  0.00  92.05   4.15  43.64  95.82  91.93      7    0.039     2    0.070    0.109
  0.00  92.05   4.15  43.64  95.82  91.93      7    0.039     2    0.070    0.109
  0.00  92.05   4.24  43.64  95.82  91.93      7    0.039     2    0.070    0.109
  0.00  92.05   4.38  43.64  95.82  91.93      7    0.039     2    0.070    0.109
  0.00  92.05   4.47  43.64  95.82  91.93      7    0.039     2    0.070    0.109
  0.00  92.05   4.51  43.64  95.82  91.93      7    0.039     2    0.070    0.109
  0.00  92.05   4.60  43.64  95.82  91.93      7    0.039     2    0.070    0.109
  0.00  92.05   4.65  43.64  95.82  91.93      7    0.039     2    0.070    0.109
  0.00  92.05   4.74  43.64  95.82  91.93      7    0.039     2    0.070    0.109
  0.00  92.05   4.87  43.64  95.82  91.93      7    0.039     2    0.070    0.109
```

- S0 -- Heap上的 Survivor space 0 区已使用空间的百分比  
- S1 -- Heap上的 Survivor space 1区已使用空间的百分比 
- E  -- Heap上的 Eden space区已使用空间的百分比  
- O -- Heap上的 Old space区已使用空间的百分比  
- YGC -- 从应用程序启动到采样时发生 Young GC的次数  
- YGT -- 从应用程序启动到采样时 Young GC所用的时间(单位秒)  
- FGC -- 从应用程序启动到采样时发生 Full GC的次数  
- FGCT -- 从应用程序启动到采样时 Full GC所用的时间(单位秒)  
- GCT--从应用程序启动到采样时用于垃圾回收的总时间(单位秒)



#### JMAP

JMAP是一个可以输出所有内存中对象的工具,甚至可以将JVM中的heap,以二进制输出成文本。        

使用方法

- jmap -histo pid>a.log 可以将其保存到文本中去,在一段时间后,使用文本对比工具,可以对比出GC回收了哪些对象。 
- jmap -dump:formatb,file=f1 PID 可以将该 PID 进程的内存 heap输出出来到f1文件里。
                                 



#### JSTACK

Jstack 可以查看 jvm 内的线程堆栈信息

```sh
$ jps                                                                          ─╯
7459 RemoteMavenServer36
7285
8054 Launcher
8055 MainFm
7335 RemoteMavenServer36
8087 Jps

$ jstack -l 8055                                                               ─╯
2021-01-19 20:05:52
Full thread dump Java HotSpot(TM) 64-Bit Server VM (25.231-b11 mixed mode):

"Prism Font Disposer" #24 daemon prio=10 os_prio=31 tid=0x00007ff57c957000 nid=0x11533 in Object.wait() [0x000070000618a000]
   java.lang.Thread.State: WAITING (on object monitor)
	at java.lang.Object.wait(Native Method)
	at java.lang.ref.ReferenceQueue.remove(ReferenceQueue.java:144)
	- locked <0x00000007406f70c8> (a java.lang.ref.ReferenceQueue$Lock)
	at java.lang.ref.ReferenceQueue.remove(ReferenceQueue.java:165)
	at com.sun.javafx.font.Disposer.run(Disposer.java:93)
	at java.lang.Thread.run(Thread.java:748)

   Locked ownable synchronizers:
	- None
```



#### JConsole

![1611058018024](ArchitectureAdvanced.assets/1611058018024.png)



#### JVisualVM

![1611058057663](ArchitectureAdvanced.assets/1611058057663.png)





### Java 代码优化

#### 合理并谨慎使用多线程        

使用场景(1O阻塞,多CPU并发)    

资源争用与同步问题    

java.util.concurrent      

**启动线程数** = [任务执行时间/(任务执行时间 - IO等待时间) * CPU内核数

- 最佳启动线程数和CPU内核数量成正比,和IO阻塞时间成反比。
- 如果任务都是CPU计算型任务,那么线程数最多不超过CPU内核数,因为启动再多线程,CPU也来不及调度;
- 相反如果是任务需要等待磁盘操作,网络响应,那么多启动线程有助于提高任务并发度,提高系统吞吐能力,改善系统性能。



#### 竞态条件与临界区        

在同一程序中运行多个线程本身不会导致问题,问题在于多个线程访问了相同的资源。    

当两个线程竞争同一资源时,如果对资源的访问顺序敏感,就称存在竞态条件。导致竞态条件发生的代码区称作临界区。    

在临界区中使用适当的同步就可以避免竞态条件。



#### Java 线程安全

允许被多个线程安全执行的代码称作线程安全的代码    

方法局部变量          

- 局部变量存储在线程自己的栈中。
- 也就是说,局部变量永远也不会被多个线程共享。所以,  基础类型的局部变量是线程安全的

方法局部的对象引用     

- 如果在某个方法中创建的对象不会逃逸出该方法,那么它就是线程安全的 

对象成员变量

- 对象成员存储在堆上。如果两个线程同时更新同个对象的同一个成员,那这个代码就不是程安全的





#### 面试问题

Java Web 应用的多线程从哪儿来的？（Tomcat容器的）

Servlet 是线程安全的吗？（本身是安全的，实现的方法不是安全的，因为存在局部变量，存储在方法区）



#### ThreadLocal

创建一个ThreadLocal 变量（X类静态成员变量）：

- public static ThreadLocal my ThreadLocal=new ThreadLocal()；

存储此对象的值（A类a方法）：

- X.myThreadLocal.set("A thread local value")；

读取一个ThreadLocal对象的值（B类b方法）：

- String threadLocalValue=(String)X.my ThreadLocal.get()；

```java
public class CustomThreadLocal {
    public void set(T value) {
        Thread t = Thread.currentThread();
        ThreadLocalMap map = getMap(t);

        if (map != null) {
            map.set(this, value);
        } else {
            createMap(t, value);
        }
    }

    void createMap(Thread t, T firstValue) {
        t.threadLocals = new ThreadLocal.ThreadLocalMap(this, firstValue);
    }

    void getMap(Thread t) {
        return t.threadLocals;
    }
}
```

![1611058750799](ArchitectureAdvanced.assets/1611058750799.png)



#### Java 内存泄漏

Java 内存泄漏是由于开发人员的错误引起的。

如果程序保留对永远不再使用的对象的引用，这些对象将会被占用并耗尽内存。

- 长生命周期对象
- 静态容器
- 缓存



#### 代码优化建议

合理使用线程池和对象池

- 复用线程或对象资源,避免在程序的生命期中创建和删除大量对象 
- 池管理算法(记录哪些对象是空闲的,哪些对象正在使用)  
- 对象内容清除( Thread Local的清空)

使用合适的JDK容器类(顺序表,链表,Hash)

- LinkList和 ArrayList的区别及适用场景  
- HashMap的算法实现及应用场景  
- 使用 concurrent包, ConcurrentHashMap和 HashMap的线程安全特性有什么不同?

缩短对象生命周期,加速垃圾回收

- 减少对象驻留内存的时间  
- 在使用时创建对象,用完释放  
- 创建对象的步骤(静态代码段-静态成员变量-父类构造函数-子类构造函数)

```java
public class StaticClass {
    static {
        A a = new A();
    }
  
  public static void cc() {
      System.out.println("cc");
  }
}
```

使用 I/O buffer 及 NIO

- 延迟写与提前读策略
- 异步无阻塞 IO 通信

优先使用组合代替继承

- 减少对象耦合
- 避免太深的继承层次带来的对象创建性能损失

合理使用单例模式

- 无状态对象
- 线程安全

计算机的任何问题都可以通过虚拟层（或者中间层）解决

- 面向接口编程
- 7层网络协议
- JVM
- 编程框架
- 一致性 hash 算法的虚拟化实现





### 作业与实践

请简述 JVM 垃圾回收原理。

设计一个秒杀系统，主要的挑战和问题有哪些？核心的架构方案或者思路有哪些？





### 秒杀案例

#### XXXX 性能现状

XXXX网站的正常流量情况

- 并发（单台），高峰期<10；
- 吞吐量（TPS，单台）高峰期，<60；
- CPU负载Load高峰期，<2，大部分服务器<1；
- CPU使用率，一般只占1颗核，平均60%左右；
- 服务器平均响应时间高峰期，<150ms；(150 = (1/60) x 1000 x 10)
- 图片总流量带宽1.8G（各网站总合）。

高并发下的风险

- 网络带宽耗尽
- 服务器Load飙高，停止响应。
- 数据库瘫痪

高并发下的事故

- 事故：网站运营推广页面弹出1兆大图片导致带宽耗尽
  - 增加审核机制：运营推广增加的图片流量不能超过现有流量的30%
- 合作媒体推广：迅雷，暴风影音浮出广告，导致ZZ集群 Crash。

秒杀

- XXXX.com开业88小时不间断秒杀活动





#### 高并发对网站性能的影响

- 注意并发数是指数上升，所以与线性的并发数，绘图不一致

![1611212704667](ArchitectureAdvanced.assets/1611212704667.png)



#### 高并发实例：XXX.com 开业秒杀活动

商业需求            

- 为庆祝xxxx.com开业推出88小时不间断秒杀活动。
- 每小时整点推出8款商品
- 每款商品共168件,每人限批3件,成交人数56人。
- CCTV黄金广告时间,各种网络,平面媒体轰炸,总广告费:1.5亿。  
- 接到运营通知,距秒杀开始仅仅5天时间。

技术挑战

- 瞬间高并发      
  - 8000并发:预估秒杀在线人数可达8000人  
  - 风险:带宽耗尽。  
  - 服务器:崩溃,可以理解成自己给自己准备的D.D.O.S攻击
- 秒杀器
  - 第一种:秒杀前不断刷新秒杀页面,直到秒杀开始,抢着下单。  
  - 第二种:跳过秒杀页面,直接进入下单页面,下单。

技术解决

- 站出来
- 重新开发一个系统，应对秒杀活动



#### XXX.com 秒杀系统：服务器和网络准备

服务器准备(距秒杀开始仅五天时间来不及采购)            

- style 服务器(Lighttpd集群): 5台  
- 图片服务器(Nginx集群): 5台  
- 静态服务器(Apache集群):10台  
- 交易服务器(JBoss动态集群):10台

带宽准备

- 图片出口带宽上限: 2.5G(出口带宽支持10G,但图片服务器集群的处理能力:图片服务集群最大并发处理能力网站平均图片大小=2.5G)
- CDN准备: Chinacache沟通;借用 CCCC CDN



#### XXX.com 秒杀系统：架构目标

1.图片网络带宽:1.0G            

- 新增图片带宽:必须控制在1.0G左右    
- 每件商品秒杀页面的图片总大小不得超过： 1000000/(1000*8) = 125K/每商品

2.网站并发:

- 单件商品并发:1000【来自运营的预估】    
- 总并发: 8(件商品)X1000(人商品)=8000



#### XXX.com 秒杀系统：组成

简单系统：

- 三个页面组成：秒杀商品列表，秒杀商品介绍，下单
- 下单成功后，进入支付系统，走支付流程

![1611213427506](ArchitectureAdvanced.assets/1611213427506.png)



#### XXX.com 秒杀系统：设计原则

静态化        

- 采用JS自动更新技术将动态页面转化为静态页面

并发控制,防秒杀器        

- 设置阀门,只放最前面的一部分人进入秒杀系统

简化流程          

- 砍掉不重要的分支流程,如下单页面的所有数据库查询    
- 以下单成功作为秒杀成功标志。支付流程只要在1天内完成即可。

前端优化

- 采用 YSLOW原则提升页面响应速度





#### XXX.com 秒杀系统：静态化

秒杀商品 list 和 Detail 是静态 HTML 页面

![1611213646432](ArchitectureAdvanced.assets/1611213646432.png)

秒杀商品列表 / 秒杀商品介绍页面，如何判断秒杀开始否

- 答案：valid-offer.js

- ```js
  var valid_offerIds = 2233322, 2235322, 2237322, 2238322, 2233392
  ```

![1611213786373](ArchitectureAdvanced.assets/1611213786373.png)



#### 三道阀门的设计

阀门： 基于 TT 的计时器

| 序号 | 阀门上限               |
| ---- | ---------------------- |
| 1    | 限制进入秒杀页面，1000 |
| 2    | 限制进入下单页面，100  |
| 3    | 限制进入支付系统，56   |

![1611213941435](ArchitectureAdvanced.assets/1611213941435.png)



#### 秒杀器的预防

秒杀 Detail 页面

- URL: 随机
- 秒杀前2秒放出，脚本生成，秒杀亲
- 1000次访问上限控制，每件商品只能放入1000人浏览

下单页面

- 订单ID 随机
- 不能直接跳过秒杀 Detail 页面进入
- 每个秒杀商品，携带预先生成的随机 Token 作 URL 参数
- 如果秒杀过，直接跳到秒杀结束页面
- 100次 访问上限控制，每件商品只能放入1000人下单

```xml
SetEnvIfNoCase Referee "^http://1688\.com" local_ref=1

<FilesMatch "\.(html|htm)">
		Order Allow, Deny
  	Allow from env=local_ref
</FilesMatch>
```





#### Web Server 调优 - Apache调优

- KeepAlive 相关参数调优
- 其他参数调优
  - HostnameLookups 设为off，对allowfromdomain 等后的域名不进行正向和反向的 dns 解析。
- 关闭cookies-log日志
- 打开Linux sendfile（)
- 关闭无用的module
  - mod_Gzip
  - （秒杀页面，非图片HTML文本所占流量比重可忽略不计，zip意义不大）
  - mod_Beacon
  - mod_hummock（等待反应过来，秒杀已经 over了）

```xml
Timeout 30
KeepAlive On
MaxKeepAliveRequests 1000
KeepAliveTimeout 30

<IfModule worker.c>
    StartServers  5
    MaxClients  1024
    MinSpareThreads  25
    MaxSpareThreads  250
    ThreadsPerChild  64
    ThreadLimit  128
    ServerLimit  16
</IfModule>

# Assume no memory leaks at all MaxRequestsPerChild  20000
```





#### Web Server 调优 - JBoss调优

Mod-jk worker 调优

![1611214825273](ArchitectureAdvanced.assets/1611214825273.png)

JBoss AJP Connector

![1611214835867](ArchitectureAdvanced.assets/1611214835867.png)

Tomcat APR 设定



#### 秒杀静态页面优化

图片合并       

- 8张图片合并成1张,CSS偏移展示。
- 减少HTTP请求数,减少请求等待数。  
- 减少发送 Cookies的量。

HTML内容压缩    

图片压缩:图片 Bytes<长X宽/2250    

HTML Header Cache-Control 设置    

CSS,JS精简

- CSS,JS精简到极致,部分直接写在页面中，减少 HTTP 请求次数

![1611215021797](ArchitectureAdvanced.assets/1611215021797.png)



#### 下单页面优化

 数据库操作:全部砍掉   

-  原下单页面要访问8次数据库,全部砍掉。

秒杀流程精简    

- 砍掉填写或选择收货地址,放在秒杀成功后填写
- 砍掉调用是否开通支付接口,秒杀首页文案提示必须开通。

采用内存缓存

- 秒杀 Offer数据,支付相关信息,缓存

![1611215035280](ArchitectureAdvanced.assets/1611215035280.png)



#### 交易系统性能优化

- 交易系统调优目标

|                    | 并发 | TPS  |
| ------------------ | ---- | ---- |
| 下单页面（优化前） | 20   | 100  |
| 下单页面（优化后） | 40   | 400  |

- 关闭 KeepAlive (分析交易系统 accesslog, 用户短时间内连续点击概率很低)
- JVM 优化
- 优化 CMS 垃圾回收器的参数
- 消灭 Top 10  Bottlenecks
  - Velocity 参数调优
  - 采用 DBCP 1.4 替换 C3P0
  - Offer 产品参数的 XML 解析



#### 二跳页面的优化

xxxx.com其他页面   

-  前端优化: Yslow规则调优      
  - 减少HTTP请求,合并JS,CSS,图片,充分利用浏览器缓存。
- 图片压缩,公式  
- 避免发送 Cookies 

交易系统优化

- 普通订单管理列表和XXXX秒批订单管理列表分离  
- 禁止用模糊查询功能



#### 应急预案

- 域名分离，独立域名，不影响XXXX原有业务。
  - Style集群：style.XXXX.china.XXXX.com
  - 图片服务器集群：img.XXXX.china.XXXX.com
  - 静态页面集群：page.XXXX.china.XXXX.com
  - 出问题直接把XXXX相关域名卡掉，所有请求跳到万能出错页面。
- 机动服务器10台，备用。
- 拆东墙补西墙战略
  - 5天时间来不及采购服务器，因此SA待命，随时准备将非核心应用集群的冗余服务器下线，加入到秒杀集群。
- 壁虎断尾策略
  - 所有办法均失效的情况下，例如流量耗尽。
  - 非核心应用集群统统停止服务，如资讯，论坛，博客等社区系统。
  - 保住首页，Offer Detail，旺铺页面等核心应用的可用性。
- 万能出错页面：秒杀活动已经结束
  - 任何出错都302跳转到此页面
  - 位于另外集群
- 万幸：最终所有的预案都没有用上



#### 秒杀活动结果

88小时秒杀，坚守阵地，大获成功

秒杀还是被秒杀？终于有了答案

三道阀门设计非常有效，拦住了秒杀器

![1611216207649](ArchitectureAdvanced.assets/1611216207649.png)



#### 改进一：采用更轻量/快速的服务器

采用 Lighttpd 替代 Apache 杀手锏（AIO）

![1611216321470](ArchitectureAdvanced.assets/1611216321470.png)

Lighttpd 1.5 VS Apache 2.2.4

小页面性能（100K）

- http_load -verbose -timeout 40 -parallel 100 -fetches 500 http-load.10M.urls-100M

![1611216457458](ArchitectureAdvanced.assets/1611216457458.png)

大页面性能（10M）

![1611216469069](ArchitectureAdvanced.assets/1611216469069.png)

性能关键：Web Server 的高性能 I/O

![1611216530394](ArchitectureAdvanced.assets/1611216530394.png)

升级软件版本，进行应用服务器升级

![1610543939031](ArchitectureAdvanced.assets/1610543939031.png)



#### 改进二：前端优化自动化

- XXXX服务器响应时间<150ms，但Offer Detail 页面用户等待时间5s，大部分时间耗在路上（资源请求和网络传输）
- 图片自动压缩（CMS自动压缩）
- Cookies 服务化（控制Cookies的大小）
- XXXX前端延迟加载框架 SmartLoad（只加载首屏数据）
- Google module_pagespeed module
  - 自动压缩图片，静态资源，智能浏览器缓存技术
- Google Diffable (增量下载静态资源技术）

![1611217018696](ArchitectureAdvanced.assets/1611217018696.png)



#### 改进三：架设镜像站组建山寨CDN

XXXX 青岛镜像站项目

![1611217093843](ArchitectureAdvanced.assets/1611217093843.png)

![1611217127491](ArchitectureAdvanced.assets/1611217127491.png)



#### 改进四：采用反向代理加速核心页面

在 Offer 集群前部署 Aquid 反向代理集群

![1611217205063](ArchitectureAdvanced.assets/1611217205063.png)



#### 改进五：海量数据的透明垂直切分

XXXX 性能优化领域立项中

![1611217268442](ArchitectureAdvanced.assets/1611217268442.png)



### 高并发营销活动

#### 场景

我们公司最近业务系统要做一个活动，在我们APP上要做一个比赛，活动时间大概2个小时，同时会有80W的用户同时在线，也就是说这些用户会集中在这两个小时登录、和访问APP首页其他功能。



#### 问题

因为我没有经历过这个级别的在线用户系统，所以想请教一下这两个小时有80W用户活跃的情况会有哪些问题需要考虑，还有这种活跃的程度的系统需要支撑的并发、带宽、服务器集群节点怎么去估算。



#### 现阶段系统情况

1、项目结构：nginx =》网关=》具体服务
2、做了服务的拆分，但是基本上都还是两个节点的集群。
3、数据库：1主2从，还没做读写分离。
4、做了部分redis缓存，redis单节点。
5、部分业务用了队列削峰，ActiveMQ单节点。



#### 我现在的思路

1、读写分离：数据库方面，先把读写分离做了。
2、缓存、异步：因为活动阶段必须要经过的流程是登录、首页、资讯、应用这些模块，所以这些流程内查询的请求全部走缓存，插入的请求全部异步处理。
3、降级：准备把请求的URL进行等级分类，活动的时候后台配置允许重要等级的URL进入应用，非重要的直接拦截（准备在网关里做拦截）
4、限流：在应用里加限流策略。



#### 我的疑问

1、因为没有这方面的经验，想知道用什么方式去估算80W用户同时活跃的并发量、然后估算对应的服务器带宽可能需要多少，支撑这个级别的并发请求应用服务器需要几个集群的节点（比如说网关服务器、用户登录的服务器）。
2、缓存redis、MQ都是单节点能不能抗住这个量级的流量。
3、还有其他我可能都没想到的问题，希望老师提醒下。



#### 解答

先具体沟通这个项目的技术指标，做出响应的判断。





### 宅米网性能优化实践

参考：[宅米网性能优化实践](Data/宅米网性能优化实践.pdf)



### 网购秒杀系统架构设计案例分析

参考：[网购秒杀系统架构设计案例分析](Data/网购秒杀系统架构设计案例分析.pdf)



### HiMeter-Performance Analysis Framework for big Data

参考：[HiMeter-Performance Analysis Framework for big Data](Data/HiMeter-Performance Analysis Framework for big Data.pdf)



### 基于akka开发的大数据集群性能监控与优化系统Dew

参见：[基于akka开发的大数据集群性能监控与优化系统Dew](Data/基于akka开发的大数据集群性能监控与优化系统Dew.pdf)

网址：https://github.com/zhihuili/Dew



## 微服务架构

### 阿里早期微服务架构重构

#### 巨无霸应用系统模块

![1611232197318](ArchitectureAdvanced.assets/1611232197318.png)



#### 巨无霸应用系统带来的问题

编译、部署困难:

> 对于网站开发工程师而言,打包构建一个巨型应用是一件痛苦的事情。  
>
> 也许只是修改了一行代码,输入 build命令后抽完一支烟,回来一看,还在 building  又去喝了一杯水,回来一看,还在 building;又去了一次厕所,回来一看,还在 building  好不容易 build结束,一看编译失败,还得重来
>
> 想砸了显示器有木有?

代码分支管理困难:

> 复用的代码模块由多个团队共同维护修改代码 merge的时候总会发生冲突。
>
> 代码 merge  一般在网站发布的时候,和发布等问题互相纠结在一起,顾此失彼,每次发布都要半夜三更。

数据库连接耗尽:

> 巨型的应用、大量的访问,必然需要将这个应用部署在一个大规模的服务器集群上,应用与数据库的连接通常使用数据库连接池,以每个应用10个连接计,一个数百台服务器集群的应用将需要在数据库上创建数千个连接,
>
> 数据库服务器上,每个连接都会占用一些昂贵的系统资源,  以至于数据库缺乏足够的系统资源进行一般的数据操作。

新增业务困难:

> 想要在一个已经如乱麻般系统中增加新业务,维护旧功能,难度可想而知      
>
> 一脚踩进去,发现全都是雷,什么都不敢碰。许多新工程师来公司半年了,还是不能接手业务,因为不知道水有多深。  
>
> 于是就出现这种怪现象: 熟悉网站产品的“老人”忙得要死,加班加点干活;不熟悉网站产品的新人一帮忙就出乱,跟着加班加点;    
>
> 整个公司热火朝天,加班加点,却还是经常出故障,新产品迟迟不能上线。

解决方案: 就是拆分,将模块独立部署,降低系统耦合性

> 纵向拆分:将一个大应用拆分为多个小应用,如果新增业务较为独立,那么就直接将其设计部署为一个独立的Web应用系统  
>
> 横向拆分:将复用的业务拆分出来,独立部署微服务,新增业务只需要调用这些微服务即可快速搭建一个应用系统。



#### 拆分后的应用系统

![1611232748048](ArchitectureAdvanced.assets/1611232748048.png)



### 微服务框架

#### Web Service 与企业级分布式服务

服务提供者通过 WSDL (Web服务描述语言, Web Services Description Language)  向注册中心( Service Broker)描述自身提供的服务接口属性,注册中心使用UDDI (Universal Description, Discovery, and Integration,统一描述、发现和集成) 发布服务提供者提供的服务, 服务请求者从注册中心检索到服务信息后,通过SOAP (Simple Object Access Protocol,简单对象访问协议) 和服务提供者通信,使用相关服务。

Web Service虽然有着成熟的技术规范和产品实现,以及在企业应用领域有许多成功的案例,但是也具有一些固有的缺点:                      

- 臃肿的注册与发现机制    
- 低效的XML序列化手段      
- 开销相对较高的HTTP远程通信
- 复杂的部署与维护手段

这些问题导致 Web Service难以满足大型网站对系统高性能、高可用、易部署、易维护  的要求。

![1611232804578](ArchitectureAdvanced.assets/1611232804578.png)



#### 微服务框架需求

对于大型互联网系统，除了Web Service 所规范的服务注册与发现，服务调用等标准功能，还需要微服务框架能够支持。

失效转移（Fail Over)：

- 对于大型网站的微服务而言，即使是很少访问的简单服务，也需要集群部署，同时微服务框架还需要支持服务提供者的失效转移机制，以实现服务高可用。

负载均衡：

- 对于集群部署的服务提供者，服务请求者可以使用加权轮询等手段访问，使服务提供者集群实现负载均衡。

高效的远程通信：

- 对于大型网站，核心服务每天的调用次数会达到数以亿计，如果没有高效的远程通信手段，服务调用可能会成为整个系统性能的瓶颈。

对应用最少侵入：

- 网站技术是为业务服务的，是否使用微服务需要根据业务发展规划，微服务也需要渐进式的演化，
- 甚至会出现反复，即使用了微服务后又退回到集中式部署，微服务框架需要支持这种渐进式演化和反复。
- 当然服务模块本身需要支持可集中式部署，也可分布式部署。

版本管理：

- 为了应对快速变化的需求，服务版本升级不可避免，如果仅仅是服务实现升级，那么这种升级对服务请求者而言是透明的，无需关注。
- 但是如果服务的访问接口发生变化，就需要服务请求者和服务提供者同时升级才不会导致服务调用失败。
- 企业应用系统可以申请停机维护，同时升级接口，而网站服务不可能中断，需要服务提供者先升级接口，并同时提供历史版本的服务供请求者调用，当请求者访问接口升级后才可以关闭历史版本服务。





#### 微服务框架（Dubbo）架构

- 服务消费者服务器
- 服务提供者服务器
- 服务注册中心

![1611233460142](ArchitectureAdvanced.assets/1611233460142.png)



#### Service Mesh 服务网格

Service Mesh 是一个基础设施层，用于处理服务间的通信，通常变现为一组轻量级网络代理，他们与应用程序部署在一起，而对应用程序透明。

![1611233584399](ArchitectureAdvanced.assets/1611233584399.png)





#### Service Mesh 的 Sidecar 模式

- Sidecar，边车，可以形成网格

![1611233650848](ArchitectureAdvanced.assets/1611233650848.png)

![1611233661565](ArchitectureAdvanced.assets/1611233661565.png)





### 微服务架构实践

#### 微服务架构落地

- 业务先行,先理顺业务边界和依赖,技术是手段而不是目的。        
- 先有独立的模块,后有分布式的服务。        
- 业务耦合严重,逻辑复杂多变的系统进行微服务重构要谨慎。       
- 要搞清楚实施微服务的目的是什么,业务复用?开发边界清晰?分布式集群提升性能?



#### 命令与查询职责隔离（CQRS）

在服务接口层面将查询(读操作)与命令(写操作）隔离，实现服务层的读写分离。

- 更清晰的领域模型  
- 针对读写分别优化,实现更好的性能  
- 查询服务不会修改数据,更好地保护数据

![1611233868161](ArchitectureAdvanced.assets/1611233868161.png)



#### 事件溯源

将用户请求处理过程中的每次状态变化都记录到事件日志中，并按时间序列进行持久化存储。

- 利用事件溯源，可以精确复现任何用户状态，进行复核审计。
- 利用事件溯源，可以有效监控用户状态变化，并在此基础上实现分布式事务。



#### 断路器

当某个服务出现故障,响应延迟或者失败率增加,继续调用这个服务会导致调用者请求阻塞,资源消耗增加,进而出现服务级联失效,这种情况下使用断路器阻断对故障服务 的调用。

断路器三种状态:关闭,打开,半开

![1611233997318](ArchitectureAdvanced.assets/1611233997318.png)



#### 服务重试及调用超时

上游调用者超时时间要大于下游调用者超时时间之和。

![1611234063676](ArchitectureAdvanced.assets/1611234063676.png)



#### 最重要的是需求

- 需求
- 价值
- 原则
- 实践
- 工具

![1611234080047](ArchitectureAdvanced.assets/1611234080047.png)



### RPC 协议实现原理

#### 远程过程调用（RPC）

- client
- server

![1611312752882](ArchitectureAdvanced.assets/1611312752882.png)



#### 通讯协议（Communications Protocol）

通讯协议在电信领域中是指在任何物理介质中允许两个或多个在传输系统中的终端之间传播信息的系统标准,也是指计算机通信或者网络设备的共同语言。        

一个完整的应用层通信协议通常包含两个部分

- 网络通信协议: TCP、UDP    
- 编码传输协议: 二进制、文本、协议头格式



#### 为什么设计私有通讯协议？

充分并有效利用通讯协议里的每个字段，减少冗余数据传输

灵活满足自定义通讯需求，例如CRC校验、Server Fail-fast、自定义序列化器

最大程度满足性能需求：IO模型和线程模型的充分利用



#### 常见的协议模式

| 常见协议 | 定长协议                                                     | 特殊结束符协议                                               | 变长协议（协议头 + 协议体）                                  |
| -------- | ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 特点     | 协议内容长度是固定的，读写性能高                             | 相对于定长协议，使用特殊结束符作为协议内容的分隔符，在数据传输和高效间取一个平衡 | 使用固定长度的协议头记录协议体的特征，例如协议头长度、协议体长度，方便数据处理 |
| 缺点     | 一般来说，应用通讯协议内容长度不固定，自适应能力差，会存在浪费 | 用户数据不能包含特殊结束符，否则可能㐀成通讯紊乱，且需要读取所有数据包后才能进行处理 |                                                              |



#### Dubbo 通讯协议格式

![1611313590010](ArchitectureAdvanced.assets/1611313590010.png)



#### Dubbo 通讯协议程序

- https://github.com/apache/dubbo
- org.apache.dubbo.remoting.exchange.codec.ExchangeCodec

```java
		@Override
    public Object decode(Channel channel, ChannelBuffer buffer) throws IOException {
        int readable = buffer.readableBytes();
        byte[] header = new byte[Math.min(readable, HEADER_LENGTH)];
        buffer.readBytes(header);
        return decode(channel, buffer, readable, header);
    }

    @Override
    protected Object decode(Channel channel, ChannelBuffer buffer, int readable, byte[] header) throws IOException {
        // check magic number.
        if (readable > 0 && header[0] != MAGIC_HIGH
                || readable > 1 && header[1] != MAGIC_LOW) {
            int length = header.length;
            if (header.length < readable) {
                header = Bytes.copyOf(header, readable);
                buffer.readBytes(header, length, readable - length);
            }
            for (int i = 1; i < header.length - 1; i++) {
                if (header[i] == MAGIC_HIGH && header[i + 1] == MAGIC_LOW) {
                    buffer.readerIndex(buffer.readerIndex() - header.length + i);
                    header = Bytes.copyOf(header, i);
                    break;
                }
            }
            return super.decode(channel, buffer, readable, header);
        }
        // check length.
        if (readable < HEADER_LENGTH) {
            return DecodeResult.NEED_MORE_INPUT;
        }

        // get data length.
        int len = Bytes.bytes2int(header, 12);
        checkPayload(channel, len);

        int tt = len + HEADER_LENGTH;
        if (readable < tt) {
            return DecodeResult.NEED_MORE_INPUT;
        }

        // limit input stream.
        ChannelBufferInputStream is = new ChannelBufferInputStream(buffer, len);

        try {
            return decodeBody(channel, is, header);
        } finally {
            if (is.available() > 0) {
                try {
                    if (logger.isWarnEnabled()) {
                        logger.warn("Skip input stream " + is.available());
                    }
                    StreamUtils.skipUnusedStream(is);
                } catch (IOException e) {
                    logger.warn(e.getMessage(), e);
                }
            }
        }
    }
```



#### Dubbo 通讯协议程序 - 解码 Responce 对象

- org.apache.dubbo.rpc.protocol.dubbo.DubboCodec

```java
@Override
protected Object decodeBody(Channel channel, InputStream is, byte[] header) throws IOException {
    byte flag = header[2], proto = (byte) (flag & SERIALIZATION_MASK);
    // get request id.
    long id = Bytes.bytes2long(header, 4);
    if ((flag & FLAG_REQUEST) == 0) {
        // decode response.
        Response res = new Response(id);
        if ((flag & FLAG_EVENT) != 0) {
            res.setEvent(true);
        }
        // get status.
        byte status = header[3];
        res.setStatus(status);
        try {
            if (status == Response.OK) {
                Object data;
                if (res.isEvent()) {
                    ObjectInput in = CodecSupport.deserialize(channel.getUrl(), is, proto);
                    data = decodeEventData(channel, in);
                } else {
                    DecodeableRpcResult result;
                    if (channel.getUrl().getParameter(DECODE_IN_IO_THREAD_KEY, DEFAULT_DECODE_IN_IO_THREAD)) {
                        result = new DecodeableRpcResult(channel, res, is,
                                (Invocation) getRequestData(id), proto);
                        result.decode();
                    } else {
                        result = new DecodeableRpcResult(channel, res,
                                new UnsafeByteArrayInputStream(readMessageData(is)),
                                (Invocation) getRequestData(id), proto);
                    }
                    data = result;
                }
                res.setResult(data);
            } else {
                ObjectInput in = CodecSupport.deserialize(channel.getUrl(), is, proto);
                res.setErrorMessage(in.readUTF());
            }
        } catch (Throwable t) {
            if (log.isWarnEnabled()) {
                log.warn("Decode response failed: " + t.getMessage(), t);
            }
            res.setStatus(Response.CLIENT_ERROR);
            res.setErrorMessage(StringUtils.toString(t));
        }
        return res;
    } else {
        // decode request.
        // ....
    }
```



#### Dubbo 通讯协议程序 - 解码 Request 对象

```java
// decode response.
// ....
} else {
        // decode request.
        Request req = new Request(id);
        req.setVersion(Version.getProtocolVersion());
        req.setTwoWay((flag & FLAG_TWOWAY) != 0);
        if ((flag & FLAG_EVENT) != 0) {
            req.setEvent(true);
        }
        try {
            Object data;
            if (req.isEvent()) {
                ObjectInput in = CodecSupport.deserialize(channel.getUrl(), is, proto);
                data = decodeEventData(channel, in);
            } else {
                DecodeableRpcInvocation inv;
                if (channel.getUrl().getParameter(DECODE_IN_IO_THREAD_KEY, DEFAULT_DECODE_IN_IO_THREAD)) {
                    inv = new DecodeableRpcInvocation(channel, req, is, proto);
                    inv.decode();
                } else {
                    inv = new DecodeableRpcInvocation(channel, req,
                            new UnsafeByteArrayInputStream(readMessageData(is)), proto);
                }
                data = inv;
            }
            req.setData(data);
        } catch (Throwable t) {
            if (log.isWarnEnabled()) {
                log.warn("Decode request failed: " + t.getMessage(), t);
            }
            // bad request
            req.setBroken(true);
            req.setData(t);
        }

        return req;
    }
}
```



#### Dubbo 利用 requestId 避免队头阻塞

- requestld: 请求ID,该字段主要用于异步请求时,保留请求存根使用,便于响应回来时触发回调。
- 另外,在日志打印与问题调试时,也需要该字段。
- org.apache.dubbo.remoting.exchange.support.DefaultFuture

![1611314836450](ArchitectureAdvanced.assets/1611314836450.png)



#### SOFA-RPC 通讯协议（Bolt 协议）

- 请求命令
- 响应命令

![1611314889910](ArchitectureAdvanced.assets/1611314889910.png)

![1611314936777](ArchitectureAdvanced.assets/1611314936777.png)



#### SOFA-RPC 通讯协议程序 

- com.alipay.remoting.rpc.protocol.RpcCommandEncoderV2

```java
/**
 * Encode remoting command into ByteBuf v2.
 * 
 * @author jiangping
 * @version $Id: RpcCommandEncoderV2.java, v 0.1 2017-05-27 PM8:11:27 tao Exp $
 */
public class RpcCommandEncoderV2 implements CommandEncoder {
    /** logger */
    private static final Logger logger = LoggerFactory.getLogger("RpcRemoting");

    /**
     * @see CommandEncoder#encode(ChannelHandlerContext, Serializable, ByteBuf)
     */
    @Override
    public void encode(ChannelHandlerContext ctx, Serializable msg, ByteBuf out) throws Exception {
        try {
            if (msg instanceof RpcCommand) {
                /*
                 * proto: magic code for protocol
                 * ver: version for protocol
                 * type: request/response/request oneway
                 * cmdcode: code for remoting command
                 * ver2:version for remoting command
                 * requestId: id of request
                 * codec: code for codec
                 * switch: function switch
                 * (req)timeout: request timeout.
                 * (resp)respStatus: response status
                 * classLen: length of request or response class name
                 * headerLen: length of header
                 * cotentLen: length of content
                 * className
                 * header
                 * content
                 * crc (optional)
                 */
                int index = out.writerIndex();
                RpcCommand cmd = (RpcCommand) msg;
                out.writeByte(RpcProtocolV2.PROTOCOL_CODE);
                Attribute<Byte> version = ctx.channel().attr(Connection.VERSION);
                byte ver = RpcProtocolV2.PROTOCOL_VERSION_1;
                if (version != null && version.get() != null) {
                    ver = version.get();
                }
                out.writeByte(ver);
                out.writeByte(cmd.getType());
                out.writeShort(((RpcCommand) msg).getCmdCode().value());
                out.writeByte(cmd.getVersion());
                out.writeInt(cmd.getId());
                out.writeByte(cmd.getSerializer());
                out.writeByte(cmd.getProtocolSwitch().toByte());
                if (cmd instanceof RequestCommand) {
                    //timeout
                    out.writeInt(((RequestCommand) cmd).getTimeout());
                }
                if (cmd instanceof ResponseCommand) {
                    //response status
                    ResponseCommand response = (ResponseCommand) cmd;
                    out.writeShort(response.getResponseStatus().getValue());
                }
                out.writeShort(cmd.getClazzLength());
                out.writeShort(cmd.getHeaderLength());
                out.writeInt(cmd.getContentLength());
                if (cmd.getClazzLength() > 0) {
                    out.writeBytes(cmd.getClazz());
                }
                if (cmd.getHeaderLength() > 0) {
                    out.writeBytes(cmd.getHeader());
                }
                if (cmd.getContentLength() > 0) {
                    out.writeBytes(cmd.getContent());
                }
                if (ver == RpcProtocolV2.PROTOCOL_VERSION_2
                    && cmd.getProtocolSwitch().isOn(ProtocolSwitch.CRC_SWITCH_INDEX)) {
                    // compute the crc32 and write to out
                    byte[] frame = new byte[out.readableBytes()];
                    out.getBytes(index, frame);
                    out.writeInt(CrcUtil.crc32(frame));
                }
            } else {
                String warnMsg = "msg type [" + msg.getClass() + "] is not subclass of RpcCommand";
                logger.warn(warnMsg);
            }
        } catch (Exception e) {
            logger.error("Exception caught!", e);
            throw e;
        }
    }
}
```



#### 序列化协议

|          | 优点                    | 缺点                                       |
| -------- | ----------------------- | ------------------------------------------ |
| Kryo     | 速度快，序列化后体积小  | 跨平台支持较为复杂                         |
| Hessian  | 默认支持跨平台          | 较慢                                       |
| Protobuf | 速度快，序列化后体积小  | 需要静态编译                               |
| Java     | Java 原生支持，使用方便 | 速度慢，序列化后体积较大                   |
| FST      | 速度快，序列化后体积小  | 不支持跨平台                               |
| JSON     | 使用方便                | 不同平台的实现性能差别较大，可靠性有待提高 |





### 微服务网关

#### 基于网关的微服务架构

- API Gateway

![1611315418278](ArchitectureAdvanced.assets/1611315418278.png)



#### 网关作用

- 统一接入
- 流量管控与容错
- 协议适配
- 安全防护

![1611315431914](ArchitectureAdvanced.assets/1611315431914.png)



#### 微服务网关

![1611315524986](ArchitectureAdvanced.assets/1611315524986.png)



#### 网关管道技术

网关本身没有什么业务，主要职责是做各种校验与拦截，这些职责可以通过管道技术连接起来。

![1611315615065](ArchitectureAdvanced.assets/1611315615065.png)

实现管道技术的责任链设计模式

![1611315631120](ArchitectureAdvanced.assets/1611315631120.png)



#### Flower 异步网关与异步微服务框架

![1609080524832](ArchitectureAdvanced.assets/1609080524832.png)

利用 Servlet 3 实现异步网关

```java
// com.ly.train.flower.web.spring.FlowerController#doProcess
  protected void doProcess(Object param, HttpServletRequest req) {
    AsyncContext context = null;
    if (req != null) {
      context = req.startAsync();
    }
    this.flowRouter.asyncCallService(param, context);
  }

// com.ly.train.flower.common.core.web.Web
public class Web {
  public Web(AsyncContext context) {
    this.asyncContext = context;
    this.servletRequest = context.getRequest();
    this.servletResponse = context.getResponse();
    servletResponse.setCharacterEncoding(Constant.ENCODING_UTF_8);
    try {
      this.writer = servletResponse.getWriter();
    } catch (IOException e) {
      logger.error("", e);
    }
  }

  public void print(String message) {
    writer.print(message);
  }
```



#### 开放平台网关

- 提供给第三方调用的API
- 可以免费，也可以收费提供服务

API接口：是开放平台暴露给合作者使用的一组API，其形式可以是RESTful、 WebService、RPC等各种形式

协议转换：将各种 API输入转换成内部服务可以识别的形式，并将内部服务的返回封装成API的格式。

安全：除了一般应用需要的身份识别、权限控制等安全手段，开放平台还需要分级的访问带宽限制，保证平台资源被第三方应用公平合理使用，也保护网站内部服务不会被外部应用拖垮。

审计：记录第三方应用的访问情况，并进行监控、计费等。

路由：将开放平台的各种访问路由映射到具体的内部服务。

流程：将一组离散的服务组织成一个上下文相关的新服务，隐藏服务细节，提供统一接口供开发者调用。

![1611316265303](ArchitectureAdvanced.assets/1611316265303.png)



#### 开放授权协议（OAuth 2.0）

![1611316336809](ArchitectureAdvanced.assets/1611316336809.png)



#### 授权码授权

OAuth2.0一共有四种授权方式，分别是授权码、隐式授权、资源所有者密码凭据和客户端凭据。

目前互联网上使用最多也是最安全的的一种方式是授权码方式。

证明用户的凭证 token，叫做令牌。

![1611316376180](ArchitectureAdvanced.assets/1611316376180.png)





### 领域驱动设计

#### 领域模型

##### 为什么需要DDD

很多项目的实际情况                              

- 用户或者产品经理的需求零零散散,不断变更。    
- 工程师在各处代码中寻找可以实现这些需求变更的代码,修修补补。  
- 软件只有需求分析,并没有真正的设计,系统没有一个统一的领域模型维持其内在的逻辑一致性。  
- 功能特性并不是按照领域模型内在的逻辑设计,而是按照各色人等自己的主观想象设计。

项目时间一长,各种困难重重,需求不断延期,线上bug不断,管理者考虑是不是要推倒重来,而程序员则考虑是不是要跑路。



##### 事务脚本

- Controller
- Service
- Dao

![1611316633382](ArchitectureAdvanced.assets/1611316633382.png)



##### 领域模型

![1611316647339](ArchitectureAdvanced.assets/1611316647339.png)



##### 贫血模型 vs 充血模型

由于事务脚本模式中, Service、Dao这些对象只有方法,没有数值成员变量,而方法调用时传递的数值对象,比如 Contract,没有方法(或者只有一些 getter、 setter方法)  , 因此事务脚本又被称作贫血模型。        

领域模型的对象则包含了对象的数据和计算逻辑,比如合同对象,既包含合同数据,也包含合同相关的计算。因此从面向对象的角度看,领域模型才是真正的面向对象。收入确认是和合同强相关的, 是合同对象的一个职责, 那么合同对象就应该提供一个 calculateRecognition方法计算收入。        

领域模型是合并了行为和数据的领域的对象模型。通过领域模型对象的交互完成业务逻辑的实现,也就是说,设计好了领域模型对象,也就设计好了业务逻辑实现。和事务脚本被称作贫血模型相对应的,领域模型也被称为充血模型。



#### DDD 战略设计

##### 领域是什么

领域是一个组织所做的事情以及其包含的一切,通俗地说,就是组织的业务范围和做事方式,也是软件开发的目标范围。        

领域驱动设计就是从领域出发,分析领域内模型及其关系,进而设计软件系统的方法

![1611317066964](ArchitectureAdvanced.assets/1611317066964.png)



##### 子域

领域是一个组织所做的事情以及其包含的一切。这个范围就太大了,不知道该如何下手。  所以通常的做法是把整个领域拆分成多个子域, 比如用户、商品、订单、库存、物流、发票等。        

如何划分子域?    

卖家提现功能是属于用户子域? 订单子域? 财务子域? 还是直接设计一个提现子域?



##### 限界上下文

在一个子域中, 会创建一个概念上的领域边界, 在这个边界中,任何领域对象都只表示特定于该边界内部的确切含义。这样边界便称为限界上下文。

限界上下文和子域具有一对一的关系,用来控制子域的边界。        

通常限界上下文对应一个组件或者一个模块,或者一个微服务。



##### 上下文映射图

不同的界限上下文，也就是不同的子系统或者模块之间会有各种的交互合作。DDD使用上下文映射图来设计这种交互。

![1611317302378](ArchitectureAdvanced.assets/1611317302378.png)



#### DDD 战术设计

##### 实体

领域模型对象也被称为实体,每个实体都是唯一的,具有一个唯一标识,一个订单对象是一个实体,一个产品对象也是一个实体,订单ID或者产品ID是它们的唯一标识。

实体可能会发生变化,比如订单的状态会变化,但是它们的唯一标识不会变化。        

实体设计是DDD的核心所在,首先通过业务分析,识别出实体对象,然后通过相关的业务逻辑设计实体的属性和方法。这里最重要的,是要把握住实体的特征是什么,实体应该承担什么职责,不应该承担什么职责,分析的时候要放在业务场景和界限上下文中,  而不是想当然地认为这样的实体就应该承担这样的角色。



##### 值对象

并不是领域内的对象都应该被设计为实体，DDD推荐尽可能将对象设计为值对象。比如像住址这样的对象就是典型的值对象，也许建在住址上的房子可以被当做一个实体，但是住址仅仅是对房子的一个描述，像这样仅仅用来做度量或描述的对象应该被设计为值对象。

值对象的一个特点是不变性，一个值对象创建以后就不能再改变了。如果地址改变了，那就是一个新地址，而一个订单实体则可能会经历创建、待支付、已支付、代发货、已发货、待签收、待评价等各种变化。



##### 聚合

聚合是一个关联对象的集合,我们将其作为一个单元来处理数据更改。每个集合都有一个根和一个边界。

边界定义了聚合内部的内容。根是聚合中包含的单个特定实体。    

聚合根: 将多个实体和值对象聚合在一起的实体。

![1611320683840](ArchitectureAdvanced.assets/1611320683840.png)



##### DDD 分层架构

领域实体的组合调用和事务控制在应用层。

![1611320707680](ArchitectureAdvanced.assets/1611320707680.png)



##### DDD 六边形架构

领域模型通过应用程序封装成一个相对比较独立的模块, 而不同的外部系统则通过不同的适配器和领域模型交互,比如可以通过HTTP接口访问领域模型,也可以通过 Web Service或者消息队列访问领域模型, 只需要为这些不同的访问接口提供不同的适配器就可以了。

![1611322695037](ArchitectureAdvanced.assets/1611322695037.png)



#### DDD 战略设计与战术设计

领域、子域、界限上下文、上下文映射图，这些是DDD的战略设计。

实体、值对象、聚合、CQRS、事件溯源，这些是DDD战术设计。

通过战略设计，划分模块和服务的边界及依赖关系，对微服务架构的设计至关重要。



#### 我经历的一个 DDD 重构实践过程

当前系统设计与问题汇总讨论      

- 架构与代码混乱,需求迭代困难,部署麻烦,bug率逐渐升高

针对问题分析具体原因        

- 子系统A太庞大,模块B和C职责不清,业务理解不一致

重新梳理业务规则和边界,明确业务术语      

- DDD战略设计,领域建模

技术框架选型与落地方案验证      

- DDD战术设计,样例代码

任务分解与持续重构

- 在不影响业务开发的前提下,按照战略与战术设计,将重构开发和业务迭代有机融合

如果一个工作多年的程序员，还是仅仅写一些跟他工作第一年差不多的CRUD代码。那么他迟早会遇到自己的职业危机。公司必然愿意用更年轻、更努力，当然也更低薪水的程序员来代替他。至于学习新技术的能力，其实多年工作经验也并没有太多帮助，有时候也许还是劣势。

资深程序员真正有优势的是他在一个业务领域的多年积淀，对业务领域有更深刻的理解和认知。那么如何将这些业务沉淀和理解反映到工作中，体现在代码中呢？实践DDD是一个不错的方式。

如果一个人有多年的领域经验，那么必然对领域模型设计有更深刻的认识，把握好领域模型在不断的需求变更中的演进，使系统维持更好的活力，并因此体现自己真正的价值。





### 组件设计原则

#### 软件组件起源

在没有变成语言的时候就已经有了软件组件

![1611322998912](ArchitectureAdvanced.assets/1611322998912.png)



#### 软件的复杂度和它的规模成指数关系

一个复杂度为100的软件系统,如果能拆分成两个互不相关、同等规模的子系统,那么每个子系统的复杂度应该是25,而不是50。

软件开发这个行业很久之前就形成了一个共识,应该将复杂的软件系统进行拆分,拆成多个更低复杂度的子系统,子系统还可以 继续拆分成更小粒度的组件。也就是说,软件需要进行模块化、组件化设计。



#### 组件内聚原则

组件内聚原则主要讨论哪些类应该聚合在同一个组件中,以便组件既能提供相对完整的功能,又不至于太过庞大。        

- 复用发布等同原则    
- 共同封闭原则    
- 共同复用原则



##### 复用发布等同原则

复用发布等同原则是说,软件复用的最小粒度应该等同于其发布的最小粒度。也就是说如果你希望别人以怎样的粒度复用你的软件,你就应该以怎样的粒度发布你的软件。这其实就是组件的定义了,组件是软件复用和发布的最小粒度软件单元。这个粒度既是复用的粒度,也是发布的粒度。

版本号约定建议

- 版本号格式:主版本号.次版本号修订号。比如1.3.12, 在这个版本号中,主版本号是1,  次版本号是3,修订号是12。  
- 主版本号升级,表示组件发生了不向前兼容的重大修订;    
- 次版本号升级,表示组件进行了重要的功能修订或者bug修复,但是组件是向前兼容的;  
- 修订号升级,表示组件进行了不重要的功能修订或者bug修复。



##### 共同封闭原则

共同封闭原则是说,我们应该将那些会同时修改,并且为了相同目的而修改的类放到同一个组件中。而将不会同时修改,并且不会为了相同目的而修改的类放到不同的组件中。        

组件的目的虽然是为了复用,然而开发中常常引发问题的,恰恰在于组件本身的可维护性。如果组件在自己的生命周期中必须经历各种变更,那么最好不要涉及其他组件,相关的变更都在同一个组件中。这样,当变更发生的时候,只需要重新发布这个组件就可以了,而不是一大堆组件都受到牵连。



##### 共同复用原则

共同复用原则是说,不要强迫一个组件的用户依赖他们不需要的东西。        

这个原则一方面是说,我们应该将互相依赖,共同复用的类放在一个组件中。比如说，一个数据结构容器组件,提供数组、Hash表等各种数据结构容器,那么对数据结构遍历的类、排序的类也应该放在这个组件中,以使这个组件中的类共同对外提供服务。    

另一方面,这个原则也说明,如果不是被共同依赖的类,就不应该放在同一个组件中。  如果不被依赖的类发生变更,就会引起组件变更,进而引起使用组件的程序发生变更。  这样就会导致组件的使用者产生不必要的困扰,甚至讨厌使用这样的组件,也造成了组件复用的困难。



#### 组件耦合原则

组件内聚原则讨论的是组件应该包含哪些功能和类,而组件耦合原则讨论组件之间的耦合关系应该如何设计。            

- 无循环依赖原则    
- 稳定依赖原则    
- 稳定抽象原则



##### 无循环依赖原则

无循环依赖原则说，组件依赖关系中不应该出现环。如果组件A依赖组件B，组件B依赖组件C，组件C又依赖组件A，就形成了循环依赖。

很多时候，循环依赖是在组件的变更过程中逐渐形成的，组件A版本1.0依赖组件B版本1.0，后来组件B升级到1.1，升级的某个功能依赖组件A的1.0版本，于是形成了循环依赖。

如果组件设计的边界不清晰，组件开发设计缺乏评审，开发者只关注自己开发的组件，整个项目对组件依赖管理没有统一的规则，很有可能出现循环依赖。



##### 稳定依赖原则

稳定依赖原则说,组件依赖关系必须指向更稳定的方向。很少有变更的组件是稳定的,  也就是说,经常变更的组件是不稳定的。根据稳定依赖原则,不稳定的组件应该依赖稳  定的组件,而不是反过来。        

反过来说,如果一个组件被更多组件依赖,那么它需要相对是稳定的,因为想要变更一个被很多组件依赖的组件,本身就是一件困难的事。相对应的,如果一个组件依赖了很多的组件,那么它相对也是不稳定的,因为它依赖的任何组件变更,都可能导致自己的变更。      

稳定依赖原则通俗地说就是,组件不应该依赖一个比自己还不稳定的组件。



##### 稳定抽象原则

稳定抽象原则说,一个组件的抽象化程度应该与其稳定性程度一致。也就是说,一个稳定的组件应该是抽象的,而不稳定的组件应该是具体的。        

这个原则对具体开发的指导意义就是:如果你设计的组件是具体的、不稳定的,那么可以为这个组件对外提供服务的类设计一组接口,并把这组接口封装在一个专门的组件中,  那么这个组件相对就比较抽象、稳定。        

Java中的JDBC就是这样一个例子,我们开发应用程序的时候只需要使用JDBC的接口编程就可以了。而发布应用的时候,我们指定具体的实现组件,可以是 MySQL实现的JDBC组件,也可以是 Oracle实现的JDBC组件。



#### 组件的边界与依赖关系，不仅仅是技术问题

组件的边界与依赖关系划分，不仅需要考虑技术问题，也要考虑业务场景问题。易变与稳定，依赖与被依赖，都需要放在业务场景中去考察。

有的时候，甚至不只是技术和业务的问题，还需要考虑人的问题，在一个复杂的组织中，组件的依赖与设计需要考虑人的因素，如果组件的功能划分涉及到部门的职责边界，甚至会和公司内的政治关联起来。





### 逻辑思维DDD战略建模-在重构业务系统时的实践

- [逻辑思维DDD战略建模-在重构业务系统时的实践](Data/逻辑思维DDD战略建模-在重构业务系统时的实践.pdf)



### 从应用到中台-业务平台的演进

- [从应用到中台-业务平台的演进](Data/从应用到中台-业务平台的演进.pdf)





### 作业与实践

- 关于微服务架构（中台架构，领域驱动设计，组件设计原则），你有什么样的思考和认识？
- 根据微服务框架 Dubbo 的架构图，画出 Dubbo 进行一次微服务调用的时序图。

![1611233460142](ArchitectureAdvanced.assets/1611233460142.png)







## 高可用系统架构



### 安全架构

#### XSS 攻击

##### XSS 攻击-用户侧

![1611410517180](ArchitectureAdvanced.assets/1611410517180.png)



##### XSS 攻击-服务器侧

![1611410542519](ArchitectureAdvanced.assets/1611410542519.png)



##### XSS 攻击防御手段

消毒：

- XSS攻击者一般都是通过在请求中嵌入恶意脚本达到攻击目的，这些脚本是一般用户输入中不使用的，如果进行过滤和消毒处理，即对某些 HTML危险字符转义，
- 如">"转义为"&gt"、“<”转义为“&lt”等，就可以防止大部分攻击。
- 为了避免对不必要的内容错误转义，如“3<5”中的“<”，需要进行文本匹配后再转义，如"<img src=”这样的上下文中"<"才转义。
- 事实上，消毒几乎是所有网站最必备的 XSS防攻击手段。



#### SQL 注入攻击

##### SQL 注入攻击

![1611410567064](ArchitectureAdvanced.assets/1611410567064.png)



##### 获取数据库表结构信息的手段

开源：如果网站采用开源软件搭建，如用 Discuz！搭建论坛网站，那么网站数据库结构就是公开的，攻击者可以直接获得。

错误回显：如果网站开启错误回显，攻击者故意构造非法参数，服务端异常信息会输出到浏览器端，为攻击猜测数据库表结构提供了便利。

盲注：网站关闭错误回显，攻击者根据页面变化情况判断 SQL语句的执行情况，据此猜测数据库表结构，此种方式攻击难度较大。



##### 注入攻击防御手段

消毒：

- 和防 XSS 攻击一样，请求参数消毒是一种比较简单粗暴又有效的手段。通过正则匹配，过滤请求数据中可能注入的SQL文。
- 如："drop table"、"\b(?:update\b.\*?\bsetdelete\b\W*?\bfrom)\b" 等。

SQL预编译参数绑定:

- 使用预编译手段,绑定参数是最好的防SQL注入方法。
- 目前许多数据访问层框架,如 myBatis, Hibernate 等,都实现SQL预编译和参数绑定,攻击者的恶意SQL会被当做SQL的参数,而不是SQL命令被执行。





#### CSRF 攻击

##### CSRF 攻击

![1611410588386](ArchitectureAdvanced.assets/1611410588386.png)



##### CSRF 攻击防御手段

表单 Token:

- CSRF是一个伪造用户请求的操作,所以需要构造用户请求的所有参数才可以。
- 表单 Token 就是阻止攻击者获得所有请求参数的可能,在页面表单中增加一个随机数 Token,每次请求的 Token都不相同,请求提交后检查 Token的值是否正确以确定请求提交者是否合法。

验证码：

- 相对说来，验证码则更加简单有效，即请求提交时，需要用户输入验证码，以避免在用户不知情的情况下被攻击者伪造请求。
- 但是输入验证码是一个糟糕的用户体验，所以必要的时候才使用，如支付交易等关键页面。

referer check : 

- http请求头的 referer域中记录着请求来源,可通过检查请求来源,  验证其是否合法。
- 但是该方法有一定局限性， referer也并不一定总能得到。



#### 其他需要关注的攻击和漏洞        

Error Code:

- 也称作错误回显,许多Web服务器默认是打开异常信息输出的,即服务器端未处理的异常堆栈信息会直接输出到客户端浏览器,这种方式虽然对程序调试和错误  报告有好处,但同时也给黑客造成可乘之机。
- 通过故意制造非法输入,使系统运行时出错,获得异常信息,从而寻找系统漏洞进行攻击。
- 防御手段也很简单,通过配置Web服务器参数,跳转500页面(HTTP响应码500表示服务器内部错误)到专门的错误页面即可,这个功能Web应用常用的MVC框架也可以做到。

HTML注释:

- 为了程序调试方便或其他不恰当的原因,有的时候程序开发人员会在PHP 、JSP等服务器页面程序中使用HTML注释语法进行程序注释,这些HTML注释就会显  示在客户端浏览器,给黑客造成攻击便利。
- 程序最终发布前需要进行代码 revlew或自动扫描,避免HTML注释漏洞。

文件上传:

- 一般网站都会有文件上传功能,设置头像、分享视频、上传附件等。
- 如果上传的是可执行的程序,并通过该程序获得服务器端命令执行能力,那么攻击者几乎可以在服务器上为所欲为,并以此为跳板攻击集群环境的其他机器。
- 最有效的防御手段是设置上传文件白名单,只允许上传可靠的文件类型。
- 此外还可以修改文件名、使用专门的存储等手段,保护服务器免受上传文件攻击。

路径遍历:

- 攻击者在请求的URL中使用相对路径,遍历系统未开放的目录和文件。
- 防御方法主要是将 JavaScript、CSS等资源文件独立服务器、独立域名,其他文件不使用静态URL访问,动态参数不包含文件路径信息。



#### Web 应用防火墙

##### Web 应用防火墙

- 将应用防火墙，设置为一个单独的组件

![1611410613838](ArchitectureAdvanced.assets/1611410613838.png)



##### 开源Web应用防火墙 ModSecurity        

ModSecurity 是一个开源的Web应用防火墙,探测攻击并保护Web应用程序,既可以嵌入到Web应用服务器中,也可以作为一个独立的应用程序启动。 ModSecurity最早只是 Apache的一个模块,现在已经有Java、.net多个版本,并支持 Nginx        

ModSecurity 采用处理逻辑与规则集合分离的架构模式。处理逻辑负责请求和响应的拦截过滤,规则加载执行等功能。而规则集合则负责对具体的攻击的规则定义、模式识别防御策略等功能。处理逻辑比较稳定,规则集合需要不断针对漏洞进行升级,这是一种可扩展的架构设计。



##### 网站安全漏洞扫描        

和电脑安全漏洞扫描一样,网站也需要安全漏洞扫描。        

网站安全漏洞扫描工具是根据内置规则,模拟黑客攻击行为,用以发现网站安全漏洞的工具。许多大型网站的安全团队都有自己开发的漏洞扫描工具,不定期的对网站的服务器进行扫描,查漏补缺。        

目前市场上也有很多商用的网站安全漏洞扫描平台。



#### 信息加密技术及密钥安全管理        

2011年12月被曝的CSDN密码泄露事故中,网站安全措施不力,导致用户数据库被黑客“拖库”并不稀奇,令人错愕的是数据库中的用户密码居然是明文保存,导致密码泄  露,成为地下黑市交易的商品。        

通常,为了保护网站的敏感数据,应用需要对这些信息进行加密处理,信息加密技术可分为三类:单项散列加密,对称加密,非对称加密。



##### 单项散列加密

- 保证加密效果好，需要加盐
- 有彩虹表，进行明文与密文的破译

![1611410630969](ArchitectureAdvanced.assets/1611410630969.png)

![1611410651179](ArchitectureAdvanced.assets/1611410651179.png)



##### 对称加密

![1611410665185](ArchitectureAdvanced.assets/1611410665185.png)



##### 非对称加密

![1611410686992](ArchitectureAdvanced.assets/1611410686992.png)



##### 密钥安全管理与加解密服务系统架构

- 应用服务器只能调用密钥服务器的接口
- 对于密钥的管理，需要多方协作，才可以实现
- 防止内部人作弊

![1611410707184](ArchitectureAdvanced.assets/1611410707184.png)



#### 反垃圾邮件

![1611410723509](ArchitectureAdvanced.assets/1611410723509.png)



##### 贝叶斯分类算法

贝叶斯算法解决概率论中的一个典型问题：一号箱子放有红色球和白色球各20个，二号箱子放有白色球10个，红色球30个，现在随机挑选一个箱子，取出来一个球的颜色是红色的，请问这个球来自一号箱子的概率是多少。

利用贝叶斯算法进行垃圾邮件的识别基于同样原理，根据已分类的样本信息获得一组特征值的概率（如“茶叶”这个词出现在垃圾邮件中的概率和非垃圾邮件中的概率），就得到分类模型，然后对待处理信息提取特征值，结合分类模型，判断其分类。

贝叶斯公式

![1611410738268](ArchitectureAdvanced.assets/1611410738268.png)

![1611410768232](ArchitectureAdvanced.assets/1611410768232.png)



##### 布隆过滤器黑名单

- 通过一个小内存，进行大量数据是否存在的判断
- 可能会误判，但是一定可以判断出错误的对象
- 将邮件，使用8种算法，计算得到8位，分别在16G x 8 的整个位置中纪录1，只有存放过，就可以验证出来是否存在

![1611410785966](ArchitectureAdvanced.assets/1611410785966.png)



#### 电子商务风险控制

电子商务网站在给人们代理购物交易的极大便利的同时,也将风险带给了对网络安全一无所知的人们。

由于买卖双方的信息不对等,交易本来就存在风险,而当交易在网上发生的时候,买卖双方彼此一无所知,交易风险也就更加难以控制。如果一个电商网站骗子横行,诚信的交易者屡屡被骗,那么网站就到了最危险的时候,可以说,交易安全是电子商务网站的底线。

电子商务具有多种形式，B2B，B2C，C2C每种交易的场景都不相同，风险也各有特点，大致可分为以下几种：

- 账户风险：包括账户被黑客盗用，恶意注册账号等几种情形。
- 买家风险：买家恶意下单占用库存进行不正当竞争；黄牛利用促销抢购低价商品；此外还有良品拒收，欺诈退款以及常见于B2B交易的虚假询盘等。
- 卖家风险：不良卖家进行恶意欺诈的行为，例如货不对板，虚假发货，炒作信用等，此外还有发布违禁商品、侵权产品等。
- 交易风险：信用卡盗刷，支付欺诈，洗钱套现等。

大型电商网站都配备有专门的风控团队进行风险控制, 风控的手段也包括自动和人工两种方式。

机器自动识别为高风险的交易和信息会发送给风控审核人员进行人工审核,机器自动风控的技术和方法也不断通过人工发现的新风险类型进行逐步完善。    

机器自动风控的技术手段主要有规则引擎和机器学习



##### 规则引擎

当交易的某些指标满足一定条件的时候,就会被认为具有高风险的欺诈可能性。  

比如:                          

- 用户来自欺诈高发地区;
- 交易金额超过某个数值;  
- 和上次登录的地址距离差距很大;  
- 用户登录地与收货地不符;  
- 用户第一次交易;
- ......

大型网站在运营过程中,结合业界的最新发现,会总结出数以千计的此类高风险交易规则。

一种方案是在业务逻辑中通过编程方式使用 if...else.. 代码实现这些规则,可以想见,这些代码会非常庞大,而且由于运营过程中不断发现新的交易风险类型,需要不断调整规则,代码也需要不断修改...

![1611410810691](ArchitectureAdvanced.assets/1611410810691.png)





##### 机器学习

规则引擎虽然技术简单,但是随着规则的逐渐增加,出现规则冲突,难以维护等情况,  而且规则越多,性能也越差。大型互联网应用更倾向于使用机器学习模型进行风控。

![1611410834429](ArchitectureAdvanced.assets/1611410834429.png)





### 高可用系统的度量

#### 可用性指标

业界通常用多少个9来衡量网站的可用性，如 QQ的可用性是4个9，即 QQ服务99.99%可用，这意味着QQ服务要保证其在所有运行时间中，只有0.01%的时间不可用，也就是一年中大约53分钟不可用。

网站年度可用性指标 =（1-网站不可用时间/年度总时间）x 100%
网站不可用时间（故障时间）= 故障修复时间点 - 故障发现（报告）时间点

对可用性的定性描述，两个9是基本可用，年度停机时间小于88小时；3个9较高可用，年度停机时间小于9小时；4个9是具有自动恢复能力的高可用，年度停机时间小于53分钟；5个9是极高可用性，年度停机时间小于5分钟。

由于可用性影响因素很多，对于网站整体而言，达到4个9，乃至5个9的可用性，除了过硬的技术、大量的设备资金投入和工程师的责任心，还要有个好运气。



#### 故障分管理

![1611497453895](ArchitectureAdvanced.assets/1611497453895.png)



#### 故障处理流程及考核

![1611497474153](ArchitectureAdvanced.assets/1611497474153.png)



#### 引起故障的原因

- 硬件故障
- 软件 bug
- 系统发布
- 并发压力
- 网络攻击
- 外部灾害





### 高可用系统的架构

#### 解耦

- 高内聚，低耦合的组件设计原则
- 面向对象基本设计原则
- 面向对象设计模式
- 领域驱动设计建模



#### 隔离

- 业务与子系统隔离
- 微服务与中台架构
- 生产者消费者隔离
- 虚拟机与容器隔离



#### 异步

- 多线程编程
- 反应式编程
- 异步通信网络编程
- 事件驱动异步架构

![1611498103696](ArchitectureAdvanced.assets/1611498103696.png)



#### 备份

- 集群设计
- 数据库复制
  - CAP 原理

![1611498157820](ArchitectureAdvanced.assets/1611498157820.png)



#### Failover（失效转移）

数据库主主失效转移

负载均衡失效转移

如何确认失效，需要转移？
设计无状态的服务。



#### 幂等

应用调用服务失败后,会将调用请求重新发送到其他服务器,但是这个失败可能是虚假的失败。

比如服务已经处理成功,但是因为网络故障应用没有收到响应,这时应用重新提交请求就导致服务重复调用,如果这个服务是一个转账操作,就会产生严重后果。    

服务重复调用有时候是无法避免的,必须保证服务重复调用和调用一次产生的结果相同即服务具有幂等性。

有些服务天然具有幂等性,比如将用户性别设置为男性,不管设置多少次,结果都一样。但是对于交易等操作,问题就会比较复杂,需要通过交易编号等信息进行服务调用有效性校验,只有有效的操作才继续执行。



#### 事务补偿

传统事务的ACID          

- 原子性( Atomicity)、一致性( Consistency)、隔离性( Isolation,又称独立性)、持久性(Durability)

分布式事务的BASE            

- 基本可用( Basic Availability)、软状态（Soft-state)、最终一致性( Eventual consistency)

事务补偿: 通过执行业务逻辑逆操作,使事务回滚到事务前状态



#### 重试

远程服务可能会由于线程阻塞、垃圾回收或者网络抖动，而无法及时返还响应，调用者可以通过重试的方式，修复单词调用的故障。

- 上游调用者超时时间要大于下游调用者超时时间之和。

![1611234063676](ArchitectureAdvanced.assets/1611234063676.png)



#### 熔断

当某个服务出现故障,响应延迟或者失败率增加,继续调用这个服务会导致调用者请求阻塞,资源消耗增加,进而出现服务级联失效,这种情况下使用断路器阻断对故障服务的调用。

- 断路器三种状态：关闭，打开，半开
- Spring Cloud 断路器实现： Hystrix

![1611498796556](ArchitectureAdvanced.assets/1611498796556.png)



#### 限流

在高并发场景下,如果系统的访问量超过了系统的承受能力,可以通过限流对系统进行保护。

限流是指对进入系统的用户请求进行流量限制,如果访问量超过了系统的最大处理能力,就会丢弃一部分的用户请求,保证整个系统可用,保证大部分用户是可以访问  系统的。

这样虽然有一部分用户的请求被丢弃,产生了部分不可用,但还是好过整个系统崩溃,所有的用户都不可用要好。        

限流的几种算法

- 计数器算法(固定窗口,滑动窗口)    
- 令牌桶算法
- 漏桶算法

计数器（固定窗口）算法

- 使用计数器在周期内累加访问次数，当达到设定的限流值时，触发限流策略。下一个周期开始时，进行清零，重新计数。
- 固定窗口算法的临界点问题: 假设1min 内服务器的负载能力为100,因此一个周期的访问量限制在100, 然而在第一个周期的最后5秒和下一个周期的开始5秒时间段内分别涌入100的访问量,虽然没有超过每个周期的限制量,但是整体上10秒内已达到200的访问量,已远远超过服务器的负载能力

![1611498998890](ArchitectureAdvanced.assets/1611498998890.png)

计数器(滑动窗口)算法  

- 将时间周期分为N个小周期,分别记录每个小周期内访问次数,并且根据时间滑动删除过期的小周期
- 假设时间周期为1min,将1min再分为2个小周期,统计每个小周期的访问数量,则可以看到,第一个时间周期内,访问数量为75,第二个时间周期内,访问数量为100,超过100的访问则被限流掉了

![1611499104821](ArchitectureAdvanced.assets/1611499104821.png)

令牌桶算法    

- 以固定的速度向令牌桶中增加令牌,直到令牌桶满,请求到达时向令牌桶请求令牌,如获取到令牌则通过请求,否则触发限流策略

![1611499177447](ArchitectureAdvanced.assets/1611499177447.png)

漏桶算法    

- 访问请求到达时直接放入漏桶,如当前容量已达到限流值,则进行丢弃。漏桶以固定的速率进行释放访问请求,直到漏桶为空。

![1611499259636](ArchitectureAdvanced.assets/1611499259636.png)



#### 自适应限流

没有提前的人工评估，便没有提前的评估过时与人的评估疏漏/错误！

- 实时自动评估QPS
- 业务流量的不确定性与技术方案的自适应性天生一对！

![1611499344463](ArchitectureAdvanced.assets/1611499344463.png)





#### 降级

有一些系统功能是非核心的，但是它也给系统产生了非常大的压力，比如说在电商系统中有确认收货这个功能，即便我们不去确认收货，系统也会超时自动确认收货。

但实际上确认收货这个操作是一个非常重的操作，因为它会对数据库产生很大的压力：它要进行更改订单状态，完成支付确认，并进行评价等一系列操作。如果在系统高并发的时候去完成这些操作，那么会对系统雪上加霜，使系统的处理能力更加恶化。

解决办法就是在系统高并发的时候，比如说像淘宝双11的时候，当天可能整天系统都处于一种极限的高并发访问压力之下，这时候就可以将确认收货、评价这些非核心的功能关闭，将宝贵的系统资源留下来，给正在购物的人，让他们去完成交易。



#### 异地多活

如果整个数据中心都不可用，比如说数据中心所在城市遭遇了地震，机房遭遇了火灾或者停电，这样的话，不管我们的设计和系统多么的高可用，系统依然是不可用的。

为了解决这个问题，同时也为了提高系统的处理能力和改善用户体验，很多大型互联网应用都采用了异地多活的多机房架构策略，也就是说将数据中心分布在多个不同地点的机房里，这些机房都可以对外提供服务，用户可以连接任何一个机房进行访问，这样每个机房都可以提供完整的系统服务，即使某一个机房不可使用，系统也不会宕机，依然保持可用。

异地多活的难点是数据一致。





### 高可用系统的运维

#### 发布       

网站需要保证7×24高可用运行,同时网站又需要不断的发布新功能吸引用户以保证在激烈的市场竞争中获得成功。许多大型网站每周都需要发布一到两次,而中小型网站则更加频繁,一些处于快速发展期的网站甚至每天发布十几次。    

不管发布的新功能是修改了一个按钮的布局还是增加一个核心交易功能,都需要在服务器上关闭原有的应用,然后重新部署启动新的应用,整个过程还要求不影响用户的使用。这相当于是要求给飞行中的飞机换个引擎,既不能让飞机有剧烈的晃动,也不能让飞机降落,更不能让飞机坠毁。    

既然网站的发布过程事实上和服务器宕机效果相当,那么就可以用服务器宕机的高可用方案来应对网站的发布。所以设计一个网站的高可用架构的时候,需要考虑的服务器宕机概率不是物理上的每年一两次,而是事实上的每周一两次。也许你认为这个应用不重要,重启也非常快,用户可以忍受每年一到两次的宕机故障,因而不需要复杂的高可用设计。事实上,由于应用的不断发布,用户需要面对的是每周一到两次的宕机故障。用户哭了。

![1611499689178](ArchitectureAdvanced.assets/1611499689178.png)



#### 自动化测试

代码在发布到线上服务器之前需要进行严格的测试。即使每次发布的新功能都是在原有系统功能上的小幅增加,但是为了保证系统没有引入未预料的BUG,网站测试还是需要对整个网站功能进行全面的回归测试。此外还需要测试各种浏览器的兼容性,在发布频  繁的网站应用中,如果使用人工来进行,成本和时间都难以承受。 

目前大部分网站都采用Web自动化测试技术,使用自动测试工具或脚本完成测试。比较流行的Web自动化测试工具是 ThoughtWorks开发的 Selenium。 Selenium运行在浏览器中,模拟用户操作进行测试,因此 Selenium可以同时完成Web功能测试和浏览器兼容测试。



#### 手工测试和自动化测试的总体成本

雇个测试工程师，测试工程师在每次发布前进行应用测试。开始的时候，这种成本是非常小的，但是增长却很快。每次开发新功能都需要对新功能进行测试，而前面已经发布的各种功能也需要进行测试，确保开发新功能不会破坏现有的产品功能。也就是说，每次发布的测试成本都比前一次发布的测试成本更高（测试效率随时间推移逐步降低）。这也会使软件的版本的发布周期逐渐变长，因为随着软件规模的增长，测试需要越来越长的时间。

自动化测试需要一些前置投资，你需要安装自动化测试工具，部署持续集成服务器，但是后续投入却是相对便宜的。一旦完成初始安装，只需要为新功能创建测试就可以了，测试已经存在的功能几乎不需要花费任何成本。随着时间的推移，测试会变得越来越高效，每一次发布测试，已测试的代码和待测试的代码之比都在增加。最终，会到达一个平衡点，然后自动化测试的总体成本会低于手工测试的成本。

![1611499944021](ArchitectureAdvanced.assets/1611499944021.png)



#### 自动化部署

![1611500078878](ArchitectureAdvanced.assets/1611500078878.png)



#### 持续部署三步走

持续集成

- 允许工程师随时向公共分支提交代码，并立即进行自动化测试

持续交付

- 除了跑单元测试及软件打包，持续交付机制会将软件部署到各种测试环境中

持续部署

- 代码在没有人工干预的情况下被测试，构建，部署并推送到生产环境



#### 持续部署流程

![1611500248877](ArchitectureAdvanced.assets/1611500248877.png)



#### 预发布验证

即使是经过严格的测试，软件部署到线上服务器之后还是经常会出现各种问题，甚至根本无法启动服务器。主要原因是测试环境和线上环境并不相同，特别是应用需要依赖的其他服务，如数据库，缓存、公用业务服务等，以及一些第三方服务，如电信短信网关、银行网银接口等。也许是接口变化导致的通信失败；也许是配置错误导致连接失败；也许依赖的服务在线上环境还没有准备好；这些问题都有可能导致应用故障。

因此在网站发布的时候，并不是把测试通过的代码包直接发布到线上服务器，而是先发布到预发布机器上，开发工程师和测试工程师在预发布服务器上进行预发布验证，执行一两个典型的业务流程，确认系统没有问题后才正式发布。

预发布服务器是一种特殊用途的服务器，它和线上的正式服务器唯一的不同就是没有配置在负载均衡服务器上，外部用户无法访问。

![1611500385129](ArchitectureAdvanced.assets/1611500385129.png)



#### 代码版本控制

对于大型互联网系统,核心应用系统和公用业务模块涉及许多团队和工程师,需要对相同的代码库进行共同开发和维护,而这些团队对同一个应用的开发维护,其开发周期和发布时间点各不相同。

如何进行代码管理,既能保证代码发布版本的稳定正确,同时又能保证不同团队的开发互不影响。

主干开发、分支发布：

- 代码修改都在主干上进行，需要发布的时候，从主干上拉一个分支发布，该分支即成为一个发布版本，如果该版本发现Bug，继续在该分支上修改发布，并将修改合并（merge) 回主干，直到下次主干发布。

分支开发,主干发布

- 任何修改都不得在主干上直接进行,需要开发一个新功能或者修复一个bug的时候,从主干拉一个分支进行开发,开发完成测试通过后,合回主干,然后从主干进行发布,主干上的代码永远是最新发布的版本。

两种方式各有优缺点。主干开发、分支发布方式，主干代码反应目前整个应用的状态，一目了然，便于管理和控制，也利于持续集成。分支开发，主干发布方式，各个分支独立进行，互不干扰，可以使不同发布周期的开发在同一应用中进行。

目前互联网应用开发中主要使用的是分支开发、主干发布的方式

![1611500626801](ArchitectureAdvanced.assets/1611500626801.png)



#### 自动化发布

网站的版本发布频繁,整个发布过程需要许多团队合作,发布前,多个代码分支合并回主干可能会发生冲突( conflict),预发布验证也会带来风险,每次发布又相当于一次宕机事故。因此网站发布过程荆棘丛生,一不小心就会踩到雷。

![1611500712710](ArchitectureAdvanced.assets/1611500712710.png)



#### 灰度发布

应用发布完成功后,仍然可能会发现因为软件问题而引入的故障,这时候就需要做发布回滚,即卸载刚刚发布的软件,将上一个版本的软件包重新发布,使系统复原,消除故障。      

大型网站的主要业务服务器集群规模非常庞大,比如QQ的服务器数量超过一万台。  一旦发现故障,即使想要发布回滚也需要很长时间才能完成,只能眼睁睁看着故障时间在不断增加干着急。

为了应付这种局面,大型网站会使用灰度发布模式,将集群服务器分成若干部分,每天只发布一部分服务器,观察运行稳定没有故障,第二天继续发布一部分服务器,持续几天的时间才把整个集群全部发布完毕,期间如果发现问题,就只需要回滚已发布的一部分服务器即可。



#### 网站运行监控            

“不允许没有监控的系统上线”, 这是许多网站架构师在做项目上线评审的时候常说的一句话。

网站运行监控对于网站运维和架构设计优化至关重要,没有监控的网站, 犹如盲人骑瞎马,夜半临深渊而不知。生死未卜,提高可用性、减少故障率就更无从做起了。

![1611551148364](ArchitectureAdvanced.assets/1611551148364.png)



#### 监控数据采集        

广义上的网站监控涵盖所有非直接业务行为的数据采集与管理,包括供数据分析师和产品设计师使用的网站用户行为日志,业务运行数据和系统性能数据等。



#### 用户行为日志收集

用户行为日志指用户在浏览器上所做所有操作及其所在的操作环境,包括用户操作系统与浏览器版本信息,IP地址,页面访问路径,页面停留时间等,这些数据对统计网站 PV/UV 指标,分析用户行为,优化网站设计,个性化营销与推荐等非常重要。    

具体用户行为日志收集手段有两种：    

服务器端日志收集,这个方案比较简单, Apache 等几乎所有Web服务器都具备日志记录功能,可以记录大部分用户行为日志,开启Web服务器的日志记录功能即可。其缺点是可能会出现信息失真,如IP地址是代理服务器地址而不是用户真实IP;多个链接指向同一个页面的情况下无法分辨访问路径等。    

客户端浏览器日志收集,浏览器可以收集用户真实的操作行为,因此比服务器日志收集更加精准。其缺点是比较麻烦,需要在页面嵌入特定的JS脚本来完成。



#### 服务器性能监控        

收集服务器性能指标,如系统Load,内存占用,磁盘IO,网络IO等对尽早做出故障预警,及时判断应用状况,防患于未然,将故障扼杀在萌芽时期非常重要。此外根据性能  监控数据,运维工程师可以合理安排服务器集群规模,架构师及时改善系统性能及调整系统伸缩性策略。    

目前网站使用比较广泛的开源性能监控工具是 Ganglia,支持大规模服务器集群,并支持以图形的方式在浏览器展示实时性能曲线。



#### 业务运行数据报告        

除了服务器系统性能监控,网站还需要监控一些具体业务场景相关的技术和业务指标,  比如缓冲命中率、平均响应延迟时间、每分钟发送邮件数目、待处理的任务总数等。

不同于服务器性能监控,网站运维人员可以在初始化系统的时候统一部署,业务运行数据需要在具体程序中采集并报告,汇总后统一显示。



#### 监控管理        

监控数据采集后,除了用作系统性能评估、集群规模伸缩性预测等,还可以根据实时监 控数据进行风险预警,并对服务器进行失效转移,自动负载调整,最大化利用集群所有机器的资源。

报警：   

服务器运行正常的情况下,其各项监控指标基本稳定在一个特定水平,如果这些指标超过某个阀值,就意味着系统可能将要出现故障,这时候就需要对相关人员报警,及时采取措施,在故障还未真正发生就将其扼杀在萌芽状态。    

监控管理系统可以配置报警阀值和值守人员联系方式,报警方式除了邮件,即时通讯工具,还可以配置手机短信,语音报警,保发生报警时,工程师即使在千里之外、夜里睡觉也能及时通知,迅速响应。

自动控制：    

自动失效转移: 除了应用程序访问失败时进行失效转移,监控系统也可以在发现故障的情况下主动通知应用,进行失效转移。    

自动扩容: 如果因访问压力大而导致服务性能指标下降,监控系统自动触发服务集群扩容    

自动限流: 根据监控指标,自动控制访问流量



#### 监控系统架构

![1611551779774](ArchitectureAdvanced.assets/1611551779774.png)



#### 高可用的价值观

保持简单，使问题易于发现，快速解决。

目标明确，解决特定环境下的具体问题。

价值回归，成本收益要合理。





### 故障案例分析

#### 故障1

故障现象：        

某应用服务器集群发布后不久就出现多台服务器相继报警,硬盘可用空间低于警戒值并且很快有服务器宕机。登录到线上服务器,发现log文件夹里的文件迅速增加,不断消耗磁盘空间。

原因分析：        

这是一个普通的应用服务器集群,不需要存储数据,因此服务器里配置的是一块100GB 的小硬盘,安装完操作系统、Web服务器、java虚拟机、应用程序后,空闲空间只有 几十GB了,正常情况下这些磁盘空间足够了,但是该应用的开发人员将log输出的 level全局配置为 Debug。

这样一次简单的Web请求就会产生大量的log文件输出,在高并发的用户请求下,很快就消耗完不多的磁盘空间。

经验教训：              

- 检查log配置文件,日志输出级别至少为 Warning,并且检查log输出代码调用,调用级别要符合其真实日志级别。      
- 有些开源的第三方组件也会不恰当地输出太多的 Error 日志,需要关闭这些第三方库的日志输出,至于哪些第三方库有问题,只有在遇到问题时才知道。    
- 应用程序自己的日志输出配置和第三方组件日志输出要分别配置。



#### 故障2

故障现象：

某应用发布后，数据库 Load 居高不下，远超过正常水平，持续报警。

原因分析:        

检查数据库,发现报警是因为某条SQL引起的这条SQL是一条简单的有索引的数据查询,不应该引发报警。

继续检查,发现这条SQL执行频率非常高,远远超过正常水平。

追查这条SQL,发现被网站首页应用调用首页是被访问最频繁的网页,这条SQL被首页调用,也就被频繁执行了。

经验教训:        

- 首页不应该访问数据库,首页需要的数据可以从缓存服务器或者搜索引擎服务器获取。   
- 首页最好是静态的。



#### 故障3 

故障现象:       

某应用服务器不定时地因为响应超时而报警但是很快又超时解除,恢复正常,如此反复,让运维人员非常苦恼。

原因分析:        

程序中某个单例对象( singleton object) 中多个方法使用了 synchronized修饰符,由于 this 对象只有一个,即使执行不同方法,所有的并发请求也都要排队获得这唯一的一把锁。

一般情况下,都是一些简单操作,获得锁,迅速完成操作,释放锁,不会引起线程排队。

但是某个需要执行远程调用的方法也被加了 synchronized,这个方法只是偶尔会被执行,但是每次执行都需要较长的时间才能完成,这段时间锁被占用,所有的用户线  程都要等待,响应超时,这个方法执行完后释放锁,其他线程迅速执行,超时解除。

经验教训：

- 使用锁操作要谨慎，特别注意在有锁的方法中进行长时间的IO操作的时候。
- 针对使用锁的不同场景，使用不同锁对象，而不是简单的在所有方法上都加上 synchronized



#### 故障4

故障现象:        

没有新应用发布,用户并发请求也没有突然增加,但是数据库服务器突然Load飙升,  并很快失去响应。DBA将数据库访问切换到备机,Load也很快飙升,并失去响应。最终引发网站全部瘫痪。

原因分析：        

缓存服务器在网站服务器集群中的地位一直比较低,服务器配置和管理级别都比其他服务器要低一些。人们都认为缓存是改善性能的手段,丢失一些缓存也没什么问题,有时候关闭一两台缓存服务器也确实对应用没有明显影响,所以长期疏于管理缓存服务器。  

结果这次一个缺乏经验的工程师关闭了缓存服务器集群中全部的几十台 Memcached服务器,导致了网站全部瘫痪的重大事故。

经验教训:        

- 当缓存已经不仅仅是改善性能,而是成为网站架构不可或缺的一部分时,对缓存的管理就需要提高到和其他服务器一样的级别。



#### 故障5

故障现象：

某应用发布后，服务器立即崩溃。

原因分析：

应用程序Web 环境使用Apache+JBoss 的模式，用户请求通过 Apache 转发到JBoss。在发布时，Apache和JBoss同时启动，由于JBoss启动时需要加载很多应用并初始化，花费时间较长，结果JBoss还没有完全启动，Apache就已经启动完毕开始接收用户请求，大量请求阻塞在JBoss 进程中，最终导致JBoss崩溃。

除了这种Apache和JBoss 启动不同步的情况，网站还有很多类似的场景，都需要后台服务准备好，前台应用才能启动，否则就会导致故障。

这种情况被内部人戏称作“姑娘们还没穿好衣服，老钨就开门迎客了"。

经验教训:        

- 老鸨开门前要检查下姑娘们是否穿好了衣服。
- 就本例来说,在java应用程序中加入一个特定的动态页面(比如只返回OK两个字母),启动脚本先启动 JBoss,然后在脚本中不断用curl命令访问这个特定页面,直到收到OK,才启动 Apache。



#### 故障6

故障现象：

某应用主要功能是管理用户图片，接到部分用户投诉，表示上传图片非常慢，原来只需要一两秒，现在需要几十秒，有时等半天结果浏览器显示服务器超时。

原因分析：

图片需要使用存储，最有可能出错的地方是存储服务器。检查存储服务器，发现大部分文件只有几百K，而有几个文件非常大，有数百兆，读写这些大文件一次需要几十秒，这段时间，磁盘基本被这个文件操作独占，导致其他用户的文件操作缓慢。

经验教训:       

- 存储的使用需要根据不同文件类型和用途进行管理,图片都是小文件,应该使用专用的存储服务器,不能和大文件共用存储。
- 批处理用的大文件可以使用其他类型的分布式文件系统。



#### 故障7

故障现象：

监控发现某个时段内，某些应用突然变慢，内部网络访问延迟非常厉害。

原因分析:        

检查发现,该时段内网卡流量也下降,但是没有找到原因。过了一阵子才知道,原来有工程师在线上生产环境进行性能压力测试,占用了大部分交换机带宽。

经验教训:       

- 访问线上生产环境要规范,不小心就会导致大事故。   
- 滥用生产环境的一个例子: 网站数据库有专门的DBA维护,如果发现数据库存在错误记录,需要进行数据订正,必须走数据订正流程,申请DBA协助。于是就有工程  师为避免麻烦,直接写一段数据库更新操作的代码,悄悄放到生产环境应用服务器上执行,神不知鬼不觉地订正了数据。但是如果不小心写错了SQL,后果可想而知。



#### 故障8        

故障现象:        

某应用发布后,数据库Load迅速飙升,超过报警值,回滚发布后报警消除。

原因分析：

发现该应用发布后出现大量数据库读操作,而这些数据本来应该从分布式缓存读取。检查缓存,发现数据已经被缓存了。

检查代码,发现访问缓存的那行代码被注释掉了。原来工程师在开发的时候,为了测试方便,特意注释掉读取缓存的代码,结果开发完成后忘记把注释去掉,直接提交到代码库被发布到线上环境。

经验教训:        

- 代码提交前使用 diff命令进行代码比较，确认没有提交不该提交的代码。    
- 加强code review,代码在正式提交前必须被至少一个其他工程师做过 code review,  并且共同承担因代码引起的故障责任。



#### 故障9        

故障现象:        

某应用更新某功能后,有少量用户投诉无法正常访问该功能,一点击就显示出错信息。

原因分析：

分析这些用户，都是第一次使用该功能，检查代码，发现程序根据历史使用记录构造一个对象，如果该对象为null，就会导致NullPointException。

经验教训：

- 程序在处理一个输入的对象时，如果不能明确该对象是否为空，必须做空指针判断。
- 程序在调用其他方法时，输入的对象尽量保证不是null，必要时构造空对象（使用空对象模式）。





### 作业与实践

- 问题：导致系统不可用的原因有哪些？保障系统稳定高可用的方案有哪些？请分别列举并简述。
- 答案：
  - 导致系统不可用的原因
    - 硬件故障
    - 软件程序Bug
    - 系统发布
    - 并发压力
    - 网络攻击
    - 外部不可抗因素（如：自然灾害、电缆被挖断……）
  - 保障系统稳定高可用的方案
    - 高可用系统架构
      1. 系统或组件解耦
      2. 业务隔离
      3. 异步架构
      4. 备份（集群、多节点）
      5. 重试、失效转移
      6. 熔断、限流
      7. 服务无状态
      8. 幂等设计、事务补偿
      9. 异地多活
    - 高可用系统运维
      1. 规范化发布流程
      2. 自动化发布/灰度发布
      3. 自动化运维监控、报警

    - 安全架构
      1. 开发安全防范（如：安全加密，HTTPS）
      2. 网络安全配置
      3. 防火墙
      4. 黑/白名单
      5. 安全扫描及监控



- 问题：请用你熟悉的编程语言写一个用户密码验证函数，Boolean checkPW （String用户ID， String 密码明文，String密码密文）返回密码是否正确 boolear值，密码加密算法使用你认为合适的加密算法。

![1611410651179](ArchitectureAdvanced.assets/1611410651179.png)

- 答案：
-  [Main.java](UserPasswordValidateFunc/src/main/java/org/copdays/rmliu/Main.java)
- [PasswordUtils.java](UserPasswordValidateFunc/src/main/java/org/copdays/rmliu/PasswordUtils.java)
- [PasswordUtilsGo.go](UserPasswordValidateFunc/src/main/java/org/copdays/rmliu/PasswordUtilsGo.go)
- [PasswordUtilsPHP.php](UserPasswordValidateFunc/src/main/java/org/copdays/rmliu/PasswordUtilsPHP.php)





## 大数据系统架构



### 大数据概述

#### 大数据技术发展史        

##### Hadoop

今天我们常说的大数据技术,其实起源于 Google 在2004年前后发表的三篇论文,也就是我们经常听到的大数据“三驾马车”分别是分布式文件系统GFS、大数据分布式计算框架 MapReduce和 NoSQL数据库系统 BigTable.        

搜索引擎主要就做两件事情,一个是网页抓取,一个是索引构建和排序,而在这个过程中,有大量的数据需要存储和计算。这“三驾马车”其实就是用来解决这个问题的,也  就是,一个文件系统、一个计算框架、一个数据库系统。        

浏览下 Hadoop的代码,这个纯用Java编写的软件其实并没有什么高深的技术难点,  使用的也都是一些最基础的编程技巧,也没有什么出奇之处,但是它却给社会带来巨大的影响,甚至带动一场深刻的科技革命,推动了人工智能的发展与进步。

Lucene开源项目的创始人 Doug Cutting 当时正在开发开源搜索引擎 Nutch,阅读了 Google 的论文后,根据论文原理初步实现了类似 GFS 和 MapReduce 的功能。        

2006年, Doug Cutting将这些大数据相关的功能从 Nutch 中分离了出来,然后启动了一个独立的项目专门开发维护大数据技术, 这就是后来赫赫有名的 **Hadoop**,主要包括  Hadoop分布式文件系统 **HDFS**和大数据计算引擎 **MapReduce**。

Hadoop发布之后, Yahoo首先用了起来。        

大概又过了一年到了2007年,百度和阿里巴巴也开始使用 Hadoop进行大数据存储与计算。        

2008年, Hadoop正式成为 Apache的顶级项目,后来 Doug Cutting本人也成为了 Apache基金会的主席。自此, Hadoop作为软件开发领域的一颗明星冉冉升起。        

同年,专门运营 Hadoop的商业公司 Cloudera成立, Hadoop得到进一步的商业支持。

这个时候, Yahoo的一些人觉得用 MapReduce 进行大数据编程太麻烦了,于是便开发了Pig。Pig是一种脚本语言,使用类SQL的语法,开发者可以用Pig脚本描述要对大数据集上进行的操作, Pig经过编译后会生 MapReduce程序,然后在 Hadoop上运行。          

编写Pig脚本虽然比直接 MapReduce编程容易,但是依然需要学习新的脚本语法。于是 Facebook又发布了hive。Hive支持使用SQL语法来进行大数据计算,比如说你可以写个 Select语句进行数据查询,然后 Hive会把SQL语句转化成 MapReduce的计算程序。这样,熟悉数据库的数据分析师和工程师便可以无门槛地使用大数据进行数据分析和处理了。

Hive出现后极大程度地降低了 Hadoop的使用难度,迅速得到开发者和企业的追捧。据说,2011年的时候, Facebook大数据平台上运行的作业90%都来源于Hive。

随后,众多 Hadoop周边产品开始出现,大据数生态体系逐渐形成,其中包括：

- 专门将关系数据库中的数据导入导出到 Hadoop平台的 Sqoop;    
- 针对大规模日志进行分布式收集、聚合和传输的 Flume;
- MapReduce 工作流调度引擎 Oozie。

![1611582520882](ArchitectureAdvanced.assets/1611582520882.png)



##### Yarn

在 Hadoop早期, MapReduce既是一个执行擎,又是一个资源调度框架,服务器集群的资源调度管理由 MapReduce自己完成。但是这样不利于资源复用,也使得  MapReduce 非常臃肿。于是一个新项目启动,将 MapReduce执行引擎和资源调度分离开来,这就是**Yarn**。2012年,Yarn成为一个独立的项目开始运营,随后被各类大  数据产品支持,成为大数据平台上最主流的资源调度系统。        



##### Spark

同样是在2012年, UC伯克利 AMP实验室( Algorithms、 Machine和 People的缩写)  开发的 **Spark**开始崭露头角。当时AMP实验室的马铁博士发现使用 MapReduce进行机器学习计算的时候性能非常差,因为机器学习算法通常需要进行很多次的迭代计算,  而 MapReduce每执行一次Map和 Reduce计算都需要重新启动一次作业,带来大量的无谓消耗。还有一点就是 MapReduce主要使用磁盘作为存储介质,而2012年的时候,  内存已经突破容量和成本限制,成为数据运行过程中主要的存储介质。 Spark一经推出,  立即受到业界的追捧,并逐步替代 MapReduce在企业应用中的地位。



##### 离线与实时计算

一般说来，像MapReduce、Spark 这类计算框架处理的业务场景都被称作**批处理计算**，因为它们通常针对以“天”为单位产生的数据进行一次计算，然后得到需要的结果，这中间计算需要花费的时间大概是几十分钟甚至更长的时间。因为计算的数据是非在线得到的实时数据，而是历史数据，所以这类计算也被称为**大数据离线计算**。

而在大数据领域，还有另外一类应用场景，它们需要对实时产生的大量数据进行**即时计算**，比如对于遍布城市的监控摄像头进行人脸识别和嫌犯追踪。这类计算称为**大数据流计算**，相应地，有**Storm、Flink、Spark Streaming** 等流计算框架来满足此类大数据应用的场景。流式计算要处理的数据是实时在线产生的数据，所以这类计算也被称为**大数据实时计算**。

NoSQL系统处理的主要也是大规模海量数据的存储与访问，所以也被归为大数据技术。NoSQL 曾经在2011年左右非常火爆，涌现出**HBase、Cassandra**等许多优秀的产品，其中HBase是从Hadoop中分离出来的、基于HDFS的NoSQL系统。

上面这些基本上都可以归类为大数据引擎或者大数据框架。而大数据处理的主要应用场景包括数据分析、数据挖掘与机器学习。数据分析主要使用Hive、 Spark SQL等 SQL引擎完成; 数据挖掘与机器学习则有专门的机器学习框架 TensorFlow、 Mahout以及  MLlib等,内置了主要的机器学习和数据挖掘算法。

![1611582858657](ArchitectureAdvanced.assets/1611582858657.png)



#### 大数据应用发展史        

##### 大数据应用的搜索引擎时代       

作为全球最大的搜索引擎公司, Google也是我们公认的大数据鼻祖,它存储着全世界几乎所有可访问的网页,数目可能超过万亿规模,全部存储起来大约需要数万块磁盘。为了将这些文件存储起来, Google开发了GFS(Google文件系统), 将数千台服务器上的数万块磁盘统一管理起来,然后当作一个文件系统,统一存储所有这些网页文件。        

Google 得到这些网页文件是要构建搜索引擎, 需要对所有文件中的单词进行词频统计,  然后根据 Page Rank算法计算网页排名。这中间, Google需要对这数万块磁盘上的文件进行计算处理,,也正是基于这些需求, Google又开发了 MapReduce大数据计算框架。



##### 大数据应用的数据仓库时代     

曾经人们在进行数据分析与统计时,仅仅局限于数据库,在数据库的计算环境中对数据库中的数据表进行统计分析。并且受数据量和计算能力的限制,只能对最重要的数据进行统计和分析。这里所谓最重要的数据,通常指的都是给老板看的数据和财务相关的数据。      

而Hive可以在 Hadoop上进行SQL操作,实现数据统计与分析。也就是说,可以用更低廉的价格获得比以往多得多的数据存储与计算能力。可以把运行日志、应用采集数据数据库数据放到一起进行计算分析,获得以前无法得到的数据结果,企业的数据仓库也随之呈指数级膨胀。      

不仅是老板,公司中每个普通员工比如产品经理、运营人员、工程师,只要有数据访问权限,都可以提出分析需求,从大数据仓中获得自己想要了解的数据分析结果。



##### 大数据应用的数据挖掘时代        

很早以前商家就通过数据发现, 买尿不湿的人通常也会买啤酒, 于是精明的商家就把这两样商品放在一起,以促进销售。除了商品和商品有关系,还可以利用人和人之间的关系推荐商品。如果两个人购买的商品有很多都是类似甚至相同的,不管这两个人天南海北相隔多远,他们一定有某种关系,比如可能有差不多的教育背景、经济收入、兴趣爱好。根据这种关系,可以进行关联推荐,让他们看到自己感兴趣的商品。        

大数据还可以将每个人身上的不同特性挖掘出来,打上各种各样的标签: 90后、生活在一线城市、月收入1~2万、宅...... 这些标签组成了用户画像,并且只要这样的标签足  够多, 就可以完整描绘出一个人。除了商品销售,数据挖掘还可以用于人际关系挖掘。



##### 大数据应用的机器学习时代        

人们很早就发现,数据中蕴藏着规律,这个规律是所有数据都遵循的,过去发生的事情遵循这个规律,将来要发生的事情也遵循这个规律。一旦找到了这个规律,对于正在发生的事情,就可以按照这个规律进行预测。        

在过去,受数据采集、存储、计算能力的限制,只能通过抽样的方式获取小部分数据,  无法得到完整的、全局的、细节的规律。而现在有了大数据,可以把全部的历史数据都收集起来,统计其规律,进而预测正在发生的事情        

这就是机器学习。



#### 大数据应用领域        

##### 医学影像智能识别        

图像识别是机器学习获得的重大突破之一,使用大量的图片数据进行深度机器学习训练,  机器可以识别出特定的图像元素,比如猫或者人脸,当然也可以识别出病理特征。        

比如X光片里的异常病灶位置, 是可以通过机器学习智能识别出来的。甚至可以说医学影像智能识别在某些方面已经比一般医生拥有更高的读图和识别能力。



##### 病历大数据智能诊疗

病历，特别是专家写的病历，本身就是一笔巨大的知识财富，利用大数据技术将这些知识进行处理、分析、统计、挖掘，可以构成一个病历知识库，可以分享给更多人，即构成一个智能辅助诊疗系统。

![1611583291584](ArchitectureAdvanced.assets/1611583291584.png)



##### AI外语老师        

得益于语音识别和语音合成技术的成熟(语音识别与合成技术同样是利用大数据技术进行机器学习与训练), 一些在线教育网站尝试用人工智能外语老师进行外语教学。

这里面的原理其实并不复杂, 聊天机器人技术已经普遍应用, 只要将学习的知识点设计进聊天的过程中,就可以实现一个简单的AI外语老师了。



##### 智能解题

比较简单的智能解题系统其实是利用搜索引擎技术，在收集大量的试题以及答案的基础上，进行试题匹配，将匹配成功的答案返回。这个过程看起来就像智能做题一样，表面看给个题目就能解出答案，而实际上只是找到答案。

进阶一点的智能解题系统，通过图像识别与自然语言处理（这两项技术依然使用大数据技术实现），进行相似性匹配。更改试题的部分数字、文字表述，但是不影响实质性解答思路，依然可以解答。

高阶的智能解题系统，利用神经网络机器学习技术，将试题的自然语言描述转化成形式语言，然后分析知识点和解题策略，进行自动推导，从而完成实质性的解题。



##### 舆情监控与分析        

编写数据爬虫,实时爬取各个社交新媒体上的各种用户内容和媒体信息,然后通过自然语言处理,就可以进行情感分析、热点事件追踪等。舆情实时监控可用于商业领域,引导智能广告投放;可用于金融领域,辅助执行自动化股票、期权、数字货币交易;可用于社会管理,及时发现可能引发社会问题的舆论倾向。        

在美国总统大选期间,候选人就曾雇佣大数据公司利用社交媒体的数据进行分析,发现选票可能摇摆的地区,有针对性前去进行竞选演讲。并利用大数据分析选民关注的话题, 包装自己的竞选主张。 Facebook也因为授权大数据公司滥用自己用户的数据而遭到调查和谴责,市值蒸发了数百亿美元。



##### 大数据风控        

在金融借贷中,如何识别出高风险用户,要求其提供更多抵押、支付更高利息、调整更低的额度,甚至拒绝贷款, 从而降低金融机构的风险?

事实上,金融行业已经沉淀了大量的历史数据,利用这些数据进行计算,可以得到用户特征和风险指数的曲线(即风控模型)。当新用户申请贷款的时候,将该用户特征带入曲线进行计算,就可以得到该用户的风险指数,进而自动给出该用户的贷款策略



##### 新零售

亚马逊Go 无人店使用大量的摄像头，实时捕捉用户行为，判断用户取出还是放回商品、取了何种商品等。

这实际上是大数据流计算与机器学习的结合，最终实现的购物效果是，无需排队买单，进去就拿东西，拿好了就走。



##### 无人驾驶        

无人驾驶就是在人的驾驶过程中实时采集车辆周边数据和驾驶控制信息, 然后通过机器学习,获得周边信息与驾驶方式的对应关系(自动驾驶模型)。然后将这个模型应用到无人驾驶汽车上,传感器获得车辆周边数据后,就可以通过自动驾驶模型计算出车辆控制信息(转向、刹车等)。

计算自动驾驶模型需要大量的数据,所以我们看到,这些无人驾驶创业公司都在不断攀比自己的训练数据有几十万公里、几百万公里,因为训练数据的量意味着模型的完善程度。





### HDFS

#### 常用 RAID 技术

- RAID 0
- RAID 1
- RAID 10
- RAID 5 （常用）
- RAID 6

![1610631204528](ArchitectureAdvanced.assets/1610631204528.png)

![1610631266477](ArchitectureAdvanced.assets/1610631266477.png)



#### HDFS 系统架构

![1611583727072](ArchitectureAdvanced.assets/1611583727072.png)





#### 数据存储细节

![1611584122341](ArchitectureAdvanced.assets/1611584122341.png)



#### HDFS 设计目标

HDFS 以流式数据访问模式存储超大文件，运行于商用硬件集群上。

- 超大文件
- 流式数据访问
  - 一次写入多次读取
- 商用硬件



#### 不适合 HDFS 的场景

- 低延迟的数据访问
- 大量小文件
  - 超过 NameNode 的处理能力
- 多用户随机写入修改文件

HDFS为了做到可靠性（reliability）创建了多份数据块（data blocks）的复制（replicas），并将它们放置在服务器群的计算节点中（compute nodes），MapReduce就可以在它们所在的节点上处理这些数据了。

![1611584211925](ArchitectureAdvanced.assets/1611584211925.png)



#### 设计目标

假设：节点失效是常态

理想：

- 任何一个节点失效，不影响 HDFS 服务
- HDFS 可以自动完成副本的复制



#### 文件

文件切分成块（默认大小64M，实践中一般使用128M），以块为单位，每个块有多个副本存储在不同的机器上，副本数可在文件生成时指定（默认3）
NameNode是主节点，存储文件的元数据如文件名，文件目录结构，文件属性（生成时间，副本数，文件权限），以及每个文件的块列表以及块所在的 DataNode等等。

DataNode在本地文件系统存储文件块数据，以及块数据的校验和。

可以创建、删除、移动或重命名文件，当文件创建、写入和关闭之后不能修改文件内容。



#### 分而治之（Divide and Conquer）

##### Hadoop Distributed File System

![1611584251626](ArchitectureAdvanced.assets/1611584251626.png)



##### Distributed Processing

![1611584269909](ArchitectureAdvanced.assets/1611584269909.png)

![1611584287645](ArchitectureAdvanced.assets/1611584287645.png)



#### NameNode

NameNode 是一个中心服务器, 负责管理文件系统的名字空间( namespace)以及客户端对文件的访问。    

文件操作, NameNode负责文件元数据的操作, DataNode负责处理文件内容的读写请求, 跟文件内容相关的数据流不经过 NameNode,只会询问它跟那个 DataNode联系, 否则 NameNode会成为系统的瓶颈。

副本存放在哪些 DataNode上由 NameNode来控制,根据全局情况做出块放置决定,  读取文件时 NameNode 尽量让用户先读取最近的副本, 降低网络带宽消耗和读取时延。

NameNode 全权管理数据块的复制,它周期性地从集群中的每个 DataNode接收心跳信号和块状态报告( Blockreport)。接收到心跳信号意味着该 DataNode节点工作正常。 块状态报告包含了一个该 DataNode上所有数据块的列表。



#### DataNode       

一个数据块在 DataNode 以文件存储在磁盘上, 包括两个文件,一个是数据本身,一个是元数据包括数据块的长度, 块数据的校验和时间戳。    

DataNode启动后向 NameNode注册,通过后, 周期性(1小时)的向 NameNode上报所有的块信息。    

心跳是每3秒一次,心跳返回结果带有 NameNode 给该 DataNode的命令如复制块数据到另一台机器,或删除某个数据块。如果超过10分钟没有收到某个 DataNode的心跳,  则认为该节点不可用。    

集群运行中可以安全加入和退出一些机器。



#### HDFS 关键运行机制 - 高可用

一个名字节点和多个数据节点。

数据复制（冗余机制）

- 存放的位置（机架感应策略）

故障检测

数据节点

- 心跳包（检测是否宕机）
- 块报告（安全模式下检测）
- 数据完整性检测（校验和比较）

名字节点（日志文件，镜像文件）

空间回收机制

![1611584333830](ArchitectureAdvanced.assets/1611584333830.png)



#### HDFS 如何写文件？

- 使用 HDFS 提供的客户端开发库Client，向远程的 NameNode发起RPC请求；
- NameNode 会检查要创建的文件是否已经存在，创建者是否有权限进行操作，成功则会为文件创建一个记录，否则会让客户端抛出异常；
- 当客户端开始写入文件的时候，开发库会将文件切分成多个packets，并在内部以数据队列"data queue"的形式管理这些packets，并向NameNode申请新的blocks，获取用来存储 replicas 的合适的 datanodes 列表，列表的大小根据在 NameNode中对replication的设置而定。
- 开始以 pipeline（管道）的形式将 packet写入所有的 replicas中。开发库把 packet以流的方式写入第一个datanode，该datanode把该 packet存储之后，再将其传递给在此 pipeline中的下一个datanode，直到最后一个datanode，这种写数据的方式呈流水线的形式。
- 最后一个datanode成功存储之后会返回一个 ack packet，在 pipeline里传递至客户端，在客户端的开发库内部维护着“ack queue”，成功收到 datanode返回的ack packet 后会从“ack queue”移除相应的packet。
- 如果传输过程中，有某个datanode 出现了故障，那么当前的 pipeline会被关闭，出现故障的 datanode 会从当前的pipeline中移除，剩余的block 会继续写入剩下的 datanode 中，继续以pipeline的形式传输，同时NameNode会分配一个新的 datanode，保持replicas设定的数量。

![1611584362697](ArchitectureAdvanced.assets/1611584362697.png)

写一个数据块

![1611584454387](ArchitectureAdvanced.assets/1611584454387.png)



#### HDFS 如何读文件？

- 使用HDFS提供的客户端开发库Client，向远程的NameNode发起RPC请求；
- NameNode 会视情况返回文件的部分或者全部 block列表，对于每个block，NameNode 都会返回有该block拷贝的DataNode地址；
- 客户端开发库 Client会选取离客户端最接近的 DataNode来读取block；如果客户端本身就是DataNode，那么将从本地直接获取数据。
- 读取完当前 block的数据后，关闭与当前的 DataNode连接，并为读取下一个block寻找最佳的DataNode；
- 当读完列表的 block后，且文件读取还没有结束，客户端开发库会继续向 NameNode获取下一批的block列表。
- 读取完一个 block 都会进行 checksum 验证，如果读取 DataNode时出现错误，客户端会通知NameNode，然后再从下一个拥有该block 拷贝的DataNode继续读。

![1611584491581](ArchitectureAdvanced.assets/1611584491581.png)



#### 节点失效是常态

- DataNode 中的磁盘挂了怎么办?    
- DataNode 所在机器挂了怎么办?    
- NameNode挂了怎么办?    
- Client挂了怎么办?



##### DataNode 的磁盘挂了怎么办?

- DataNode正常服务    
- 坏掉的磁盘上的数据尽快通知 NameNode



##### DataNode 所在机器挂了怎么办?        

问: NameNode怎么知道 DataNode挂掉了?    

答: Datanode每3秒钟向 NameNode发送心跳, 如果10分钟 DataNode没有向 NameNode发送心跳，则 Name Node认为该 DataNode 已经dead, NameNode将取出该 DataNode上对应的 block, 对其进行复制.



##### NameNode挂了怎么办?        

持久化元数据

- 操作日志( edit log)  
  - 记录文件创建, 删除, 修改文件属性等操作
- Fsimage  
  - 包含完整的命名空间
  - File -> Block的映射关系  
  - 文件的属性(ACL, quota, 修改时间等)

![1611584722222](ArchitectureAdvanced.assets/1611584722222.png)



##### Client挂了怎么办?

问： Client 所在机器挂了有什么影响？

答：一致性问题

![1611584751291](ArchitectureAdvanced.assets/1611584751291.png)



#### HDFS 一致性模型

- 文件创建以后，不保证在 NameNode立即可见，即使文件刷新并存储，文件长度依然可能为0；
- 当写入数据超过一个块后，新的 reader可以看见第一个块，reader不能看见当前正在写入的块；
- HDFS 提供 sync() 方法强制缓存与数据节点同步，sync() 调用成功后，当前写入数据对所有reader可见且一致；
- 调用sync() 会导致额外的开销。



#### 副本摆放策略

- 不放置同一个机架

![1611584845891](ArchitectureAdvanced.assets/1611584845891.png)



#### 压缩

减少存储所需的磁盘空间

加速数据在网络和磁盘上的传输

![1611584866320](ArchitectureAdvanced.assets/1611584866320.png)



#### SequenceFile

![1611584884206](ArchitectureAdvanced.assets/1611584884206.png)



#### 参数设置 hdfs-site.xml

数据块 block

- 默认 64 M，通常设置为 128 M
- 可以在 hdfs-site.xml 中设置

```xml
<property>
  <name>dfs.block.size</name>
  <value>134217728</value>
</property>
```

NameNode 参数，在 hdfs-site.xml 中设置。

```xml
dfs.name.dir

<property>
  <name>dfs.name.dir</name>
  <value>/data0/name, /nfs/name</value>
  <description>文件存储路径</description>
</property>


dfs.replication

<property>
  <name>dfs.replication</name>
  <value>3</value>
  <description>复本数</description>
</property>
```

DataNode 参数，在 hdfs-site.xml 中设置。

```xml
dfs.data.dir

<property>
  <name>dfs.data.dir</name>
  <value>/data0/hdfs,/data1/hdfs</value>
  <description>数据存储目录</description>
</property>
```



#### Hadoop 文件系统

文件系统抽象（org.apache.hadoop）

- fs.FileSystem
- fs.LocalFileSystem
- hdfs.DistributedFileSystem
- hdfs.HftpFileSystem
- hdfs.HsftpFileSystem
- fs.HarFileSystem



#### Java 接口

通过 FileSystem API 读取数据

- Path 对象

  - ```java
    hdfs://localhost:9000/user/tom/t.txt
    ```

- 获取 FileSystem 实例

  - ```java
    public static FileSystem get(Configuration conf) throws IOException
    
      
    public static FileSystem get(URI uri, Configuration conf) throws IOException
    ```

- 获取文件输入流

  - ```java
    public FSDataInputStream open(Path p) throws IOException
    
    public abstract FSDataInputStream open(Path p,int bufferSize) throws IOException
    ```





### MapReduce

#### MapReduce: 大规模数据处理

- 处理海量数据（> 1 TB）
- 上百上千 CPU 实现并行处理

简单地实现以上目的

- 移动计算比移动数据更划算

分而治之（Divide and Conquer）



#### MapReduce 特性

- 自动实现分布式并行计算
- 容错
- 提供状态监控工具
- 模型抽象简介，程序员易用



#### MapReduce

它是有 map 和 reduce 的两部分用户程序组成，然后利用框架在计算机集群上面根据需求运行多个程序实例来处理各个子任务，然后再对结果进行归并。



#### WordCount 举例

```python
# 文本前期处理
str_list = strl.replace('\n', '').lower().split(' ')
count_dict = {}

# 如果字典里有该单词则加1，否则添加入字典
for str in str_list:
    if str in count_dict.keys():
    		count_dict[str] = count_dict[str] + 1
    else:
   		  count_dict[str] = 1
```

![1611585096804](ArchitectureAdvanced.assets/1611585096804.png)



#### MapReduce 的 WordCount

```java
public class WordCount {
    public static class TokenizerMapper extends Mapper<Object, Text, Text, IntWritable> {
        private final static IntWritable one = new IntWritable(1);
        private Text word = new Text();
      
        public void map(Object key, Text value, Context context) throws IOException, InterruptedException {
            StringTokenizer itr = new StringTokenizer(value.toString());

            while (itr.hasMoreTokens()) {
                word.set(itr.nextToken());
                context.write(word, one);
        
            }
        }
    }
  
    public static class IntSumReducer extends Reducer<Text,IntWritable,Text,IntWritable> {
        private IntWritable result = new IntWritable();

        public void reduce(Text key, Iterable<IntWritable> values, Context context) throws IOException, InterruptedException {
            int sum = 0;

            for (IntWritable val : values) {
                sum += val.get();
            }
            result.set(sum);
            context.write(key, result);
        }
    }
  
    public static void main(String[] args) throws Exception {
        Configuration conf = new Configuration();  // 得到集群配置参数
      
        Job job = Job.getInstance(conf, "WordCount");  // 设置到本次的 job 实例
        job.setJarByClass(WordCount.class);  // 指定本次执行的主类是 WordCount
        job.setMapperClass(TokenizerMapper.class);  // 指定 map 类
        job.setCombinerClass(IntSumReducer.class);  // 指定 combiner 类
        job.setReducerClass(IntSumReducer.class);  // 指定 reducer 类
        job.setOutputKeyClass(Text.class);
        job.setOutputValueClass(IntWritable.class);
      
        FileInputFormat.addInputPath(job, new Path(args[0]));  // 指定输入数据的路径
        FileOutputFormat.setOutputPath(job, new Path(args[1]));  // 指定输出路径
      
        System.exit(job.waitForCompletion(true) ? 0 : 1);  // 指定 job 执行模式，等待任务执行完成后，提交任务的客户端才会退出
    }

}


```

![1611585781813](ArchitectureAdvanced.assets/1611585781813.png)

![1611585795232](ArchitectureAdvanced.assets/1611585795232.png)



#### MapReduce 架构图

- HDFS 中的 block 等于 MapReduce 中的 Split
- MapReduce 会在 map 和 reduce 的中间，执行 shuffle ，可以完成数据的排序，将同类数据value进行归并为values

![1611585820737](ArchitectureAdvanced.assets/1611585820737.png)

![1611585835537](ArchitectureAdvanced.assets/1611585835537.png)

![1611585853774](ArchitectureAdvanced.assets/1611585853774.png)



#### MapReduce 计算架构图

![1611585873246](ArchitectureAdvanced.assets/1611585873246.png)



#### MapReduce 应用

适合 MapReduce 的计算类型

- TopK
- K-means
- Bayes
- SQL

不适合 MapReduce 的计算类型

- Fibonacci



#### InputFormat

验证作业的输入的正确性    

将输入文件切分成逻辑的 InputSplits,一个 InputSplit将被分配给一个单独的 Mapper task  提供 RecordReader的实现, 这个 RecordReader会从 InputSplit中正确读出一条一条的  K-V 对供 Mapper使用。

![1611585887401](ArchitectureAdvanced.assets/1611585887401.png)



#### FileInputFormat

得到分片的最小值 minSize和最大值 maxSize，可以通过设置 mapred.min.split.size和 mapred.max.split.size来设置；

对于每个输入文件，计算 max(minSize, min(maxSize, blockSize))；

如果minSize<=blockSize<=maxSize，则设为blockSize。

分片信息<file, start, length, hosts>，通过hosts实现map本地性。



#### OutputFormt

OutputFormt 接口决定了在哪里以及怎样持久化作业结果。    

默认的 OutputFormat 就是 TextOutputFormat,它是一种以行分隔, 包含制表符界定的键值对的文本文件格式。



#### Partitioner        

什么是 Partitioner        

- Mapreduce 通过 Partitioner 对 Key 进行分区, 进而把数据按我们自己的需求来分发。

什么情况下使用 Partitioner

- 如果你需要key 按照自己意愿分发, 那么你需要这样的组件。  
- 框架默认的 HashPartitioner  
- 例如: 数据内包含省份, 而输出要求每个省份输出一个文件。

```java
public int getPartition(K key, V value, int numReduceTasks) {
  
  	return (key.hashCode() & Integer.MAX_VALUE) % numReduceTasks;
}
```



#### 主要调度方法

##### 单队列调度

- 特点：FIFO
- 优点：简单
- 缺点：资源利用率低



##### 容量调度（Capacity Scheduler，Hadoop-0.19.0)

- 特点：
  - 多队列，每个队列分配一定系统容量（Guaranteed Capacity)
  - 空闲资源可以被动态分配给负载重的队列
  - 支持作业优先级
- 作业选择：
  - 选择队列：资源回收请求队列优先；最多自由空间队列优先。
  - 选择作业：按提交时间、优先级排队；检查用户配额；检查内存。
- 优点：
  - 支持多作业并行执行，提高资源利用率
  - 动态调整资源分配，提高作业执行效率
- 缺点：
  - 队列设置和队列选择无法自动进行，用户需要了解大量系统信息



##### 公平调度（Fair Scheduler, Hadoop-0.19.0)

- 目标：
  - 改善小作业的响应时间
  - 确保生产性作业的服务水平
- 特点：
  - 将作业分组——形成作业池(based on a configurable attribute，such as user name, unix group, ..…)
  - 给每个作业池分配最小共享资源（Minimum map slots，Minimum reduce slots)
  - 将多余的资源平均分配给每个作业
- 作业选择：
  - 优先调度资源小于最小共享资源的作业
  - 选择分配资源与所需资源差距最大的作业
- 优点：
  - 支持作业分类调度，使不同类型的作业获得不同的资源分配，提高服务质量
  - 动态调整并行作业数量，充分利用资源
- 缺点：
  - 不考虑节点的实际负载状态，导致节点负载实际不均衡



#### JobTracker 内部实现

作业控制

- 作业抽象成三层：作业监控层（JIP），任务控制层（TIP），任务执行层。
- 任务可能会被尝试多次执行，每个任务实例被称作 Task Attempt（TA）
- TA成功，TIP会标注该任务成功，所有TIP成功，JIP成功

资源管理

- 根据TaskTracker 状态信息进行任务分配



#### JobTracker 容错

JobTracker 失败，那么未完成 Job 失败；

通过 Job 日志，Job 可部分恢复。



#### TaskTracker 容错

超时          

- Task Tracker 10分钟 (mapred.tasktracker.expiry.interval) 未汇报心跳, 则将其从集群移除

灰名单,黑名单

- TaskTracker 上部署性能监控脚本
- 如果性能表现太差,被 JobTracker暂停调度



#### Task 容错

允许部分Task失败              

- 允许失败的任务占比, 默认0, Maprec.max.map.filers.percent,  mapred.max.reduce.failures.percent

Task由TP监控,失败任务多次尝试,慢任务启动备份任务

- 每次都是一个TA( Task Attempt), 最大允许尝试次数: mapped.map.max.attempts,  mapred.reduce.max.attempts



#### Record 容错        

跳过导致 Task失败的坏记录

- K,V 超大,导致OOM, 配置最大长度, 超出截断 mapred.linercordreader.maxlength  
- 异常数据引发程序bug, task重试几次后,自动入 skip mode, 跳过导致失败的记录  mapred.skip.attempts.to.start.skipping



### Yarn

#### YARN：Yet Another Resource Negotiator

下一代 MapReduce 框架的名称。

不再是一个传统的 MapReduce 框架，甚至与 MapReduce 无关。

一个通用的运行时框架，用户可以编写自己的计算框架，在该运行环境中运行。

MapReduce 的架构，在MapReduce 应用程序的启动过程中，最重要的就是要把 MapReduce 程序分发到大数据集群的服务器上，在Hadoop1中，这个过程主要是通过 TaskTracker和 JobTracker通信来完成。

这种架构方案的主要缺点是，服务器集群资源调度管理和 MapReduce执行过程耦合在一起，如果想在当前集群中运行其他计算任务，比如 Spark或者Storm，就无法统一使用集群中的资源了。

在 Hadoop早期的时候, 大数据技术就只有 Hadoop一家,这个缺点并不明显。但随着大数据技术的发展, 各种新的计算框架不断出现,我们不可能为每一种计算框架部署个服务器集群, 而且就算能部署新集群, 数据还是在原来集群的HDFS上。

所以我们需要把 MapReduce的资源管理和计算框架分开, 这也是 Hadoop 2最主要的变化, 就是将 Yarn从 MapReduce 中分离出来,成为一个独立的资源调度框架。 

MRv2 最基本的设计思想是将 JobTracker 的两个主要功能, 即资源管理和作业管理分成两个独立的进程。

- 在该解决方案中包含两个组件: 全局的 ResourceManager(RM) 和与每个应用相关的  ApplicationMaster (AM)      
- 这里的“应用”指一个单独的MapReduce作业或者DAG作业
                    



#### Yarn 架构

![1611665059107](ArchitectureAdvanced.assets/1611665059107.png)

Yarn包括两个部分:       

一个是资源管理器(Resource Manager), 一个是节点管理器( Node Manager)。        

这也是 Yarn的两种主要进程:  ResourceManager 进程负责整个集群的资源调度管理,  通常部署在独立的服务器上; NodeManager 进程负责具体服务器上的资源和任务管理,  在集群的每一台计算服务器上都会启动, 基本上跟HDFS 的 DataNode进程一起出现。

资源管理器又包括两个主要组件：调度器和应用程序管理器。

调度器其实就是一个资源分配算法，根据应用程序（Client) 提交的资源申请和当前服务器集群的资源状况进行资源分配。Yarn内置了几种资源调度算法，包括Fair Scheduler、Capacity Scheduler等，你也可以开发自己的资源调度算法供Yarn调用。

Yarn 进行资源分配的单位是容器（Container)，每个容器包含了一定量的内存、CPU等计算资源，默认配置下，每个容器包含一个CPU核心。容器由NodeManager 进程启动和管理，NodeManger 进程会监控本节点上容器的运行状况并向 ResourceManger进程汇报。

应用程序管理器负责应用程序的提交、监控应用程序运行状态等。应用程序启动后需要在集群中运行一个 ApplicationMaster, ApplicationMaster 也需要运行在容器里面。每个应用程序启动后都会先启动自己的 ApplicationMaster,由 ApplicationMaster根据应用程序的资源需求进一步向 ResourceManager进程申请容器资源,得到容器以后就会分发自己的应用程序代码到容器上启动,进而开始分布式计算。



#### Yarn的工作流程 (Map Reduce为例)        

我们向Yarn提交应用程序,包括 MapReduce ApplicationMaster、我们的 MapReduce  程序,以及 Map Reduce Application启动命令。    

ResourceManager进程和 NodeManage进程通信,根据集群资源,为用户程序分配第一个容器,并将 MapReduce ApplicationMaster 分发到这个容器上面,并在容器里面启 Map Reduce ApplicationMaster.    

MapReduce ApplicationMaster启动后立即向 ResourceManager进程注册,并为自己的应用程序申请容器资源。   

MapReduce ApplicationMaster申请到需要的容器后,立即和相应的 NodeManager进程通信,将用户 MapReduce程序分发到 NodeManager进程所在服务器,并在容器中运行,运行的就是Map或者 Reduce任务。    

Map或者 Reduce任务在运行期和 Map Reduce ApplicationMaster 通信,汇报自己的运行状态,如果运行结束, MapReduce ApplicationMaster ResourceManager进程注销并释放所有的容器资源。



#### 资源管理器 HA

- ZooKeeper

![1611665769409](ArchitectureAdvanced.assets/1611665769409.png)





### Hive

#### SQL 与 MapReduce

- Map
- Shuffle
- Reduce

![1611665891359](ArchitectureAdvanced.assets/1611665891359.png)

![1611665911595](ArchitectureAdvanced.assets/1611665911595.png)

![1611665931303](ArchitectureAdvanced.assets/1611665931303.png)



#### Hive 语句

```sh
hive> CREATE TABLE pokes (foo INT, bar STRING);

hive> SHOW TABLES;

hive> ALTER TABLE pokes ADD COLUMNS (new_col INT);

hive> DROP TABLE pokes;

hive> LOAD DATA LOCAL INPATH './examples/files/kv1.txt' OVERWRITE INTO TABLE pokes;  -- 本地文件与 hive table 相关联

hive> SELECT a.foo FROM invites a WHERE a.ds='2008-08-15';
```



#### Hive 架构

![1611666173234](ArchitectureAdvanced.assets/1611666173234.png)

![1611666208281](ArchitectureAdvanced.assets/1611666208281.png)



#### Hive 执行流程        

- 操作符(Operator) 是Hive的最小处理单元    
- 每个操作符处理代表 HDFS操作或MR作业    
- 编译器把Hive SQL转换成一组操作符

![1611666335492](ArchitectureAdvanced.assets/1611666335492.png)



#### Hive 编译器

![1611666348453](ArchitectureAdvanced.assets/1611666348453.png)

![1611666390487](ArchitectureAdvanced.assets/1611666390487.png)

![1611666410103](ArchitectureAdvanced.assets/1611666410103.png)





#### Example Query (Filter)

Filter status updates containing ‘michael jackson’

- SELECT * FROM status_updates WHERE status LIKE ‘michael jackson’

![1611666497411](ArchitectureAdvanced.assets/1611666497411.png)



#### Example Query (Aggregation)

Figure out total number of status_updates in a given day

- SELECT COUNT(1) FROM status_updates WHERE ds = ’2009-08-01’

![1611666574900](ArchitectureAdvanced.assets/1611666574900.png)



#### Example Query (multi-group-by)

```sql
FROM (SELECT a.status, b.school, b.gender
    FROM status_updates a 
      	JOIN profiles b
    		ON (a.userid = b.userid and a.ds='2009-03-20' )
		) subq1

INSERT OVERWRITE TABLE gender_summary PARTITION(ds='2009-03-20')

SELECT subq1.gender, COUNT(1) GROUP BY subq1.gender

INSERT OVERWRITE TABLE school_summary PARTITION(ds='2009-03-20')

SELECT subq1.school, COUNT(1) GROUP BY subq1.school
```

![1611666774054](ArchitectureAdvanced.assets/1611666774054.png)



### Hive Metastore

#### Single User Mode (Default)

![1611666894760](ArchitectureAdvanced.assets/1611666894760.png)



#### Multi User Mode

![1611666955810](ArchitectureAdvanced.assets/1611666955810.png)



#### Remote Server

![1611667020964](ArchitectureAdvanced.assets/1611667020964.png)



#### Hive QL – Join

```sql
INSERT OVERWRITE TABLE pv_users

SELECT pv.pageid, u.age FROM page_view pv
		JOIN user u
		ON (pv.userid = u.userid);
```



#### Hive QL – Join in Map Reduce

![1611667357342](ArchitectureAdvanced.assets/1611667357342.png)



#### Join Optimizations

Map Joins

- User specified small tables stored in hash tables on the mapper backed by jdbm
- No reducer needed

```sql
INSERT INTO TABLE pv_users

SELECT /*+ MAPJOIN(pv) */ pv.pageid, u.age FROM page_view pv 
		JOIN user u
		ON (pv.userid = u.userid);
```



#### Hive QL – Map Join

![1611667503169](ArchitectureAdvanced.assets/1611667503169.png)





### 作业与实践

1.在你所在的公司（行业，领域），正在用大数据处理哪些业务？可以用大数据实现那些价值？

答案：

- 我所在的公司是一个金融科技公司，而公司的核心能力是大数据风控和智能获客，都是在挖掘大数据价值的基础上进行的。通过挖掘各种海量数据进行智能客群分析，用户画像，开展智能获客。 在大数据挖掘基础上，创建反欺诈、反洗钱模型，创建用户的信用评估系统，在贷款前对用户进行可入准入评估；在贷款期间，动态分析可能存在的风险；贷后进行贷后管理，智能催收。
  我所在的部门是基础架构研发部，我们支撑和维护着公司的离线数据仓库和准实时的数据仓库，各种大数据挖掘分析主要在我们的数据仓库上进行。
- 我所在的公司使用大数据进行比如安全监控，日志分析，系统链路跟踪，监控大盘，数仓，风控，用户画像，监控报警等
  实时日志，binlog，关系型数据库，hbase等->消息队列->实时离线（storm，flink，spark，hadoop，clickhouse）计算->写入存储数据源
- 电商行业用大数据处理的业务
  - 营销业务
    新老客判定：各渠道新老客判定，方便对比拉新成本。主要是流计算
    用户画像：用户的统计标签、数据挖掘类标签。提高补贴精准度，降低补贴成本。主要是批处理
  - 门店选址
    利用公开数据、公司内部数据，根据商场、常驻人口、社区条件、消费能力等预测能否支撑一家门店
  - 商品销量预测
    利用订单数据、天气、节假日、促销力度等十几种维度，预测商品的销量。避免缺货、压货
  - 履约调度
    利用订单数据、配送员数据，合理调度运力，降低配送超时率
  - 数据仓库
    把各业务的数据做出宽表，方便业务分析统计。如：以订单为中心，把商品、营销等数据集中在一处
- 大数据的不断沉淀，助推互联网侵入生活的方方面面，了解你的吃穿住行等 
  如电商，可以挖掘用户喜好，做推荐算法，让消费者更快更精准的找到自己想要的东西，提高转化率和粘度 
  在制造领域，可以利用大量的数据，建立模型，训练出优秀智能机器人帮助我们提高生活效率以及质量。 
  在善意方面：解决人们的生活工作社交等问题，比如：天气预报，股票走势，智能医疗等 
  在恶意方面：窃取个人信息，判断你的个人状况，猜测你需要什么，来诱导你落入局 利用你的行为，不断的驯化你的感知，让你成瘾等
  数据本身没价值，如果做善则造福社会，作恶则后患无穷，典型的如一些app时间杀手，搜索推荐等
- 汽车流通领域的供应链，主要用到大数据相关的技术栈如下：
  - 大数据存储（HBase\HDFS）
    数仓建设（Hive、Spark）
    大数据批处理计算（MapReduce、Spark）
    大数据实时计算（Flink）
  - 大数据实现带来的价值：
    数仓建设，可以集中化存储业务数据，进行统一数据维护及管理
    基于业务数据的数据清洗及分析，构建更多纬度的数据，为业务发展及决策作参考
    大数据的集中化管理可以为业务提供更方便的大数据查询相关功能
    大数据为业务提供风控能力
- 目前工作在互联网电商行业，公司规模不是很大，算是startup的公司，目前公司的数据业务规模不是很大，主要是用来做商品推荐，所以没有特别要讲的，这里主要针对整个电商行业来看看大数据处理有哪 些典型的应用场景， 
  - 网站流量分析 
    用户分析, 主要包括用户画像和用户行为 
    产品分析: 产品分析主要结合应用画像，挖掘一个品类的潜在用户，首先找出此品类已有的用户， 
    然后通过这些用户的行为、偏好、画像等信息对用户细分，挖掘其独有的特征，最后通过这些特征 建立模型定位出该品类的潜在用户。 
    运营活动分析: 运营分析主要针对的是运营活动前、活动中、活动后的分析，包括活动前的预期分析、用户分析、市场策划等，活动中的效果监控、A/B test，活动后的专题活动分析等。比如像观向报表、观向数据这些数据产品。 
    竞对市场分析 
    物流分析 
    KPI分析 
- 用户在APP的操作是核心行为数据，通过对用户行为的埋点数据采集，辅以互联网业务的分析模型（漏斗、留存、事件、路径）等，从不同的业务角度分析用户在APP中的表现。
  比如通过分析会员页面的浏览次数和转换率的关系，能够看出随着浏览次数增多，转换提升。但是转化率有上限，更高的次数也无法提升。
  通过这种行为表现，在接近转化率峰值的次数前，增强营销手段，促进转化。
- 目前公司主要使用大数据处理用户行为数据、页面访问数据、交易数据、资产数据等等。 目前实现的价值 
  1)主要用于描述用户画像，为客户分群，为公司运营部门精准营销提供客户数据，便于业务推广。
   2)对公司App进行优化，调整App的功能设计以及首屏业务优先级 
- 我所在领域，利用大数据分析用户口味，喜好。分析不同年龄段用户的喜好等， 外卖业务，同城配送等。
  - 实现的价值：
    更好的用户推荐他们喜欢的产品，争取在第一页就让用户能够挑选的合适的产品。
    更好的提高运行效率，分析不同区域订单情况，来分配外卖员的位置。
    更好的节约成本
- 我目前所在的公司，使用的大数据场景较少，了解到是这些业务
  1、日志分析，分析日志中的错误，按照分类进行统计，形成指标数据
  2、用户行为分析，通过埋点，抓取用户浏览记录，对用户进行画像。
  我认为可以通过大数据实现的价值是：
  1、精准分析系统运行状况，实施监控系统指标，保证系统的稳定性，可用性。
  2、通过对用户进行画像，了解用户特征，对用户进行聚类，为不同用户制定不同的运营策略。



2.分析如下 HiveQL，生成的 MapReduce 执行程序，map 函数输入是什么？输出是什么？reduce函数输入是什么？输出是什么？

```sql
INSERT OVERWRITE TABLE pv_users
SELECT pv.pageid, u.age
FROM page_view pv
	JOIN user u
	ON (pv.userid = u.userid);
```

page_view 表 和 user 表结构与数据示例如下。

![1611554208202](ArchitectureAdvanced.assets/1611554208202.png)

map函数输入的是key value。 key是偏移量，value是一行记录<userid，pageid>或<userid，age>

| key    | value   |
| ------ | ------- |
| 偏移量 | <111,1> |
| 偏移量 | <111,2> |
| 偏移量 | <222,1> |

| key    | value    |
| ------ | -------- |
| 偏移量 | <111,25> |
| 偏移量 | <222,32> |

map函数输出是key value。key是userid， value是 <表编号，pageid> 或 <表编号，age>

| key  | value  |
| ---- | ------ |
| 111  | <1,1>  |
| 111  | <1,2>  |
| 222  | <1,1>  |
| 111  | <2,25> |
| 222  | <2,32> |

reduce函数输入是key values。key 是 userid , values是相同userid合并的value列表： <表编号，pageid> <表编号，age>

| key  | values             |
| ---- | ------------------ |
| 111  | <1,1> <1,2> <2,25> |
| 222  | <1,1> <2,32>       |

reduce输出是不同表的value进行join的结果

| 1    | 25   |
| ---- | ---- |
| 2    | 25   |
| 1    | 32   |



### Spark

#### Spark VS Hadoop

![1611828354764](ArchitectureAdvanced.assets/1611828354764.png)



#### Spark 特点（Spark 为什么更快）

DAG（有向无环图）切分的多阶段计算过程更快速

使用内存存储中间计算结果更高效

RDD 的编程模型更简单



#### Spark WordCount 编程示例

```java
val textFile = sc.textFile("hdfs://...")
val counts = textFile.flatMap(line => line.split(""))
  								.map(word => (word, 1))
  								.reduceByKey(_ + _)
counts.saveAsTextFile("hdfs://...")
```

第1行代码: 根据HDFS路径生成一个输入数据RDD。  

第2行代码: 在输入数据RDD上执行3个操作,得到一个新的RDD              

- 将输入数据的每一行文本用空格拆分成单词。  
- 将每个单词进行转换, word=>(word,1),生成的结构。  
- 相同的Key进行统计, 统计方式是对 Value求和 (_ + _)

第3行代码: 将这个RDD保存到HDFS。

![1611828827542](ArchitectureAdvanced.assets/1611828827542.png)



#### 作为编程模型的 RDD

RDD是 Spark的核心概念, 是弹性分布式数据集( Resilient Distributed Datasets)的缩写。RDD既是 Spark面向开发者的编程模型, 又是 Spark自身架构的核心元素。      

作为 Spark编程模型的RDD。我们知道,大数据计算就是在大规模的数据集上进行一系列的数据计算处理。 MapReduce针对输入数据,将计算过程分为两个阶段,一个Map 阶段,一个 Reduce阶段,可以理解成是面向过程的大数据计算。我们在用  MapReduce 编程的时候,思考的是,如何将计算逻辑用Map和 Reduce两个阶段实现,  map和 reduce函数的输入和输出是什么, MapReduce是面向过程的。      

而 Spark则直接针对数据进行编程, 将大规模数据集合抽象成一个RDD对象,然后在这个RDD上进行各种计算处理,得到一个新的RDD,继续计算处理,直到得到最后的  结果数据。所以 Spark可以理解成是面向对象的大数据计算。我们在进行 Spark编程的时候,思考的是一个RDD对象需要经过什么样的操作,转换成另一个RDD对象,思考的重心和落脚点都在RDD上。

Word Count的代码示例里, 第2行代码实际上进行了3次RDD转换,每次转换都得到一个新的RDD, 因为新的RDD可以继续调用RDD的转换函数,所以连续写成一行代码。 事实上,可以分成3行。  

```java
val rdd1 = textFile.flatMap(line => line.split(" "))  
val rdd2 = rdd.map(word => (word, 1))    
val rdd3 = rdd2.reduceByKey(_ + _)      
```

RDD上定义的函数分两种,一种是转换 (transformation) 函数,这种函数的返回值还是 RDD; 另一种是执行(action)函数,这种函数不再返回RDD      

RDD定义了很多转换操作函数, 比如有计算map(func)、过滤 filter(func)、合并数据集 union(otherDataset)、根据key聚合 reduceByKey(func, [numPartitions])、连接数据集join(otherdataset, [numPartions])、分组 groupByKey([numPartions]) 等十几个函数。



#### 作为数据分片的 RDD

跟 MapReduce 一样, Spark也是对大数据进行分片计算, Spark分布式计算的数据分片、任务调度都是以RDD为单位展开的,每个RDD分片都会分配到一个执行进程去处理。      

RDD上的转换操作又分成两种, 一种转换操作产生的RDD不会出现新的分片, 比如 map、 filter等, 也就是说一个RDD数据分片,经过map或 filter转换操作后,结果还在当前分片。就像你用map函数对每个数据加1,得到的还是这样一组数据,只是值不同。实际上, Spark并不是按照代码写的操作顺序去生成RDD,比如    

```java
rdd = rdd1.map(func)  
```

这样的代码并不会在物理上生成一个新的 RDD。物理上, Spark只有在产生新的 RDD 分片时候,才会在物理上真的生成一个 RDD, Spark的这种特性也被称作惰性计算。

另一种转换操作产生的RDD则会产生新的分片, 比如 reduceByKey,来自不同分片的相同 Key必须聚合在一起进行操作, 这样就会产生新的RDD分片。然而,实际执行过程中, 是否会产生新的RDD分片,并不是根据转换函数名就能判断出来的。

![1611829758024](ArchitectureAdvanced.assets/1611829758024.png)



#### Spark 的计算阶段

和 MapReduce 一个应用一次只运行一个map和一个reduce不同，Spark可以根据应用的复杂程度，分割成更多的计算阶段（stage)，这些计算阶段组成一个有向无环图DAG，Spark任务调度器可以根据 DAG的依赖关系执行计算阶段。

![1611829833553](ArchitectureAdvanced.assets/1611829833553.png)

这个 DAG 对应的 Spark 程序伪代码如下：

```java
rddB = rddA.groupBy(key)
  
rddD = rddC.map(func)
rddF = rddD.union(rddE)
  
rddG = rddB.join(rddF)
```

整个应用被切分成3个阶段, 阶段3需要赖阶段1和阶段2,阶段1和阶段2互不依赖。 Spark在执行调度的时候,先执行阶段1和阶段2,完成以后,再执行阶段3。如果有更多的阶段, Spark的策略也是一样的。只要根据程序初始化好 DAG, 就建立了依赖关系, 然后根据依赖关系顺序执行各个计算阶段, Spark大数据应用的计算就完成了。

Spark作业调度执行的核心是 DAG,有了DAG, 整个应用就被切分成哪些阶段, 每个阶段的依赖关系也就清楚了。之后再根据每个阶段要处理的数据量生成相应的任务集合(TaskSet), 每个任务都分配一个任务进程去处理, Spark就实现了大数据的分布式计算。      

负责 Spark应用DAG生成和管理的组件是 DAGScheduler, DAGScheduler根据程序代码生成DAG, 然后将程序分发到分布式计算集群, 按计算阶段的先后关系调度执行。      

那么 Spark划分计算阶段的依据是什么呢? 显然并不是RDD上的每个转换函数都会生成一个计算阶段, 比如上面的例子有4个转换函数,但是只有3个阶段。      

当RDD之间的转换连接线呈现多对多交叉连接的时候,就会产生新的阶段。一个RDD代表一个数据集, 图中每个RDD里面都包含多个小块, 每个小块代表RDD的一个分片。

Spark 也需要通过 shuffle 将数据进行重新组合，相同Key的数据放在一起，进行聚合、关联等操作，因而每次shuffle都产生新的计算阶段。这也是为什么计算阶段会有依赖关系，它需要的数据来源于前面一个或多个计算阶段产生的数据，必须等待前面的阶段执行完毕才能进行shuffle，并得到数据。

计算阶段划分的依据是 shuffle，不是转换函数的类型，有的函数有时候有shuffle，有时候没有。例子中RDD B和RDD F进行join，得到RDD G，这里的RDD F需要进行shuffle，RDDB就不需要。

![1611830364394](ArchitectureAdvanced.assets/1611830364394.png)



#### Spark 的作业管理      

Spark里面的 RDD函数有两种, 一种是转换函数,调用以后得到的还是一个RDD, RDD的计算逻辑主要通过转换函数完成。      

另一种是 action函数, 调用以后不再返回RDD比如 count()函数,返回RDD中数据的元素个数; saveAsTextFile(path),将RDD数据存储到path路径下。 Spark的 DAGScheduler在遇到 shuffle的时候, 会生成一个计算阶段, 在遇到 action函数的时候, 会生成一个作业(job)。      

RDD里面的每个数据分片, Spark都会创建一个计算任务去处理, 所以一个计算阶段会包含很多个计算任务(task)。

![1611830507045](ArchitectureAdvanced.assets/1611830507045.png)



#### Spark 的执行过程

Spark 支持 Standalone、Yarn、Mesos、Kubernetes 等多种部署方案，集中部署方案原理也都一样，只是不同组件角色命名不同，但是核心功能和运行流程都差不多。

![1611830643992](ArchitectureAdvanced.assets/1611830643992.png)

首先，Spark应用程序启动在自己的 JVM进程里，即 Driver进程，启动后调用 SparkContext初始化执行配置和输入数据。SparkContext 启动 DAGScheduler构造执行的 DAG图，切分成最小的执行单位也就是计算任务。

然后Driver向Cluster Manager 请求计算资源，用于 DAG的分布式计算。Cluster Manager收到请求以后，将 Driver的主机地址等信息通知给集群的所有计算节点Worker。

Worker收到信息以后，根据 Driver的主机地址，跟 Driver通信并注册，然后根据自己的空闲资源向 Driver通报自己可以领用的任务数。Driver根据DAG图开始向注册的 Worker分配任务。

Worker 收到任务后，启动Executor 进程开始执行任务。Executor先检查自己是否有Driver的执行代码，如果没有，从Driver 下载执行代码，通过Java反射加载后开始执行。



#### Spark 生态体系

![1611830891427](ArchitectureAdvanced.assets/1611830891427.png)



### 流计算

#### Storm 实时的 Hadoop

实时计算系统

- 低延迟
- 高性能
- 分布式
- 可伸缩
- 高可用



#### Storm 的基本概念

- Nimbus: 负责资源分配和任务调度。  
- Supervisor: 负责接受 Nimbus 分配的任务启动和停止属于自己管理的 Worker进程。  
- Worker: 运行具体处理组件逻辑的进程。  
- Task:  Worker中每一个 Spout/bolt的线程称为一个Task
- Topology: Storm 中运行的一个实时应用程序, 因为各个组件间的消息流动形成逻辑上的一个拓扑结构。      
- Spout: 在一个 Topology 中产生源数据流的组件。通常情况下 Spout会从外部数据源中读取数据,然后转换为 Topology 内部的源数据。 Spout是一个主动的角色, 其接口中有个 nextTuple() 函数, Storm框架会不停地调用此函数,用户只要在其中生成源数据即可。      
- Bolt: 在一个 Topology 中接受数据然后执行处理的组件。Bolt可以执行过滤、函数操作、合并、写数据库等任何操作。Bolt是一个被动的角色,其接口中有个 execute(Tuple input) 函数在接受到消息后会调用此函数,  用户可以在其中执行自己想要的操作。      
- Tuple: 一次消息传递的基本单元。本来应该是一个key-value 的map,但是由于各个组件间传递的 tuple 的字段名称已经事先定义好,所以 tuple中只要按序填入各个 value就行了,所以就是一个 value list.      
- Stream: 源源不断传递的 tuple就组成了 stream

![1611831046546](ArchitectureAdvanced.assets/1611831046546.png)

![1611831514582](ArchitectureAdvanced.assets/1611831514582.png)



#### example

当车辆超越 80 公里每小时，则记录下来。

使用的一个类型日志，其中包含的车辆数据信息有：车牌号，车辆行驶的速度以及数据获取的位置。

![1611831643907](ArchitectureAdvanced.assets/1611831643907.png)



#### topology

![1611831659221](ArchitectureAdvanced.assets/1611831659221.png)



#### Spout

![1611831705453](ArchitectureAdvanced.assets/1611831705453.png)



#### Bolt

![1611831734647](ArchitectureAdvanced.assets/1611831734647.png)



#### StormMain

```java
public class StormMain {
  	public static void main(String[] args) throws AlreadyAliveException, InvalidTopologyException, InterruptedException {
        ParallelFileSpout parallelFileSpout = new ParallelFileSpout();
        ThresholdBolt thresholdBolt = new ThresholdBolt);
        DBWriterBolt dbWriterBolt= new DBWriterBolt():
        TopologyBuilder builder = new TopologyBuilder();
      
        builder.setSpout("spout", parallelFileSpout, 1);
        builder.setBolt("thresholdBolt", thresholdBolt, 1).shuffleGrouping("spout");
      	builder.setBolt("dbWriterBolt", dbWriterBolt,1).shuffleGrouping("thresholdBolt");
      if (this.argsMain != null && this.argsMain.length > O) {
        	conf.setNumWorkers(1);
          StormSubmitter.submitTopology(this.argsMain[0], conf, builder.createTopology());
      } else {
        	Config conf= new Config();
          conf.setDebug(true);
          conf.setMaxTaskParallelism(3);
          LocalCluster cluster = new LocalCluster();
          cluster.submitTopology("Threshold_Test", conf, builder.createTopology()); 
      }
    }
}
```



#### Stream Groupings

Stream Grouping 定义了一个流在 Bolt任务间该如何被切分。这里有 Storm提供的6个Stream Grouping 类型：

- 随机分组（Shuffle grouping)：随机分发tuple 到Bolt的任务，保证每个任务获得相等数量的 tuple。
- 字段分组（Fields grouping）：根据指定字段分割数据流，并分组。例如，根据“user-id”字段，相同“user-id”的元组总是分发到同一个任务，不同“user-id”的元组可能分发到不同的任务。
- 全部分组（All grouping）：tuple被复制到Bolt的所有任务。这种类型需要谨慎使用。
- 全局分组（Global grouping）：全部流都分配到Bolt的同一个任务。明确地说，是分配给ID最小的那个Task。
- 无分组（None grouping）：你不需要关心流是如何分组。目前，无分组等效于随机分组。但最终，Storm将把无分组的Bolts 放到Bolts或Spouts 订阅它们的同一线程去执行（如果可能）。
- 直接分组（Direct grouping)：这是一个特别的分组类型。元组生产者决定tuple由哪个元组处理者任务接收。
- 当然还可以实现CustomStreamGroupimg 接口来定制自己需要的分组。



#### Storm应用场景(淘宝)        

Storm 被广泛用来进行实时日志处理, 出现在实时统计、实时风控、实时推荐等场景中。

一般来说, 我们从类 Kafka的 metaq 或者基于 HBase的 TimeTunnel 中读取实时日志消息, 经过一系列处理, 最终将处理结果写入到一个分布式存储中,提供给应用程序访问。

我们每天的实时消息量从几百万到几十亿不等, 数据总量达到TB级。对于我们来说,  Storm往往会配合分布式存储服务一起使用。在我们正在进行的个性化搜索实时分析项目中,就使用了 TimeTunnel + HBase + Storm + UPS 的架构,每天处理几十亿的用户日志信息,从用户行为发生到完成分析延迟在秒级。



#### Spark Streaming

- 将流分段后，分批次执行

![1611832477560](ArchitectureAdvanced.assets/1611832477560.png)



#### Flink

示例程序

```java
// Flink 流处理计算
StreamExecutionEnvironment see = StreamExecutionEnvironment.getExecutionEnvironment();
DataStream<WikipediaEditEvent> edits = see.addSource(new WikipediaEditsSource());

// Flink 批处理计算
ExecutionEnvironment env = ExecutionEnvironment.getExecutionEnvironment();
DataSet<String>	text = env.readTextFile("/path/to/file");
```

Word Count 示例程序

```java
public class WordCountExample {
    public static void main(String[] args) throws Exception {
        final ExecutionEnvironment env = ExecutionEnvironment.getExecutionEnvironment();
      
        DataSet<String> text = env.fromElements(
        "Who's there?",
        "I think I hear them. Stand, ho! Who's there?");
       
      	DataSet<Tuple2<String, Integer>> wordCounts = text
          	.flatMap(new LineSplitter())
            .groupBy(0)
            .sum(1);
      
        wordCounts.print();
    }
}
```





#### Flink 架构

![1611832889779](ArchitectureAdvanced.assets/1611832889779.png)



### HiBench

#### HiBench 介绍

HiBench是 Intel开放的一个 Hadoop Benchmark Suit,包含9个典型的 Hadoop负载                                                

- Micro benchmarks   
  - Sort
  - WordCount
  - TeraSort         
- HDFS benchmarks      
  - DFSIO
- web search benchmarks       
  - Nutch indexing  
  - PageRank     
- machine learning benchmarks      
  - Mahout Bayesian classification
  - Mahout K-means clustering  
- data analytics benchmarks   
  - Hive Query Benchmarks

主页是 https://github.com/Intel-bigdata/HiBench





#### Micro Benchmarks

Sort (sort): 使用 Hadoop RandomTextWriter 生成数据,并对数据进行排序。        

WordCount (wordcount): 统计输入数据中每个单词的出现次数, 输入数据使用  Hadoop RandomTextWriter生成。        

TeraSort (terasort): 这是由微软的数据库大牛 Jim Gray(2007年失踪) 创建的标准  benchmark, 输入数据由 Hadoop TeraGen产生。



#### HDFS Benchmarks

增强的 DFSIO(dfsioe)：通过产生大量同时执行读写请求的任务来测试 Hadoop 集群的 HDFS 吞吐量。



#### Web search benchmarks 

Nutch indexing（nutchindexing）：大规模搜索引擎索引是 MapReduce的一个重要应用,这个负载测试 Nutch (Apache的一个开源搜索引擎) 的索引子系统,使用自动生成的Web数据, Web数据中的链接和单词符合 Zipfian分布。     

PageRank (pagerank): 这个负载包含一种在 Hadoop上的 PageRank算法实现, 使用自动生成的Web数据, Web数据中的链接符合 Zipfian分布。



#### Data Analytics Benchmarks        

Hive Query Benchmarks (hivebench): 这个负载的开发基于 SIGMOD 09 的一篇论文 “A Comparison of Approaches to Large-Scale Data Analysis"和 HIVE-396,包含执行典型 OLAP 查询的 Hive查询(Aggregation and Join), 使用自动生成的Web数据, Web数据中的链接符合 Zipfian分布。



#### Machine Learning Benchmarks        

Mahout Bayesian classification(bayes): 大规模机器学习也是 MapReduce的一个重要应用,这个负载测试 Mahout 0.7( Apache 的一个开源机器学习库) 中的Naive  Bayesian 训练器, 输入数据是自动生成的文档,文档中的单词符合 Zipfian分布。        

Mahout K-means clustering( kmeans): 这个负载测试 Mahout 0.7中的 k-means 聚类算法,输入数据集由基于均匀分布和高斯分布的 GenKMeansDataset 产生。



#### 安装与配置        

建立环境:

- Hiench-2.2:  从 https://github.com/Intel-bigdata/HiBench/releases/tag/HiBench-2.2 下载
- Hadoop: 在运行任何负载之前,请确保 Hadoop环境能正常运行,所有负载在 Cloudera  Distribution of Hadoop 3 update 4(cdh3u4) 和 Hadoop1.0.3上测试通过。      
- Hive: 如果要测试 hivebench,请确保已正确建立了Hive环境。

配置所有负载：

- 需要在 ${HIBENCH_HOME}/bin/hibench-config.sh 文件中设置一些全局的环境变量。

![1611834130599](ArchitectureAdvanced.assets/1611834130599.png)

配置单个负载：

- 在每个负载目录下，可以修改 conf/configure.sh 这个文件，设置负载运行的参数。

同步每个节点的时间

单独运行每个负载：

- 可以单独运行每个负载，通常在每个负载目录下游三个不同的文件：

![1611834205271](ArchitectureAdvanced.assets/1611834205271.png)



### Beyond Hive-Standard SQL on Hadoop

- [Beyond Hive-Standard SQL on Hadoop.pdf](Data/Beyond Hive-Standard SQL on Hadoop.pdf)
- [Beyond Hive-Standard SQL on Hadoop.pptx](Data/Beyond Hive-Standard SQL on Hadoop.pptx)



### Cloudera Impala

- [Cloudera Impala](Data/Cloudera Impala.pptx)



### Panthera SQL92 Test

- [Panthera SQL92 Test](Data/Panthera SQL92 Test.pptx)



### Spark源码性能优化案例分析

- [Spark源码性能优化案例分析](Data/Spark源码性能优化案例分析.pptx)



### 一个利用数据分析发现运营异常的案例分析

- [一个利用数据分析发现运营异常的案例分析](Data/一个利用数据分析发现运营异常的案例分析.pdf)





### 大数据可视化

#### 数据大屏

![1612079216472](ArchitectureAdvanced.assets/1612079216472.png)



#### 互联网运营常用数据指标

##### 新增用户数

新增用户数是网站增长性的关键指标，指新增加的访问网站的用户数（或者新下载App的用户数），对于一个处于爆发期的网站，新增用户数会在短期内出现倍增的走势，是网站的战略机遇期，很多大型网站都经历过一个甚至多个短期内用户暴增的阶段。

新增用户数有日新增用户数、周新增用户数、月新增用户数等几种统计口径。



##### 用户留存率/流失率

新增的用户并不一定总是对网站(App)满意, 在使用网站(App)后感到不满意,可能会注销账户(卸载App),这些辛苦获取来的用户就流失掉了。网站把经过一段时间依然没有流失的用户称作留存用户,留存用户数比当期新增用户数就是用户留存率。

用户留存率 = 留存用户数/当期新增用户数        

计算留存有时间窗口, 即和当期数据比3天前新增用户留存的,称作3日留存; 相应的,还有5日留存、7日留存等。新增用户可以通过广告、促销、病毒营销等手段获取,  但是要让用户留下来, 就必须要使产品有实打实的价值。用户留存率是反映用户体验和产品价值的一个重要指标,一般说来,3日留存率能做到40%以上就算不错了。和用户留存率对应的是用户流失率。        

用户流失率 =1 - 用户留存率
        



##### 活跃用户数

用户下载注册，但是很少打开产品，表示产品缺乏黏性和吸引力。

活跃用户数表示打开使用产品的用户数，根据统计口径不同，有日活跃用户数、月活跃用户数等。提升活跃是网站运营的重要目标，各类App常用推送优惠促销消息给用户的手段促使用户打开产品。



##### PV（Page View）

打开产品就算活跃,打开以后是否频繁操作,就用PV这个指标衡量,用户每次点击,每个页面跳转,被称为一个PV( Page View)。

PV是网页访问统计的重要指标,在移动App, 需要进行一些变通来进行统计。



##### GWV（Gross Merchandise Volume）

GWV 即成交总金额( Gross Merchandise Volume),是电商网站统计营业额(流水)、反映网站营收能力的重要指标。

和GMV配合使用的还有订单量(用户下单总量)、客单价 (单个订单的平均价格) 等。



##### 转化率

转化率是指在电商网站产生购买行为的用户与访问用户之比。

转化率 = 有购买行为的用户数 / 总访问用户数

用户从进入网站（App）到最后购买成功，可能需要经过复杂的访问路径，每个环节都有可能会离开：

- 进入首页想了想没什么要买的，然后离开；
- 搜索结果看了看不想买，然后离开；
- 进入商品详情页面，看看评价、看看图片、看看价格，然后离开；
- 放入购物车后又想了想自己的钱包，然后离开；
- 支付的时候发现不支持自己喜欢的支付方式，然后离开.…

一个用户从进入网站到支付，完成一笔真正的消费，中间会有很大概率流失，网站必须要想尽各种办法：个性化推荐、打折促销、免运费、送红包、分期支付，以留住用户，提高转化率。



#### 数据可视化图表与数据监控

##### 折线图

折线图是用的最多的可视化图表之一,通常横轴为时间,用于展示在时间维度上的数据变化规律,正向指标(比如日活跃用户数)斜率向上, 负向指标(比如用户流失率)斜率向下,  都表示网站运营日趋良好,公司发展欣欣向荣。

![1612079991913](ArchitectureAdvanced.assets/1612079991913.png)



##### 散点图

数据分析的时候，散点图可以有效帮助分析师快速发现数据分布上的规律与趋势，可谓肉眼聚类算法。

![1612080072859](ArchitectureAdvanced.assets/1612080072859.png)



##### 热力图

热力图用以分析网站页面被用户访问的热点区域，以更好进行页面布局和视觉展示。

在地图上展示的热力图，则表示了该地区的拥堵和狙击状态，方便用户进行出行规划。

![1612080084753](ArchitectureAdvanced.assets/1612080084753.png)



##### 漏斗图

漏斗图可谓是网站数据分析中最重要的图标，表示在用户的整个访问路径中每一步的转化率。

![1612080261266](ArchitectureAdvanced.assets/1612080261266.png)



### 大数据算法与机器学习

#### 网页排名算法 PageRank

PageRank，网页排名，又称为网页级别，Google 左侧排名或佩奇排名，是一种由搜索引擎根据网页之间相互的超链接计算的技术，而作为网页排名的要素之一，以Google公司创始人 拉里·佩奇（Larry Page）之姓来命名。



#### PageRank 让链接来投票

PageRank 通过网络浩瀚的超链接关系来确定一个页面的等级。

Google 把从A页面到B页面的链接解释为A页面给B页面投票， Google根据投票来源（甚至来源的来源，即链接到A页面的页面）和投票目标的等级来决定新的等级。简单的说，一个高等级的页面可以使其他低等级页面的等级提升。

一个页面的「得票数」由所有链向它的页面的重要性來决定，到一个页面的超链接相当于对该页投一票。一个页面的 PageRank是由所有链向它的页面（「链入页面」）的重要性经过递归算法得到的。一个有较多链入的页面会有较高的等级，相反如果一个页面没有任何链入页面，那么它没有等级。

![1610546485462](ArchitectureAdvanced.assets/1610546485462.png)



#### PageRank 算法

假设一个 由4个页面组成的小团体：A，B，C和D。如果所有页面都链向A，那么A的PR（PageRank）值将是 B，C和D的 PageRank 总和。

![1610546606409](ArchitectureAdvanced.assets/1610546606409.png)

继续假设B也有链接到C,并且D也有链接到包括A的3个页面。一个页面不能投票2次。所以B给每个页面半票。以同样的逻辑,D投出的票只有三分之一算到了A的  PageRank上。

![1610546673741](ArchitectureAdvanced.assets/1610546673741.png)

换句话说，根据链出总数平分一个页面的 PR 值。

![1610546724919](ArchitectureAdvanced.assets/1610546724919.png)

互联网中一个网页只有对自己的出链，或者几个网页的出链形成一个循环圈。那么在不断地迭代过程中，这一个或几个网页的PR值将只增不减，显然不合理。

如下图中的C网页，就是刚刚说的是有对自己的出链的网页。

![1610546738204](ArchitectureAdvanced.assets/1610546738204.png)

为了解决这个问题。我们想象一个随机浏览网页的人,假定他有一个确定的概率会输入网址直接跳转到一个随机的网页,并且跳转到每个网页的概率是一样的。于是则此图中A  的PR值可表示为：

![1610546902180](ArchitectureAdvanced.assets/1610546902180.png)

PageRank 计算公式：

![1610546936925](ArchitectureAdvanced.assets/1610546936925.png)

PageRank值是一个特殊矩阵中的特征向量。这个特征向量为：

![1610546983011](ArchitectureAdvanced.assets/1610546983011.png)

![1610546993931](ArchitectureAdvanced.assets/1610546993931.png)





#### KNN 分类算法

KNN 算法，也叫K近邻（K Nearest Neighbour)算法。

对于一个需要分类的数据，将其和一组已经分类标注好的样本集合进行比较，得到距离最近的K个样本，K个样本最多归属的类别，就是这个需要分类数据的类别。

![1612082602430](ArchitectureAdvanced.assets/1612082602430.png)

![1612082620257](ArchitectureAdvanced.assets/1612082620257.png)



#### 数据的距离算法

对于数据 Xi 和 xj，若其特征空间为 n 维实数向量空间 Rn，即 xi = (xi1, xi2,... , xin)， xj = (xj1, xj2,... , xjn)。

欧式距离计算公式

![1612082835786](ArchitectureAdvanced.assets/1612082835786.png)

余弦相似度计算公式

![1612082846409](ArchitectureAdvanced.assets/1612082846409.png)

#### 提取文本的特征值 TF-IDF 算法

TF 是词频（Term Frequency），表示某一个单词在文档中出现的频率。

![1612083047845](ArchitectureAdvanced.assets/1612083047845.png)

IDF 是逆文档频率（Inverse Document Frequency），表示这个单词在所有文档中的稀缺程度。

![1612083061158](ArchitectureAdvanced.assets/1612083061158.png)



#### 贝叶斯分类算法

贝叶斯公式

![1611410738268](ArchitectureAdvanced.assets/1611410738268.png)

举例：假设一所学校里男生占 60%，女生占 40%。男生总是穿长裤，女生则一半穿长裤一半穿裙子。假设你走在校园中，迎面走来一个穿长裤的学生，你能够推断出这个穿长裤学生是男生的概率是多少吗？

利用贝叶斯公式可知是 75%。

![1611410768232](ArchitectureAdvanced.assets/1611410768232.png)



#### K-means 聚类算法

![1612083224318](ArchitectureAdvanced.assets/1612083224318.png)

第1步：随机在图中取K个种子点，图中K=2，即图中的实心小圆点。

第2步：求图中所有点到这K个种子点的距离，假如一个点离种子点X最近，那么这个点属于X点群。在图中，可以看到A、B属于上方的种子点，C、D、E属于中部的种子点。

第3步：对已经分好组的两组数据，分别求其中心点。对于图中二维平面上的数据，求中心点最简单暴力的算法就是对当前同一个分组中所有点的X坐标和丫坐标分别求平均值，得到的就是中心点。

第4步：重复第2步和第3步，直到每个分组的中心点不再移动。这时候，距每个中心点最近的点数据聚类为同一组数据。

![1612083237330](ArchitectureAdvanced.assets/1612083237330.png)





#### 搜索引擎算法

- 豆瓣的，喜欢这部电影的人也喜欢。。。。

![1612083354414](ArchitectureAdvanced.assets/1612083354414.png)



#### 基于人口统计的推荐

- 假设：用户属于同一类群体，爱好应该相同

![1612085314257](ArchitectureAdvanced.assets/1612085314257.png)



#### 基于商品属性的推荐

- 假设：同一类的商品也会被喜欢

![1612085328206](ArchitectureAdvanced.assets/1612085328206.png)



#### 基于用户的协同过滤推荐

- 假设：同一个用户会喜欢同一个商品。

![1612085350169](ArchitectureAdvanced.assets/1612085350169.png)



#### 基于用户的协同过滤推荐

- 假设：同类商品，其他的用户也会喜欢。

![1612090476995](ArchitectureAdvanced.assets/1612090476995.png)



#### 机器学习系统架构

![1612090555982](ArchitectureAdvanced.assets/1612090555982.png)



#### 样本

样本就是通常我们常说的“训练数据”，包括输入和结果两部分。比如我们要做一个自动化新闻分类的机器学习系统，对于采集的每一篇新闻，能够自动发送到对应新闻分类频道里面，比如体育、军事、财经等。这时候我们就需要批量的新闻和其对应的分类类别作为训练数据。通常随机选取一批现成的新闻素材就可以，但是分类需要人手工进行标注，也就是需要有人阅读每篇新闻，根据其内容打上对应的分类标签。

T = (×1,y1),(x2,y2).…(xn,yn)

其中xn 表示一个输入，比如一篇新闻；yn表示一个结果，比如这篇新闻对应的类别。



#### 模型

模型就是映射样本输入与样本结果的函数, 可能是一个条件概率分布,也可能是一个决策函数。一个具体的机器学习系统所有可能的函数构成了模型的假设空间,数学表示是:      
$$
F = f | Y = f(X)
$$
其中X 是样本输入,Y 是样本输出,f 就是建立和映射关系的函数所有f 的可能结果构成了模型的假设空间 F 。  

很多时候F 的函数类型是明确的, 需要计算的是函数的参数, 比如确定f 函数为一个线性函数,那么f 的函数表示就可以写为:      
$$
y = a_1 x + a_0
$$
这时候需要计算的就是a1和a0两个参数的值。这种情况下模型的假设空间的数学表示  是:      
$$
F = { f|Y = f_{\theta}(X), \theta \in R^n}
$$
其中θ 为f 函数的参数取值空间,一个n 维欧氏空间,被称作参数空间。



#### 算法

算法就是要从模型的假设空间中寻找一个最优的函数, 使得样本空间的输入X 经过该函数的映射得到的f(X), 和真实的Y 值之间的距离最小。这个最优的函数通常没办法直接计算得到, 即没有解析解,需要用数值计算的方法不断迭代求解。因此如何寻找到f 函数的全局最优解,以及使寻找过程尽量高效,就构成了机器学习的算法。        

如何保证f 函数或者f 函数的参数空间最接近最优解, 就是算法的策略。机器学习中用**损失函数**来评估模型是否最接近最优解。损失函数用来计算模型预测值与真实值的差距常用的有0-1损失函数、平方损失函数、绝对损失函数、对数损失函数等。

以平方损失函数为例,损失函数如下
$$
L（Y, f(X)） = (Y - f(X))^2
$$
对于一个给定的样本数据集
$$
T = { (x_1, y_1), (x_2, y_2), ...,(x_n, y_n)}
$$
模型 f(X) 相对于真实值的平均损失为每个样本的损失函数的求和平均值：
$$
R_{emp}(f) = \frac{1}{N} 
\sum_{i=1}^{N}  L(y_i, f(x_i))
$$
这个值被称作经验风险，如果样本量足够大，那么使经验风险最小的 f 函数就是模型的最优解，即求
$$
\underset{f\in F}{min} \frac{1}{N} \sum_{i=1}^{N} L\left ( y_i, f\left ( x_i \right )   \right )
$$
但是相对于样本空间的可能取值范围, 实际中使用的样本量总是有限的,可能会出现使样本经验风险最小的模型f 函数并不能使实际预测值的损失函数最小,这种情况被称作过拟合,即一味追求经验风险最小,而使模型f 函数变得过于复杂,偏离了最优解。

这种情况下,需要引入结构风险以防止过拟合。结构风险表示为:
$$
R_{srm}(f) = \frac{1}{N} 
\sum_{i=1}^{N}  L(y_i, f(x_i)) + \lambda J（f）
$$
在经验风险的基础上加上$ \lambda J（f）$ ,其中 J(f) 表示模型f 的复杂度,模型越复杂, J(f) 越大要使结构风险最小, 就要使经验风险和模型复杂度同时小。求解模型最优解就变成求解结构风险最小值:
$$
\underset{f\in F}{min} \frac{1}{N} \sum_{i=1}^{N} L\left ( y_i, f\left ( x_i \right )   \right )  + \lambda J（f）
$$


#### 机器学习的数学原理

给定模型类型,也就是给定函数类型的情况下,如何寻找使结构风险最小的函数表达式。  由于函数类型已经给定, 实际上就是求函数的参数。各种有样本的机器学习算法基本上都是在各种模型的假设空间上求解结构风险最小值的过程,理解了这一点也就理解了各种机器学习算法的推导过程。        

机器学习要从假设空间寻找最优函数,而最优函数就是使样本数据的函数值和真实值距离最小的那个函数。

给定函数模型,求最优函数就是求函数的参数值。给定不同参数得到不同函数值和真实值的距离,这个距离就是损失,损失函数是关于模型参数的函数,  距离越小,损失越小。最小损失值对应的函数参数就是最优函数。  

数学上求极小值就是求一阶导数, 计算每个参数的一阶导数为零的偏微分方程组,就可以算出最优函数的参数值。这就是为什么机器学习要计算偏微分方程的原因。





#### 感知机

感知机是一种比较简单的二分类模型，将输入特征分类为 +1、-1 两类，就像下图所示的，一条直线将平面上的两类点分类。

![1612092425962](ArchitectureAdvanced.assets/1612092425962.png)

感知机模型如下：
$$
f（x） = sign (w · x + b)
$$
其中 x 代表输入的特征空间向量，输出空间是 {-1, +1}，w 为权值向量，b 叫做偏置，sign 是一个符号函数。
$$
sign(x) = 
\begin{cases}
  & \text{ +1 }, x\ge 0 \\
  & \text{ -1 }, x< 0
\end{cases}
$$
训练感知机模型就是要计算出w 和 b 值，当有新的数据需要分类的时候，输入感知机模型就可以计算出 +1 或者 -1 从而进行分类。

由于输出空间只有 {-1，+1} 两个值，所以只有误分类的时候，才会有模型计算值和样本真实值之间的偏差，偏差之和就是感知机的损失函数。
$$
L（w, b） = - \sum_{x_i \in M} y_i (w · x_i + b)
$$
其中M 为误分类点集合，误分类点越少，损失函数的值越小；如果没有误分类点，损失函数值为 0。求模型的参数 w和b，就是求损失函数的极小值。

数学上求函数的极小值就是求函数的一阶导数，但是感知机损失函数用统计求和函数表达，没办法计算解析解。机器学习采用梯度下降法求损失函数极小值，实质上就是求导过程的数值计算方法。

对于误分类点集合 M，损失函数 L(w, b) 变化的梯度，就是某个函数变量的变化引起的函数值的变化，根据感知机损失函数可知：
$$
\bigtriangleup _w L(w, b) = - \sum_{x_i \in M} y_i · x_i 
\\
\bigtriangleup _b L(w, b) = - \sum_{x_i \in M} y_i 
$$
使用梯度下降更新 w 和 b，不断迭代使损失函数 L(w, b) 不断减小，直到为 0，也就是没有误分类点。

感知机算法的实现过程：

- 1.选择初始值 w0, b0。
- 2.在样本集合中选择样本数据 xi, yi。
- 3.如果yi（w·xi + b）< 0，表示yi 为误分类点，那么w = w+n yixi、b = b+nyi，在梯度方向校正w和b。其中n为步长，步长选择要适当，步长太长会导致每次计算调整太大出现震荡；步长太短又会导致收敛速度慢、计算时间长。
- 4.跳转回2，直到样本集合中没有误分类点，即全部样本数据 yi（w·xi+b)≥0。



#### 神经网络

$$
sign(x) = 
\begin{cases}
  & \text{ +1 }, x\ge 0 \\
  & \text{ -1 }, x< 0
\end{cases}
$$

![1612093317866](ArchitectureAdvanced.assets/1612093317866.png)

![1612093331492](ArchitectureAdvanced.assets/1612093331492.png)



#### 神经网络在手写数字识别中的应用

![1612093348316](ArchitectureAdvanced.assets/1612093348316.png)

![1612093410243](ArchitectureAdvanced.assets/1612093410243.png)



#### 神经网络与围棋 AI

![1612093427366](ArchitectureAdvanced.assets/1612093427366.png)









### 作业与实践

1.你所在的行业，常用的数据分析指标有哪些？请简述。

2.Google 搜索引擎是如何对搜索结果进行排序的？（请用自己的语言描述 PageRank 算法）



### 













